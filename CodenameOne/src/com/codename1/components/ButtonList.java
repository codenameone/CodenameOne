/*
 * Copyright (c) 2012, Codename One and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Codename One designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Codename One through http://www.codenameone.com/ if you
 * need additional information or have any questions.
 */
package com.codename1.components;

import com.codename1.ui.ButtonGroup;
import com.codename1.ui.Component;
import com.codename1.ui.Container;
import com.codename1.ui.RadioButton;
import com.codename1.ui.events.ActionEvent;
import com.codename1.ui.events.ActionListener;
import com.codename1.ui.events.ActionSource;
import com.codename1.ui.events.DataChangedListener;
import com.codename1.ui.events.SelectionListener;
import com.codename1.ui.layouts.Layout;
import com.codename1.ui.list.DefaultListModel;
import com.codename1.ui.list.ListModel;
import com.codename1.ui.list.MultipleSelectionListModel;
import com.codename1.ui.util.EventDispatcher;

import java.util.ArrayList;
import java.util.Arrays;

/// An abstract base class for a list of buttons.  Most useful for grids of toggle widgets such as Radio Buttons,
/// CheckBoxes, and Switches.  There are concrete implementations for `Switch` (`SwitchList`), `RadioButton` (`RadioButtonList`,
/// and `CheckBox` (`CheckBoxList`).
///
/// This abstraction allows you to work with a set of toggle buttons as a single unit.  It uses
/// a `ListModel` to store the toggle options, and will automatically stay in sync with its model
/// when options are added or removed, or the selection is changed.
///
/// ```java
/// package com.codename1.testproj;
///
/// import com.codename1.components.CheckBoxList;
/// import com.codename1.components.RadioButtonList;
/// import com.codename1.components.SwitchList;
/// import static com.codename1.ui.CN.*;
/// import com.codename1.io.Log;
/// import com.codename1.ui.Button;
/// import com.codename1.ui.Form;
/// import com.codename1.ui.Dialog;
/// import com.codename1.ui.layouts.BorderLayout;
/// import com.codename1.ui.layouts.BoxLayout;
/// import com.codename1.ui.layouts.FlowLayout;
/// import com.codename1.ui.plaf.UIManager;
/// import com.codename1.ui.util.Resources;
/// import com.codename1.ui.Toolbar;
/// import com.codename1.ui.Command;
/// import com.codename1.ui.TextField;
/// import com.codename1.ui.layouts.GridLayout;
/// import com.codename1.ui.list.DefaultListModel;
/// import com.codename1.ui.table.TableLayout;
/// import java.util.Arrays;
///
/// /**
///  * This file was generated by [Codename One](https://www.codenameone.com/) for the purpose
///  * of building native mobile applications using Java.
///  */
/// public class TestProject {
///
///     private Form current;
///     private Resources theme;
///
///     public void init(Object context) {
///         // use two network threads instead of one
///         updateNetworkThreadCount(2);
///
///         theme = UIManager.initFirstTheme("/theme");
///
///         // Enable Toolbar on all Forms by default
///         Toolbar.setGlobalToolbar(true);
///
///         // Pro only feature
///         Log.bindCrashProtection(true);
///
///         addNetworkErrorListener(err -> {
///             // prevent the event from propagating
///             err.consume();
///             if(err.getError() != null) {
///                 Log.e(err.getError());
///             }
///             Log.sendLogAsync();
///             Dialog.show("Connection Error", "There was a networking error in the connection to " + err.getConnectionRequest().getUrl(), "OK", null);
///         });
///     }
///
///     public void start() {
///         if(current != null){
///             current.show();
///             return;
///         }
///
///         testButtonLists();
///     }
///
///     public void testButtonLists() {
///         Form hi = new Form("Hi", new BorderLayout());
///
///         SwitchList switchList = new SwitchList(new DefaultListModel("Red", "Green", "Blue", "Indigo"));
///         switchList.addActionListener(e->{
///             Log.p("Action event received from "+e.getSource());
///             Log.p("Selected indices: "+Arrays.toString(switchList.getMultiListModel().getSelectedIndices()));
///         });
///
///         Button clearSelections = new Button("Clear");
///         clearSelections.addActionListener(e -> {
///             switchList.getMultiListModel().setSelectedIndices();
///         });
///
///         Button addOption = new Button("Add Option");
///         addOption.addActionListener(e -> {
///             callSerially(()->{
///                 TextField val = new TextField();
///                 Command res = Dialog.show("Enter label", val, new Command("OK"));
///                 switchList.getMultiListModel().addItem(val.getText());
///
///             });
///         });
///
///         RadioButtonList layoutSelector = new RadioButtonList(new DefaultListModel("Flow", "X", "Y", "2-Col Table", "3-Col Table", "2 Col Grid", "3 Col Grid"));
///         layoutSelector.addActionListener(e->{
///             switch (layoutSelector.getModel().getSelectedIndex()) {
///                 case 0: switchList.setLayout(new FlowLayout());
///                 break;
///                 case 1: switchList.setLayout(BoxLayout.x());
///                 break;
///                 case 2: switchList.setLayout(BoxLayout.y());
///                 break;
///                 case 3: switchList.setLayout(new TableLayout(switchList.getComponentCount()/2+1, 2));
///                 break;
///                 case 4: switchList.setLayout(new TableLayout(switchList.getComponentCount()/3+1, 3));
///                 break;
///                 case 5: switchList.setLayout(new GridLayout(2));
///                 break;
///                 case 6: switchList.setLayout(new GridLayout(3));
///             }
///             switchList.animateLayout(300);
///         });
///
///         CheckBoxList checkBoxList = new CheckBoxList(switchList.getMultiListModel());
///         checkBoxList.addActionListener(e-> {
///             System.out.println("CheckBox actionEvent.  "+Arrays.toString(checkBoxList.getMultiListModel().getSelectedIndices()));
///         });
///         hi.add(BorderLayout.NORTH, layoutSelector);
///         hi.add(BorderLayout.CENTER, BoxLayout.encloseY(checkBoxList, switchList));
///         hi.add(BorderLayout.SOUTH, GridLayout.encloseIn(2, addOption, clearSelections));
///         hi.show();
///
///     }
///
///     public void stop() {
///         current = getCurrentForm();
///         if(current instanceof Dialog) {
///             ((Dialog)current).dispose();
///             current = getCurrentForm();
///         }
///     }
///
///     public void destroy() {
///     }
///
/// }
/// ```
///
/// Examples
///
/// **Switch List in a FlowLayout:**
///
/// ```java
/// `SwitchList switchList = new SwitchList(new DefaultListModel("Red", "Green", "Blue", "Indigo"));
/// switchList.setLayout(new FlowLayout());`
/// ```
///
/// **Switch List in a BoxLayout.Y:**
///
/// *
/// ```java
/// `SwitchList switchList = new SwitchList(new DefaultListModel("Red", "Green", "Blue", "Indigo"));
/// switchList.setLayout(BoxLayout.y());`
/// ```
///
/// **Switch List in a Grid Layout:**
///
/// **Switch List in a Table Layout:**
///
/// **2 Columns:**
///
/// ```java
/// `SwitchList switchList = new SwitchList(new DefaultListModel("Red", "Green", "Blue", "Indigo"));
/// switchList.setLayout(new TableLayout(switchList.getComponentCount()/2+1, 2));`
/// ```
///
/// **3 Columns:**
///
/// ```java
/// `SwitchList switchList = new SwitchList(new DefaultListModel("Red", "Green", "Blue", "Indigo"));
/// switchList.setLayout(new TableLayout(switchList.getComponentCount()/3+1, 3));`
/// ```
///
/// @author Steve Hannah
///
/// #### Since
///
/// 6.0
public abstract class ButtonList extends Container implements DataChangedListener, SelectionListener, ActionListener, ActionSource {
    private final EventDispatcher actionListeners = new EventDispatcher();
    private final java.util.List<Runnable> onReady = new ArrayList<Runnable>();
    private final boolean allowMultipleSelection;
    protected boolean ready;
    private ButtonGroup group;
    private ListModel model;
    private String cellUIID;
    private java.util.List<Decorator> decorators;

    /// Creates a new ButtonList.
    ///
    /// #### Parameters
    ///
    /// - `model`: The options.  Each will be represented by a button.
    ///
    /// - `allowMultipleSelection`: indicates that multiple selection is allowed or not
    protected ButtonList(ListModel model, boolean allowMultipleSelection) {
        this.allowMultipleSelection = allowMultipleSelection;
        if (model instanceof DefaultListModel && allowMultipleSelection) {
            ((DefaultListModel) model).setMultiSelectionMode(true);
        }
        setModel(model);
    }

    /// Wrap any calls that requires that the infrastructure is ready inside this.
    ///
    /// #### Parameters
    ///
    /// - `r`: Will be run when buttons are ready to be generated.
    protected void onReady(Runnable r) {
        if (ready) {
            r.run();
        } else {
            onReady.add(r);
        }
    }

    /// This should be called by the concrete implementation once it is ready to generate the
    /// buttons.
    protected final void fireReady() {
        ready = true;
        for (Runnable r : onReady) {
            r.run();
        }
        onReady.clear();
    }

    /// For multi-selection models (e.g. for checkbox or switch lists), this will return the
    /// model as a `MultiSelectionListModel`.  Otherwise it will return null.
    ///
    /// #### Returns
    ///
    /// The model.
    public MultipleSelectionListModel getMultiListModel() {
        if (model instanceof MultipleSelectionListModel) {
            return (MultipleSelectionListModel) model;
        }
        return null;
    }

    /// Returns the model.
    ///
    /// #### Returns
    ///
    /// The model
    public ListModel getModel() {
        return model;
    }

    public final void setModel(ListModel model) {
        if (model != this.model) { //NOPMD CompareObjectsWithEquals
            if (this.model != null) {
                this.model.removeDataChangedListener(this);
                this.model.removeSelectionListener(this);
            }
            this.model = model;
            if (this.model != null) {
                this.model.addDataChangedListener(this);
                this.model.addSelectionListener(this);
            }
            if (ready) {
                refresh();
            } else {
                onReady(new Runnable() {
                    @Override
                    public void run() {
                        refresh();
                    }
                });
            }
        }
    }

    /// Creates a new button for this list. Should be implemented by subclasses to create the correct kind of button.
    ///
    /// #### Parameters
    ///
    /// - `model`
    protected abstract Component createButton(Object model);

    /// Sets the given button's selected state.
    ///
    /// #### Parameters
    ///
    /// - `button`: The button (in the form produced by `#createButton`.
    ///
    /// - `selected`: Whether the button is selected or not.
    protected abstract void setSelected(Component button, boolean selected);

    /// Sets the layout for the list.  This refresh the list to match the new layout.
    ///
    /// #### Parameters
    ///
    /// - `layout`: @param layout The layout to use.  Only layouts that don't require constraints in `com.codename1.ui.Component)`
    /// may be used.  E.g. `FlowLayout`, `BoxLyout`, `TableLayout`, `GridLayout` are all fine.
    @Override
    public void setLayout(Layout layout) {
        if (layout != this.getLayout()) { //NOPMD CompareObjectsWithEquals
            super.setLayout(layout);
            refresh();
        }
    }

    /// Refreshes the container - regenerating all of the buttons in the list from
    /// the model.  This usually doesn't ever need to be called explicitly as it will be called
    /// automatically when the model changes, or the layout changes.
    public void refresh() {
        group = new ButtonGroup();

        removeAll();
        int selectedIndex = getModel().getSelectedIndex();
        int[] selectedIndices = new int[0];
        if (getModel() instanceof MultipleSelectionListModel) {
            selectedIndices = getMultiListModel().getSelectedIndices();
        }
        int len = model.getSize();
        for (int i = 0; i < len; i++) {
            Component b = createComponent(model.getItemAt(i));
            if (allowMultipleSelection) {
                if (Arrays.binarySearch(selectedIndices, i) >= 0) {
                    setSelected(b, true);
                }
            } else {
                if (i == selectedIndex) {
                    setSelected(b, true);
                }
            }
            add(b);
        }

    }

    private Component createComponent(Object model) {
        Component b = createButton(model);
        b = decorateComponent(model, b);
        return b;
    }

    /// Decorates buttons.  This allows subclasses to add event listeners
    /// to buttons.
    ///
    /// #### Parameters
    ///
    /// - `b`: The button in the form returned by `#createButton(java.lang.Object)`
    ///
    /// #### Returns
    ///
    /// Should pass back the same component it receives.
    protected Component decorateComponent(Object modelItem, Component b) {
        if (cellUIID != null) {
            setUIID(cellUIID);
        }
        if (b instanceof RadioButton) {
            group.add((RadioButton) b);
        }
        if (decorators != null) {
            for (Decorator d : decorators) {
                d.decorate(modelItem, b);
            }
        }
        return b;
    }

    /// Undecorates buttons.  This allows subclasses to remove event listeners from
    /// buttons.
    ///
    /// #### Parameters
    ///
    /// - `b`: The button in the form returned by `#createButton(java.lang.Object)`
    ///
    /// #### Returns
    ///
    /// Should pass back the same component it receives.
    protected Component undecorateComponent(Component b) {
        if (decorators != null) {
            for (Decorator d : decorators) {
                d.undecorate(b);
            }
        }

        if (b instanceof RadioButton) {
            group.remove((RadioButton) b);
        }

        return b;
    }

    // When the list model is changed, this fires
    // This should allow us to keep the buttons in sync
    // with the model
    @Override
    public void dataChanged(int status, int index) {
        switch (status) {
            case DataChangedListener.ADDED:
                this.addComponent(index, createComponent(model.getItemAt(index)));
                break;
            case DataChangedListener.CHANGED: {
                Component cmp = undecorateComponent(this.getComponentAt(index));
                this.removeComponent(cmp);
                this.addComponent(index, createComponent(model.getItemAt(index)));
                break;
            }
            case DataChangedListener.REMOVED: {
                Component cmp = undecorateComponent(this.getComponentAt(index));
                this.removeComponent(cmp);
                break;
            }
            default:
                break;
        }
    }

    // Called when the selection is changed in the model
    @Override
    public void selectionChanged(int oldSelected, int newSelected) {
        if (allowMultipleSelection) {
            if (oldSelected < 0 && newSelected >= 0) {
                Component cmp = newSelected < getComponentCount() ? getComponentAt(newSelected) : null;
                if (cmp != null) {
                    setSelected(cmp, true);
                }
            } else if (oldSelected >= 0 && newSelected < 0) {
                Component cmp = oldSelected < getComponentCount() ? getComponentAt(oldSelected) : null;
                if (cmp != null) {
                    setSelected(cmp, false);
                }
            } else {
                Component old = getComponentAt(oldSelected);
                if (old != null) {
                    setSelected(old, false);
                }
                Component cmp = newSelected < getComponentCount() ? getComponentAt(newSelected) : null;
                if (cmp != null) {
                    setSelected(cmp, true);
                }
            }
        } else {
            if (newSelected >= 0) {
                Component cmp = newSelected < getComponentCount() ? getComponentAt(newSelected) : null;
                if (cmp != null) {
                    setSelected(cmp, true);
                }
            }
            if (oldSelected >= 0) {
                Component cmp = oldSelected < getComponentCount() ? getComponentAt(oldSelected) : null;
                setSelected(cmp, false);
            }
        }
    }

    // Called when one of the buttons within the list fires an action event.
    // This should just propagate the event.
    @Override
    public void actionPerformed(ActionEvent evt) {
        if (evt.getSource() instanceof Component && contains((Component) evt.getSource())) {
            ActionEvent nevt = new ActionEvent(this, evt.getEventType(), evt.getActualComponent(), evt.getX(), evt.getY());
            actionListeners.fireActionEvent(nevt);
        }
    }

    /// Add a listener to be notified when any of the buttons in the list are pressed.
    ///
    /// #### Parameters
    ///
    /// - `l`
    @Override
    public void addActionListener(ActionListener l) {
        actionListeners.addListener(l);
    }

    /// Remove a listener so that it no longer is notified when buttons in the list are pressed.
    ///
    /// #### Parameters
    ///
    /// - `l`
    @Override
    public void removeActionListener(ActionListener l) {
        actionListeners.removeListener(l);
    }

    /// Sets the UIID for cells of the list.  Each cell will be a component as returned by the
    /// concrete implementation's `#createButton(java.lang.Object)` method.
    ///
    /// #### Parameters
    ///
    /// - `uiid`
    public void setCellUIID(String uiid) {
        cellUIID = uiid;
        for (Component c : this) {
            c.setUIID(cellUIID);
        }
    }

    /// Adds a decorator that can be used to customize a button when it is created
    ///
    /// #### Parameters
    ///
    /// - `decorator`: A decorator.
    public void addDecorator(Decorator decorator) {
        if (decorators == null) {
            decorators = new ArrayList<Decorator>();
        }
        decorators.add(decorator);
    }

    /// Removes a decorator.
    ///
    /// #### Parameters
    ///
    /// - `decorator`
    public void removeDecorator(Decorator decorator) {
        if (decorators != null) {
            decorators.remove(decorator);
        }
    }

    /// An interface that can be implemented to provide custom decoration/undecoration of the buttons as they are
    /// created/removed.  This will allow you to do things like add custom icons or styles to the buttons.
    ///
    /// #### Parameters
    ///
    /// - `The`: type used for the model item.
    ///
    /// - `The`: @param  The type used for the view.  For RadioList T would be RadioButton.  For CheckBoxList, T would be CheckBox.  For SwitchList it's different because
    /// the Switch uses a wrapper component.
    public interface Decorator<M, V extends Component> { // PMD Fix: UnnecessaryModifier removed redundant static
        void decorate(M modelItem, V viewItem); // PMD Fix: UnnecessaryModifier removed redundant public

        void undecorate(V viewItem); // PMD Fix: UnnecessaryModifier removed redundant public
    }

}
