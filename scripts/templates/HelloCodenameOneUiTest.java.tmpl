package @PACKAGE@;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.os.SystemClock;
import android.util.DisplayMetrics;
import android.view.TextureView;
import android.view.View;
import android.view.ViewGroup;

import com.codename1.impl.android.AndroidImplementation;
import com.codename1.ui.Display;
import com.codename1.ui.Form;
import com.codename1.ui.Image;
import com.codename1.ui.util.ImageIO;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.android.controller.ActivityController;
import org.robolectric.annotation.Config;
import org.robolectric.annotation.LooperMode;
import org.robolectric.shadows.ShadowLooper;

@RunWith(RobolectricTestRunner.class)
@Config(sdk = 30)
@LooperMode(LooperMode.Mode.LEGACY)
public class @MAIN_NAME@UiTest {

    private static final long STARTUP_TIMEOUT_MS = 30_000L;
    private static final long LAYOUT_TIMEOUT_MS = 5_000L;
    private static final long EDT_TIMEOUT_MS = 10_000L;

    private ActivityController<@MAIN_NAME@Stub> controller;
    private @MAIN_NAME@Stub activity;

    @Before
    public void setUp() throws Exception {
        controller = Robolectric.buildActivity(@MAIN_NAME@Stub.class);
        activity = controller.setup().get();
        bootstrapCodenameOneApp();
        waitForCodenameOneForm();
    }

    @After
    public void tearDown() {
        if (controller != null) {
            controller.pause();
            controller.stop();
            controller.destroy();
        }
    }

    @Test
    public void mainFormScreenshotContainsRenderedContent() throws Exception {
        View decorView = activity.getWindow().getDecorView();
        assertNotNull("Activity decor view should be available", decorView);

        Bitmap androidScreenshot = captureAndroidScreenshot(decorView);
        assertTrue("Android screenshot width should be positive", androidScreenshot.getWidth() > 0);
        assertTrue("Android screenshot height should be positive", androidScreenshot.getHeight() > 0);
        assertTrue(
                "Android screenshot should contain rendered content beyond the background",
                hasRenderableContent(androidScreenshot));

        File androidScreenshotFile = saveBitmap(androidScreenshot, "@MAIN_NAME@-android-ui.png");
        assertTrue("Android screenshot file should exist", androidScreenshotFile.isFile());
        assertTrue("Android screenshot file should not be empty", androidScreenshotFile.length() > 0L);

        Image codenameOneScreenshot = captureCodenameOneScreenshot();
        assertNotNull("Codename One screenshot should be available", codenameOneScreenshot);
        assertTrue("Codename One screenshot width should be positive", codenameOneScreenshot.getWidth() > 0);
        assertTrue("Codename One screenshot height should be positive", codenameOneScreenshot.getHeight() > 0);
        assertTrue(
                "Codename One screenshot should contain rendered content beyond the background",
                hasRenderableContent(codenameOneScreenshot));

        File codenameOneScreenshotFile = saveCodenameOneScreenshot(
                codenameOneScreenshot,
                "@MAIN_NAME@-codenameone-ui.png");
        assertTrue("Codename One screenshot file should exist", codenameOneScreenshotFile.isFile());
        assertTrue("Codename One screenshot file should not be empty", codenameOneScreenshotFile.length() > 0L);
    }

    private Bitmap captureAndroidScreenshot(View decorView) throws Exception {
        ensureViewHasLayout(decorView);
        ShadowLooper.runUiThreadTasksIncludingDelayedTasks();
        flushCodenameOneGraphics();
        ShadowLooper.runUiThreadTasksIncludingDelayedTasks();

        View codenameOneSurface = findCodenameOneSurface(decorView);
        Bitmap surfaceBitmap = captureSurfaceBitmap(codenameOneSurface);
        if (surfaceBitmap != null && hasRenderableContent(surfaceBitmap)) {
            return surfaceBitmap;
        }

        return captureBitmap(decorView);
    }

    private static Bitmap captureBitmap(View view) {
        Bitmap bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(bitmap);
        view.draw(canvas);
        return bitmap;
    }

    private static void ensureViewHasLayout(View view) {
        long deadline = SystemClock.uptimeMillis() + LAYOUT_TIMEOUT_MS;
        DisplayMetrics metrics = view.getResources().getDisplayMetrics();
        int widthSpec = View.MeasureSpec.makeMeasureSpec(metrics.widthPixels, View.MeasureSpec.EXACTLY);
        int heightSpec = View.MeasureSpec.makeMeasureSpec(metrics.heightPixels, View.MeasureSpec.EXACTLY);

        while ((view.getWidth() == 0 || view.getHeight() == 0) && SystemClock.uptimeMillis() < deadline) {
            view.measure(widthSpec, heightSpec);
            view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight());
            ShadowLooper.runUiThreadTasksIncludingDelayedTasks();
            SystemClock.sleep(16L);
        }

        if (view.getWidth() == 0 || view.getHeight() == 0) {
            throw new AssertionError("Timed out waiting for decor view to obtain layout bounds");
        }
    }

    private static boolean hasRenderableContent(Bitmap screenshot) {
        int width = screenshot.getWidth();
        int height = screenshot.getHeight();
        int[] pixels = new int[width * height];
        screenshot.getPixels(pixels, 0, width, 0, 0, width, height);
        return hasRenderableContent(pixels, width, height);
    }

    private static boolean hasRenderableContent(Image screenshot) throws Exception {
        int width = screenshot.getWidth();
        int height = screenshot.getHeight();
        int[] pixels = callSeriallyAndWait(screenshot::getRGB);
        return hasRenderableContent(pixels, width, height);
    }

    private static boolean hasRenderableContent(int[] pixels, int width, int height) {
        if (width <= 0 || height <= 0 || pixels == null || pixels.length == 0) {
            return false;
        }
        int background = pixels[0];
        int contentPixels = 0;
        for (int argb : pixels) {
            int alpha = (argb >>> 24) & 0xFF;
            if (alpha == 0) {
                continue;
            }
            if (argb != background) {
                contentPixels++;
                if (contentPixels > width) {
                    return true;
                }
            }
        }
        return false;
    }

    private static File saveBitmap(Bitmap screenshot, String fileName) throws IOException {
        File outputDir = resolveArtifactDirectory();
        File screenshotFile = new File(outputDir, fileName);
        try (FileOutputStream out = new FileOutputStream(screenshotFile)) {
            if (!screenshot.compress(Bitmap.CompressFormat.PNG, 100, out)) {
                throw new IOException("Failed to encode Android screenshot as PNG");
            }
        }
        return screenshotFile;
    }

    private static File saveCodenameOneScreenshot(Image screenshot, String fileName) throws Exception {
        File outputDir = resolveArtifactDirectory();
        File screenshotFile = new File(outputDir, fileName);
        ImageIO io = callSeriallyAndWait(() -> Display.getInstance().getImageIO());
        assertNotNull("Codename One ImageIO should be available", io);
        try (FileOutputStream out = new FileOutputStream(screenshotFile)) {
            FileOutputStream stream = out;
            callSeriallyAndWait(() -> {
                io.save(screenshot, stream, ImageIO.FORMAT_PNG, 1.0f);
                return null;
            });
        }
        return screenshotFile;
    }

    private static File resolveArtifactDirectory() throws IOException {
        String directory = System.getenv("CN1_TEST_SCREENSHOT_DIR");
        File outputDir = (directory != null && !directory.isEmpty())
                ? new File(directory)
                : new File("build/ui-test-screenshots");
        if (!outputDir.exists() && !outputDir.mkdirs()) {
            throw new IOException("Failed to create screenshot directory " + outputDir.getAbsolutePath());
        }
        return outputDir;
    }

    private static void waitForCodenameOneForm() {
        long deadline = SystemClock.uptimeMillis() + STARTUP_TIMEOUT_MS;
        while (SystemClock.uptimeMillis() < deadline) {
            ShadowLooper.runUiThreadTasksIncludingDelayedTasks();
            if (Display.isInitialized()) {
                Form current = Display.getInstance().getCurrent();
                if (current != null) {
                    return;
                }
            }
            SystemClock.sleep(16L);
        }
        throw new AssertionError("Timed out waiting for Codename One main form to be displayed");
    }

    private void bootstrapCodenameOneApp() throws Exception {
        runOnMainSync(() -> AndroidImplementation.startContext(activity));
        if (!Display.isInitialized()) {
            runOnMainSync(() -> Display.init(activity));
        }
        if (!Display.isInitialized()) {
            throw new AssertionError("Codename One Display failed to initialize");
        }
        callSeriallyAndWait(() -> {
            @MAIN_NAME@ app = @MAIN_NAME@Stub.getAppInstance();
            boolean needsInit = isStubFirstStart(app);
            if (app == null) {
                app = new @MAIN_NAME@();
                assignStubAppInstance(app);
                needsInit = true;
            }
            if (needsInit) {
                app.init(activity);
            }
            app.start();
            markStubFirstTimeConsumed();
            return null;
        });
    }

    private void runOnMainSync(Runnable runnable) {
        activity.runOnUiThread(runnable);
        ShadowLooper.runUiThreadTasksIncludingDelayedTasks();
    }

    private static Image captureCodenameOneScreenshot() throws Exception {
        return callSeriallyAndWait(() -> Display.getInstance().captureScreen());
    }

    private static Bitmap captureSurfaceBitmap(View view) {
        if (view == null) {
            return null;
        }
        if (view instanceof TextureView) {
            Bitmap bitmap = ((TextureView) view).getBitmap();
            if (bitmap != null) {
                return bitmap;
            }
        }

        Bitmap reflectionBitmap = extractCodenameOneViewBitmap(view);
        if (reflectionBitmap != null) {
            return reflectionBitmap;
        }

        if (view instanceof ViewGroup) {
            ViewGroup group = (ViewGroup) view;
            for (int i = 0; i < group.getChildCount(); i++) {
                Bitmap childBitmap = captureSurfaceBitmap(group.getChildAt(i));
                if (childBitmap != null) {
                    return childBitmap;
                }
            }
        }
        return null;
    }

    private static Bitmap extractCodenameOneViewBitmap(View view) {
        try {
            Field cn1Field = view.getClass().getDeclaredField("cn1View");
            cn1Field.setAccessible(true);
            Object cn1View = cn1Field.get(view);
            if (cn1View != null) {
                Field bitmapField = cn1View.getClass().getDeclaredField("bitmap");
                bitmapField.setAccessible(true);
                Object bitmapValue = bitmapField.get(cn1View);
                if (bitmapValue instanceof Bitmap) {
                    Bitmap bitmap = (Bitmap) bitmapValue;
                    if (bitmap.getWidth() > 0 && bitmap.getHeight() > 0) {
                        Bitmap copy = bitmap.copy(Bitmap.Config.ARGB_8888, false);
                        if (copy == null) {
                            copy = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888);
                            Canvas canvas = new Canvas(copy);
                            canvas.drawBitmap(bitmap, 0f, 0f, null);
                        }
                        return copy;
                    }
                }
            }
        } catch (NoSuchFieldException ignored) {
            // View does not expose a Codename One backing field.
        } catch (IllegalAccessException e) {
            throw new RuntimeException("Unable to access Codename One view bitmap", e);
        }
        return null;
    }

    private static View findCodenameOneSurface(View root) {
        if (root == null) {
            return null;
        }
        if (root.getId() == 2001) {
            return root;
        }
        if (root.getClass().getName().contains("CodenameOne")) {
            return root;
        }
        if (root instanceof ViewGroup) {
            ViewGroup group = (ViewGroup) root;
            for (int i = 0; i < group.getChildCount(); i++) {
                View child = group.getChildAt(i);
                View match = findCodenameOneSurface(child);
                if (match != null) {
                    return match;
                }
            }
        }
        return null;
    }

    private static void flushCodenameOneGraphics() throws Exception {
        callSeriallyAndWait(() -> {
            Form current = Display.getInstance().getCurrent();
            if (current != null) {
                current.revalidate();
                current.repaint();
            }
            return null;
        });
        callSeriallyAndWait(() -> {
            AndroidImplementation impl = getAndroidImplementation();
            if (impl != null) {
                impl.flushGraphics();
            }
            return null;
        });
    }

    private static AndroidImplementation getAndroidImplementation() {
        try {
            Field implField = Display.class.getDeclaredField("impl");
            implField.setAccessible(true);
            Object impl = implField.get(null);
            if (impl instanceof AndroidImplementation) {
                return (AndroidImplementation) impl;
            }
            return null;
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new RuntimeException("Unable to access Codename One implementation", e);
        }
    }

    private static void assignStubAppInstance(@MAIN_NAME@ app) {
        try {
            Field appField = @MAIN_NAME@Stub.class.getDeclaredField("i");
            appField.setAccessible(true);
            appField.set(null, app);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new RuntimeException("Unable to assign Codename One application instance", e);
        }
    }

    private boolean isStubFirstStart(@MAIN_NAME@ appInstance) {
        try {
            Field firstTimeField = @MAIN_NAME@Stub.class.getDeclaredField("firstTime");
            firstTimeField.setAccessible(true);
            boolean firstTimeValue;
            if (java.lang.reflect.Modifier.isStatic(firstTimeField.getModifiers())) {
                firstTimeValue = firstTimeField.getBoolean(null);
            } else {
                firstTimeValue = firstTimeField.getBoolean(activity);
            }
            return firstTimeValue || appInstance == null;
        } catch (NoSuchFieldException ignored) {
            return appInstance == null;
        } catch (IllegalAccessException e) {
            throw new RuntimeException("Unable to inspect Codename One stub firstTime flag", e);
        }
    }

    private void markStubFirstTimeConsumed() {
        try {
            Field firstTimeField = @MAIN_NAME@Stub.class.getDeclaredField("firstTime");
            firstTimeField.setAccessible(true);
            if (java.lang.reflect.Modifier.isStatic(firstTimeField.getModifiers())) {
                firstTimeField.setBoolean(null, false);
            } else {
                firstTimeField.setBoolean(activity, false);
            }
        } catch (NoSuchFieldException ignored) {
            // Field absent in some stub variants; nothing to update.
        } catch (IllegalAccessException e) {
            throw new RuntimeException("Unable to update Codename One stub firstTime flag", e);
        }
    }

    private static <T> T callSeriallyAndWait(Callable<T> callable) throws Exception {
        CountDownLatch latch = new CountDownLatch(1);
        AtomicReference<T> result = new AtomicReference<>();
        AtomicReference<Throwable> error = new AtomicReference<>();
        Display.getInstance().callSerially(() -> {
            try {
                result.set(callable.call());
            } catch (Throwable t) {
                error.set(t);
            } finally {
                latch.countDown();
            }
        });
        boolean completed;
        try {
            completed = awaitLatch(latch, EDT_TIMEOUT_MS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw e;
        }
        if (!completed) {
            throw new AssertionError("Timed out waiting for Codename One EDT task to finish");
        }
        if (error.get() != null) {
            Throwable throwable = error.get();
            if (throwable instanceof Exception) {
                throw (Exception) throwable;
            }
            throw new RuntimeException(throwable);
        }
        return result.get();
    }

    private static boolean awaitLatch(CountDownLatch latch, long timeoutMs) throws InterruptedException {
        long deadline = SystemClock.uptimeMillis() + timeoutMs;
        while (SystemClock.uptimeMillis() < deadline) {
            if (latch.await(4L, TimeUnit.MILLISECONDS)) {
                return true;
            }
            ShadowLooper.runUiThreadTasksIncludingDelayedTasks();
        }
        return latch.await(0L, TimeUnit.MILLISECONDS);
    }
}
