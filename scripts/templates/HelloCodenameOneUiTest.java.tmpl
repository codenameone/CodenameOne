package @PACKAGE@;

import static org.junit.Assert.assertTrue;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.util.DisplayMetrics;
import android.view.View;

import com.codename1.ui.Display;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.concurrent.TimeUnit;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestRule;
import org.junit.rules.Timeout;
import org.junit.rules.TestWatcher;
import org.junit.runner.RunWith;
import org.junit.runner.Description;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.android.controller.ActivityController;
import org.robolectric.annotation.Config;
import org.robolectric.annotation.LooperMode;
import org.robolectric.shadows.ShadowLooper;

@RunWith(RobolectricTestRunner.class)
@Config(sdk = 30)
@LooperMode(LooperMode.Mode.LEGACY)
public class @MAIN_NAME@UiTest {

    private static final long TEST_TIMEOUT_SECONDS = 300L;

    private ActivityController<@MAIN_NAME@Stub> controller;
    private @MAIN_NAME@Stub activity;

    @Rule
    public final TestRule timeoutRule = Timeout.builder()
            .withTimeout(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS)
            .withLookingForStuckThread(true)
            .build();

    @Rule
    public final TestWatcher loggingWatcher = new TestWatcher() {
        @Override
        protected void starting(Description description) {
            log("Starting test method: " + description.getDisplayName());
        }

        @Override
        protected void succeeded(Description description) {
            log("Test method succeeded: " + description.getDisplayName());
        }

        @Override
        protected void failed(Throwable e, Description description) {
            logError("Test method failed: " + description.getDisplayName(), e);
            dumpAllThreads("Failure diagnostics for " + description.getDisplayName());
        }

        @Override
        protected void finished(Description description) {
            log("Finished test method: " + description.getDisplayName());
        }
    };

    @Before
    public void setUp() {
        log("Starting Robolectric activity for screenshot test");
        try {
            controller = Robolectric.buildActivity(@MAIN_NAME@Stub.class);
            log("ActivityController created");
        } catch (RuntimeException ex) {
            logError("Failed to create ActivityController", ex);
            throw ex;
        }
        log("Invoking controller.setup() to create/start/resume activity");
        try {
            activity = controller.setup().get();
            log("controller.setup() completed (Display.isInitialized=" + Display.isInitialized()
                    + ", activity=" + activity + ")");
        } catch (RuntimeException ex) {
            logError("controller.setup() threw an exception", ex);
            dumpAllThreads("controller.setup() failure diagnostics");
            throw ex;
        }
        log("Processing pending Codename One tasks after setup");
        try {
            ShadowLooper.runUiThreadTasksIncludingDelayedTasks();
            log("Initial runUiThreadTasksIncludingDelayedTasks call finished");
        } catch (RuntimeException ex) {
            logError("runUiThreadTasksIncludingDelayedTasks threw an exception", ex);
            throw ex;
        }
    }

    @After
    public void tearDown() {
        if (controller == null) {
            return;
        }
        safelyInvokeLifecycle(controller::pause, "pause");
        safelyInvokeLifecycle(controller::stop, "stop");
        safelyInvokeLifecycle(controller::destroy, "destroy");
    }

    @Test
    public void mainFormScreenshotContainsRenderedContent() throws Exception {
        log("Running screenshot assertions with prepared activity");
        log("Idling main looper to process pending tasks");
        try {
            ShadowLooper.runUiThreadTasksIncludingDelayedTasks();
            log("Completed runUiThreadTasksIncludingDelayedTasks");
        } catch (RuntimeException ex) {
            logError("runUiThreadTasksIncludingDelayedTasks during test threw an exception", ex);
            throw ex;
        }

        if (Display.isInitialized()) {
            log("Codename One display reports current form="
                    + Display.getInstance().getCurrent());
        } else {
            log("Codename One display not initialized; continuing with screenshot capture");
        }

        log("Capturing decor view screenshot without additional waits");
        Bitmap screenshot = captureScreenshot(activity);
        assertTrue("Screenshot capture should succeed", screenshot != null);
        log("Screenshot dimensions=" + screenshot.getWidth() + "x" + screenshot.getHeight());
        assertTrue("Screenshot width should be positive", screenshot.getWidth() > 0);
        assertTrue("Screenshot height should be positive", screenshot.getHeight() > 0);
        boolean hasContent = hasRenderableContent(screenshot);
        log("Screenshot content analysis result=" + hasContent);
        assertTrue("Screenshot should contain rendered content beyond the background", hasContent);

        File screenshotFile = saveScreenshot(screenshot);
        log("Screenshot stored at " + screenshotFile.getAbsolutePath());
        assertTrue("Screenshot file should exist", screenshotFile.isFile());
        assertTrue("Screenshot file should not be empty", screenshotFile.length() > 0L);
    }

    private static Bitmap captureScreenshot(@MAIN_NAME@Stub activity) {
        View decorView = activity.getWindow().getDecorView();
        log("Decor view instance=" + decorView);
        if (decorView == null) {
            throw new AssertionError("Activity decor view was null");
        }
        ensureViewHasLayout(decorView);
        log("Decor view layout dimensions after ensure: " + decorView.getWidth() + "x" + decorView.getHeight());
        Bitmap bitmap = Bitmap.createBitmap(decorView.getWidth(), decorView.getHeight(), Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(bitmap);
        decorView.draw(canvas);
        return bitmap;
    }

    private static boolean hasRenderableContent(Bitmap screenshot) {
        int width = screenshot.getWidth();
        int height = screenshot.getHeight();
        if (width <= 0 || height <= 0) {
            return false;
        }
        int[] pixels = new int[width * height];
        screenshot.getPixels(pixels, 0, width, 0, 0, width, height);
        if (pixels.length == 0) {
            return false;
        }
        int background = pixels[0];
        int contentPixels = 0;
        for (int argb : pixels) {
            int alpha = (argb >>> 24) & 0xFF;
            if (alpha == 0) {
                continue;
            }
            if (argb != background) {
                contentPixels++;
                if (contentPixels > width) {
                    return true;
                }
            }
        }
        return false;
    }

    private static File saveScreenshot(Bitmap screenshot) throws IOException {
        File outputDir = resolveArtifactDirectory();
        File screenshotFile = new File(outputDir, "@MAIN_NAME@-ui-test.png");
        try (FileOutputStream out = new FileOutputStream(screenshotFile)) {
            if (!screenshot.compress(Bitmap.CompressFormat.PNG, 100, out)) {
                throw new IOException("Failed to encode screenshot as PNG");
            }
        }
        return screenshotFile;
    }

    private static File resolveArtifactDirectory() throws IOException {
        String directory = System.getenv("CN1_TEST_SCREENSHOT_DIR");
        File outputDir = (directory != null && !directory.isEmpty()) ? new File(directory)
                : new File("build/ui-test-screenshots");
        if (!outputDir.exists() && !outputDir.mkdirs()) {
            throw new IOException("Failed to create screenshot directory " + outputDir.getAbsolutePath());
        }
        return outputDir;
    }

    private static File resolveArtifactDirectoryForLogging() {
        try {
            return resolveArtifactDirectory();
        } catch (IOException ex) {
            System.out.println("[@MAIN_NAME@UiTest] Unable to prepare artifact directory for logging: " + ex.getMessage());
            return null;
        }
    }

    private static void ensureViewHasLayout(View view) {
        if (view.getWidth() > 0 && view.getHeight() > 0) {
            log("ensureViewHasLayout: view already laid out with size " + view.getWidth() + "x" + view.getHeight());
            return;
        }
        DisplayMetrics metrics = view.getResources().getDisplayMetrics();
        int widthSpec = View.MeasureSpec.makeMeasureSpec(metrics.widthPixels, View.MeasureSpec.EXACTLY);
        int heightSpec = View.MeasureSpec.makeMeasureSpec(metrics.heightPixels, View.MeasureSpec.EXACTLY);
        view.measure(widthSpec, heightSpec);
        view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight());
        log("ensureViewHasLayout: forced layout to " + view.getWidth() + "x" + view.getHeight());
    }

    private static void log(String message) {
        String formatted = "[@MAIN_NAME@UiTest] " + message;
        System.out.println(formatted);
        appendLogLine(formatted);
    }

    private static void logError(String message, Throwable error) {
        log(message + ": " + error);
        StringWriter buffer = new StringWriter();
        error.printStackTrace(new PrintWriter(buffer));
        for (String line : buffer.toString().split("\r?\n")) {
            if (!line.isEmpty()) {
                log(line);
            }
        }
    }

    private static void safelyInvokeLifecycle(Runnable invocation, String name) {
        try {
            invocation.run();
            log("Activity " + name + " invoked");
        } catch (RuntimeException ex) {
            log("Lifecycle invocation " + name + " failed: " + ex);
        }
    }

    private static synchronized void appendLogLine(String message) {
        File directory = resolveArtifactDirectoryForLogging();
        if (directory == null) {
            return;
        }
        File logFile = new File(directory, "@MAIN_NAME@UiTest.log");
        try (FileWriter writer = new FileWriter(logFile, true); PrintWriter out = new PrintWriter(writer)) {
            out.println(message);
        } catch (IOException ex) {
            System.out.println("[@MAIN_NAME@UiTest] Failed to persist log entry: " + ex.getMessage());
        }
    }

    private static void dumpAllThreads(String reason) {
        log("Capturing thread dump: " + reason);
        Thread.getAllStackTraces().forEach((thread, stack) -> {
            log("Thread '" + thread.getName() + "' (id=" + thread.getId()
                    + ", state=" + thread.getState() + ")");
            if (stack.length == 0) {
                log("  <no stack trace>");
            } else {
                for (StackTraceElement element : stack) {
                    log("  at " + element);
                }
            }
        });
    }
}
