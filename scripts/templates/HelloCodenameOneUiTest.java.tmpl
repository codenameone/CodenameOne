package @PACKAGE@;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.util.DisplayMetrics;
import android.view.View;

import com.codename1.ui.Display;
import com.codename1.ui.Form;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.concurrent.atomic.AtomicInteger;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.android.controller.ActivityController;
import org.robolectric.annotation.Config;
import org.robolectric.annotation.LooperMode;
import org.robolectric.shadows.ShadowLooper;
import org.robolectric.util.Scheduler;

@RunWith(RobolectricTestRunner.class)
@Config(sdk = 30)
@LooperMode(LooperMode.Mode.PAUSED)
public class @MAIN_NAME@UiTest {

    @Test
    public void mainFormScreenshotContainsRenderedContent() throws Exception {
        log("Starting Robolectric activity for screenshot test");
        ActivityController<@MAIN_NAME@Stub> controller = Robolectric.buildActivity(@MAIN_NAME@Stub.class).setup().visible();
        pumpSchedulers();
        try {
            log("Waiting for Codename One main form to be displayed");
            Form displayed = waitForDisplayedForm(10000L);
            assertNotNull("Codename One form should be displayed", displayed);

            @MAIN_NAME@Stub activity = controller.get();
            log("Captured Codename One form; capturing decor view screenshot");
            Bitmap screenshot = captureScreenshot(activity);
            assertNotNull("Screenshot capture should succeed", screenshot);
            assertTrue("Screenshot width should be positive", screenshot.getWidth() > 0);
            assertTrue("Screenshot height should be positive", screenshot.getHeight() > 0);
            assertTrue("Screenshot should contain rendered content beyond the background", hasRenderableContent(screenshot));

            File screenshotFile = saveScreenshot(screenshot);
            log("Screenshot stored at " + screenshotFile.getAbsolutePath());
            assertTrue("Screenshot file should exist", screenshotFile.isFile());
            assertTrue("Screenshot file should not be empty", screenshotFile.length() > 0L);
        } finally {
            controller.pause().stop().destroy();
        }
    }

    private static Form waitForDisplayedForm(long timeoutMillis) throws InterruptedException {
        long start = System.currentTimeMillis();
        long nextLog = start;
        while (System.currentTimeMillis() - start < timeoutMillis) {
            pumpSchedulers();
            if (Display.isInitialized()) {
                Form current = Display.getInstance().getCurrent();
                if (current != null) {
                    return current;
                }
            }
            Thread.sleep(50L);
            long now = System.currentTimeMillis();
            if (now >= nextLog) {
                log("Still waiting for Codename One form; displayInitialized=" + Display.isInitialized());
                nextLog = now + 1000L;
            }
        }
        log("Timed out waiting for Codename One form; Display.isInitialized=" + Display.isInitialized());
        throw new AssertionError("Timed out waiting for Codename One form to be displayed");
    }

    private static Bitmap captureScreenshot(@MAIN_NAME@Stub activity) throws InterruptedException {
        View decorView = waitForDecorViewWithDimensions(activity, 10000L);
        Bitmap bitmap = Bitmap.createBitmap(decorView.getWidth(), decorView.getHeight(), Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(bitmap);
        decorView.draw(canvas);
        return bitmap;
    }

    private static boolean hasRenderableContent(Bitmap screenshot) {
        int width = screenshot.getWidth();
        int height = screenshot.getHeight();
        if (width <= 0 || height <= 0) {
            return false;
        }
        int[] pixels = new int[width * height];
        screenshot.getPixels(pixels, 0, width, 0, 0, width, height);
        if (pixels.length == 0) {
            return false;
        }
        int background = pixels[0];
        int contentPixels = 0;
        for (int argb : pixels) {
            int alpha = (argb >>> 24) & 0xFF;
            if (alpha == 0) {
                continue;
            }
            if (argb != background) {
                contentPixels++;
                if (contentPixels > width) {
                    return true;
                }
            }
        }
        return false;
    }

    private static File saveScreenshot(Bitmap screenshot) throws IOException {
        File outputDir = resolveArtifactDirectory();
        File screenshotFile = new File(outputDir, "@MAIN_NAME@-ui-test.png");
        try (FileOutputStream out = new FileOutputStream(screenshotFile)) {
            if (!screenshot.compress(Bitmap.CompressFormat.PNG, 100, out)) {
                throw new IOException("Failed to encode screenshot as PNG");
            }
        }
        return screenshotFile;
    }

    private static File resolveArtifactDirectory() throws IOException {
        String directory = System.getenv("CN1_TEST_SCREENSHOT_DIR");
        File outputDir = (directory != null && !directory.isEmpty()) ? new File(directory)
                : new File("build/ui-test-screenshots");
        if (!outputDir.exists() && !outputDir.mkdirs()) {
            throw new IOException("Failed to create screenshot directory " + outputDir.getAbsolutePath());
        }
        return outputDir;
    }

    private static File resolveArtifactDirectoryForLogging() {
        try {
            return resolveArtifactDirectory();
        } catch (IOException ex) {
            System.out.println("[@MAIN_NAME@UiTest] Unable to prepare artifact directory for logging: " + ex.getMessage());
            return null;
        }
    }

    private static View waitForDecorViewWithDimensions(@MAIN_NAME@Stub activity, long timeoutMillis) throws InterruptedException {
        long start = System.currentTimeMillis();
        long nextLog = start;
        while (System.currentTimeMillis() - start < timeoutMillis) {
            View decorView = activity.getWindow().getDecorView();
            if (decorView != null) {
                ensureViewHasLayout(decorView);
                if (decorView.getWidth() > 0 && decorView.getHeight() > 0) {
                    return decorView;
                }
            }
            pumpSchedulers();
            Thread.sleep(50L);
            long now = System.currentTimeMillis();
            if (now >= nextLog) {
                log("Waiting for decor view layout; decorPresent=" + (decorView != null)
                        + " width=" + (decorView != null ? decorView.getWidth() : 0)
                        + " height=" + (decorView != null ? decorView.getHeight() : 0));
                nextLog = now + 1000L;
            }
        }
        log("Timed out waiting for decor view layout");
        throw new AssertionError("Timed out waiting for decor view layout");
    }

    private static void ensureViewHasLayout(View view) {
        if (view.getWidth() > 0 && view.getHeight() > 0) {
            return;
        }
        DisplayMetrics metrics = view.getResources().getDisplayMetrics();
        int widthSpec = View.MeasureSpec.makeMeasureSpec(metrics.widthPixels, View.MeasureSpec.EXACTLY);
        int heightSpec = View.MeasureSpec.makeMeasureSpec(metrics.heightPixels, View.MeasureSpec.EXACTLY);
        view.measure(widthSpec, heightSpec);
        view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight());
    }

    private static void log(String message) {
        String formatted = "[@MAIN_NAME@UiTest] " + message;
        System.out.println(formatted);
        appendLogLine(formatted);
    }

    private static final AtomicInteger PUMP_INVOCATION_COUNTER = new AtomicInteger();

    private static void pumpSchedulers() {
        int invocation = PUMP_INVOCATION_COUNTER.incrementAndGet();
        long start = System.currentTimeMillis();
        boolean verbose = invocation <= 5 || invocation % 10 == 0;
        if (verbose) {
            log("pumpSchedulers[" + invocation + "] begin");
        }
        try {
            ShadowLooper.idleMainLooper();
            if (verbose) {
                log("pumpSchedulers[" + invocation + "] after idleMainLooper");
            }
            ShadowLooper.runUiThreadTasksIncludingDelayedTasks();
            if (verbose) {
                log("pumpSchedulers[" + invocation + "] after runUiThreadTasksIncludingDelayedTasks");
            }
            flushScheduler(Robolectric.getForegroundThreadScheduler(), "foreground", invocation, verbose);
            flushScheduler(Robolectric.getBackgroundThreadScheduler(), "background", invocation, verbose);
        } catch (Throwable t) {
            log("pumpSchedulers[" + invocation + "] threw " + t);
            throw t;
        } finally {
            if (verbose) {
                long elapsed = System.currentTimeMillis() - start;
                log("pumpSchedulers[" + invocation + "] finished after " + elapsed + "ms");
            }
        }
    }

    private static void flushScheduler(Scheduler scheduler, String label, int invocation, boolean verbose) {
        if (scheduler == null) {
            if (verbose) {
                log("pumpSchedulers[" + invocation + "] no " + label + " scheduler available");
            }
            return;
        }
        int iterations = 0;
        while (scheduler.advanceToLastPostedRunnable()) {
            iterations++;
            if (iterations <= 5 || iterations % 50 == 0) {
                log("pumpSchedulers[" + invocation + "] ran " + label + " runnable #" + iterations);
            }
            if (iterations >= 5000) {
                log("pumpSchedulers[" + invocation + "] aborting " + label + " flush after " + iterations + " iterations");
                break;
            }
        }
        if (verbose) {
            log("pumpSchedulers[" + invocation + "] flushed " + label + " scheduler in " + iterations + " iterations");
        }
    }

    private static synchronized void appendLogLine(String message) {
        File directory = resolveArtifactDirectoryForLogging();
        if (directory == null) {
            return;
        }
        File logFile = new File(directory, "@MAIN_NAME@UiTest.log");
        try (FileWriter writer = new FileWriter(logFile, true); PrintWriter out = new PrintWriter(writer)) {
            out.println(message);
        } catch (IOException ex) {
            System.out.println("[@MAIN_NAME@UiTest] Failed to persist log entry: " + ex.getMessage());
        }
    }
}
