package @PACKAGE@;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import android.app.Activity;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.os.Build;
import android.os.Handler;
import android.os.Looper;
import android.os.SystemClock;
import android.util.Log;
import android.view.PixelCopy;
import android.view.TextureView;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;

import androidx.annotation.Nullable;
import androidx.test.ext.junit.rules.ActivityScenarioRule;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import com.codename1.ui.Display;
import com.codename1.ui.Form;
import com.codename1.ui.Image;
import com.codename1.ui.util.ImageIO;

import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

@RunWith(AndroidJUnit4.class)
public class @MAIN_NAME@UiTest {

    private static final String TAG = "@MAIN_NAME@UiTest";
    private static final long STARTUP_TIMEOUT_MS = 30_000L;
    private static final long RENDER_TIMEOUT_MS = 20_000L;
    private static final long EDT_TIMEOUT_MS = 10_000L;

    @Rule
    public final ActivityScenarioRule<@MAIN_NAME@Stub> scenarioRule =
            new ActivityScenarioRule<>(@MAIN_NAME@Stub.class);

    @Test
    public void mainFormScreenshotContainsRenderedContent() throws Exception {
        waitForCodenameOneForm();

        Bitmap androidScreenshot = waitForAndroidScreenshot();
        assertTrue("Android screenshot should contain rendered content", hasRenderableContent(androidScreenshot));
        File androidScreenshotFile = saveBitmap(androidScreenshot, "@MAIN_NAME@-android-ui.png");
        assertTrue("Android screenshot file should exist", androidScreenshotFile.isFile());

        Image codenameOneScreenshot = waitForCodenameOneScreenshot();
        assertNotNull("Codename One screenshot should not be null", codenameOneScreenshot);
        assertTrue("Codename One screenshot should contain rendered content", hasRenderableContent(codenameOneScreenshot));
        File codenameOneScreenshotFile = saveCodenameOneScreenshot(codenameOneScreenshot, "@MAIN_NAME@-codenameone-ui.png");
        assertTrue("Codename One screenshot file should exist", codenameOneScreenshotFile.isFile());
    }

    private void waitForCodenameOneForm() throws Exception {
        long deadline = SystemClock.uptimeMillis() + STARTUP_TIMEOUT_MS;
        while (SystemClock.uptimeMillis() < deadline) {
            if (Display.isInitialized()) {
                Form current = callSeriallyAndWait(() -> Display.getInstance().getCurrent());
                if (current != null) {
                    Log.i(TAG, "Codename One current form available: " + current.getName());
                    return;
                }
            }
            SystemClock.sleep(50L);
        }
        throw new AssertionError("Timed out waiting for Codename One main form");
    }

    private Bitmap waitForAndroidScreenshot() throws Exception {
        long deadline = SystemClock.uptimeMillis() + RENDER_TIMEOUT_MS;
        Bitmap lastCapture = null;
        Exception lastError = null;
        while (SystemClock.uptimeMillis() < deadline) {
            AtomicReference<Bitmap> bitmapRef = new AtomicReference<>();
            AtomicReference<Exception> errorRef = new AtomicReference<>();
            scenarioRule.getScenario().onActivity(activity -> {
                try {
                    bitmapRef.set(captureFromActivity(activity));
                } catch (Exception e) {
                    errorRef.set(e);
                }
            });
            if (errorRef.get() != null) {
                lastError = errorRef.get();
            }
            Bitmap candidate = bitmapRef.get();
            if (candidate != null) {
                lastCapture = candidate;
                if (hasRenderableContent(candidate)) {
                    return candidate;
                }
            }
            if (lastError != null) {
                throw lastError;
            }
            SystemClock.sleep(64L);
        }
        if (lastCapture != null) {
            return lastCapture;
        }
        if (lastError != null) {
            throw lastError;
        }
        throw new AssertionError("Timed out waiting for Android screenshot to contain rendered content");
    }

    private Bitmap captureFromActivity(Activity activity) throws Exception {
        Window window = activity.getWindow();
        View decorView = window.getDecorView();
        ensureLaidOut(decorView);
        flushCodenameOneGraphics();

        Bitmap pixelCopy = attemptPixelCopy(window);
        if (pixelCopy != null && hasRenderableContent(pixelCopy)) {
            Log.i(TAG, "Captured screenshot via PixelCopy");
            return pixelCopy;
        }

        Bitmap surfaceBitmap = captureCodenameOneSurface(decorView);
        if (surfaceBitmap != null && hasRenderableContent(surfaceBitmap)) {
            Log.i(TAG, "Captured screenshot via TextureView bitmap");
            return surfaceBitmap;
        }

        Bitmap fallback = captureByDrawing(decorView);
        Log.i(TAG, "Captured screenshot via decorView.draw()");
        return fallback;
    }

    private static void ensureLaidOut(View view) {
        if (view.getWidth() > 0 && view.getHeight() > 0) {
            return;
        }
        int widthSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
        int heightSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
        view.measure(widthSpec, heightSpec);
        view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight());
    }

    @Nullable
    private Bitmap attemptPixelCopy(Window window) throws InterruptedException {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
            return null;
        }
        View decorView = window.getDecorView();
        if (decorView.getWidth() <= 0 || decorView.getHeight() <= 0) {
            return null;
        }
        Bitmap bitmap = Bitmap.createBitmap(decorView.getWidth(), decorView.getHeight(), Bitmap.Config.ARGB_8888);
        CountDownLatch latch = new CountDownLatch(1);
        AtomicInteger resultCode = new AtomicInteger(PixelCopy.ERROR_UNKNOWN);
        PixelCopy.request(window, bitmap, copyResult -> {
            resultCode.set(copyResult);
            latch.countDown();
        }, new Handler(Looper.getMainLooper()));
        if (!latch.await(EDT_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
            Log.w(TAG, "PixelCopy timed out");
            return null;
        }
        if (resultCode.get() == PixelCopy.SUCCESS) {
            return bitmap;
        }
        Log.w(TAG, "PixelCopy failed with code " + resultCode.get());
        return null;
    }

    @Nullable
    private Bitmap captureCodenameOneSurface(View root) {
        if (root instanceof TextureView) {
            Bitmap bitmap = ((TextureView) root).getBitmap();
            if (bitmap != null) {
                return bitmap;
            }
        }
        if (root instanceof ViewGroup) {
            ViewGroup group = (ViewGroup) root;
            for (int i = 0; i < group.getChildCount(); i++) {
                Bitmap child = captureCodenameOneSurface(group.getChildAt(i));
                if (child != null) {
                    return child;
                }
            }
        }
        return null;
    }

    private static Bitmap captureByDrawing(View view) {
        int width = Math.max(view.getWidth(), 1);
        int height = Math.max(view.getHeight(), 1);
        Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(bitmap);
        view.draw(canvas);
        return bitmap;
    }

    private Image waitForCodenameOneScreenshot() throws Exception {
        long deadline = SystemClock.uptimeMillis() + RENDER_TIMEOUT_MS;
        Image lastCapture = null;
        while (SystemClock.uptimeMillis() < deadline) {
            Image screenshot = captureCodenameOneScreenshot();
            if (screenshot != null) {
                lastCapture = screenshot;
                if (hasRenderableContent(screenshot)) {
                    return screenshot;
                }
            }
            SystemClock.sleep(64L);
        }
        if (lastCapture != null) {
            return lastCapture;
        }
        throw new AssertionError("Timed out waiting for Codename One screenshot to contain rendered content");
    }

    @Nullable
    private Image captureCodenameOneScreenshot() throws Exception {
        if (!Display.isInitialized()) {
            return null;
        }
        return callSeriallyAndWait(() -> Display.getInstance().captureScreen());
    }

    private void flushCodenameOneGraphics() throws Exception {
        if (!Display.isInitialized()) {
            return;
        }
        callSeriallyAndWait(() -> {
            Display display = Display.getInstance();
            Form current = display.getCurrent();
            if (current != null) {
                current.revalidate();
                current.repaint();
            }
            display.repaint(null);
            return null;
        });
    }

    private static boolean hasRenderableContent(Bitmap bitmap) {
        int width = bitmap.getWidth();
        int height = bitmap.getHeight();
        if (width <= 1 || height <= 1) {
            return false;
        }
        int[] pixels = new int[width * height];
        bitmap.getPixels(pixels, 0, width, 0, 0, width, height);
        return hasRenderableContent(pixels, width, height);
    }

    private static boolean hasRenderableContent(Image screenshot) throws Exception {
        if (screenshot == null || screenshot.getWidth() <= 1 || screenshot.getHeight() <= 1) {
            return false;
        }
        int[] pixels = callSeriallyAndWait(screenshot::getRGB);
        return hasRenderableContent(pixels, screenshot.getWidth(), screenshot.getHeight());
    }

    private static boolean hasRenderableContent(int[] pixels, int width, int height) {
        if (pixels == null || pixels.length == 0) {
            return false;
        }
        int background = pixels[0];
        int contentPixels = 0;
        for (int argb : pixels) {
            int alpha = (argb >>> 24) & 0xFF;
            if (alpha == 0) {
                continue;
            }
            if (argb != background) {
                contentPixels++;
                if (contentPixels > width) {
                    return true;
                }
            }
        }
        return false;
    }

    private static File saveBitmap(Bitmap bitmap, String fileName) throws IOException {
        File outputDir = resolveArtifactDirectory();
        File destination = new File(outputDir, fileName);
        try (FileOutputStream out = new FileOutputStream(destination)) {
            if (!bitmap.compress(Bitmap.CompressFormat.PNG, 100, out)) {
                throw new IOException("Failed to encode bitmap as PNG");
            }
        }
        Log.i(TAG, "Saved Android screenshot to " + destination.getAbsolutePath());
        return destination;
    }

    private static File saveCodenameOneScreenshot(Image screenshot, String fileName) throws Exception {
        File outputDir = resolveArtifactDirectory();
        File destination = new File(outputDir, fileName);
        ImageIO io = callSeriallyAndWait(() -> Display.getInstance().getImageIO());
        assertNotNull("Codename One ImageIO should be available", io);
        try (FileOutputStream out = new FileOutputStream(destination)) {
            callSeriallyAndWait(() -> {
                io.save(screenshot, out, ImageIO.FORMAT_PNG, 1.0f);
                return null;
            });
        }
        Log.i(TAG, "Saved Codename One screenshot to " + destination.getAbsolutePath());
        return destination;
    }

    private static File resolveArtifactDirectory() throws IOException {
        File filesDir = InstrumentationRegistry.getInstrumentation().getTargetContext().getFilesDir();
        File outputDir = new File(filesDir, "ui-test-screenshots");
        if (!outputDir.exists() && !outputDir.mkdirs()) {
            throw new IOException("Failed to create screenshot directory " + outputDir.getAbsolutePath());
        }
        return outputDir;
    }

    private static <T> T callSeriallyAndWait(Callable<T> callable) throws Exception {
        if (!Display.isInitialized()) {
            throw new IllegalStateException("Codename One Display must be initialized");
        }
        CountDownLatch latch = new CountDownLatch(1);
        AtomicReference<T> result = new AtomicReference<>();
        AtomicReference<Throwable> error = new AtomicReference<>();
        Display.getInstance().callSerially(() -> {
            try {
                result.set(callable.call());
            } catch (Throwable t) {
                error.set(t);
            } finally {
                latch.countDown();
            }
        });
        if (!awaitLatch(latch, EDT_TIMEOUT_MS)) {
            throw new AssertionError("Timed out waiting for Codename One EDT work");
        }
        if (error.get() != null) {
            Throwable throwable = error.get();
            if (throwable instanceof Exception) {
                throw (Exception) throwable;
            }
            throw new RuntimeException(throwable);
        }
        return result.get();
    }

    private static boolean awaitLatch(CountDownLatch latch, long timeoutMs) throws InterruptedException {
        long deadline = SystemClock.uptimeMillis() + timeoutMs;
        while (SystemClock.uptimeMillis() < deadline) {
            if (latch.await(16L, TimeUnit.MILLISECONDS)) {
                return true;
            }
        }
        return latch.await(0L, TimeUnit.MILLISECONDS);
    }
}
