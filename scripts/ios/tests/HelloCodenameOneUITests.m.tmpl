#import <XCTest/XCTest.h>
#import <UIKit/UIKit.h>
#import <CoreGraphics/CoreGraphics.h>
#import <objc/message.h>
#import <math.h>
#import <float.h>

@interface HelloCodenameOneUITests : XCTestCase
@property(nonatomic, strong) XCUIApplication *app;
@property(nonatomic, strong) NSURL *outputDirectory;
@end

@implementation HelloCodenameOneUITests {
    NSUInteger _chunkSize;
    NSArray<NSNumber *> *_previewQualities;
    NSUInteger _maxPreviewBytes;
}

- (void)setUpWithError:(NSError *__autoreleasing  _Nullable *)error {
    [super setUpWithError:error];
    self.continueAfterFailure = NO;

    _chunkSize = 2000;
    _previewQualities = @[@60, @50, @40, @35, @30, @25, @20, @18, @16, @14, @12, @10, @8, @6, @5, @4, @3, @2, @1];
    _maxPreviewBytes = 20 * 1024;

    NSDictionary<NSString *, NSString *> *env = [[NSProcessInfo processInfo] environment];
    NSString *bundleID = env[@"CN1_AUT_BUNDLE_ID"];
    if (bundleID.length == 0) {
        bundleID = @"com.codenameone.examples.hellocodenameone";
        printf("CN1SS:INFO:ui_test_target_bundle_id=fallback(%s)\n", bundleID.UTF8String);
    } else {
        printf("CN1SS:INFO:ui_test_target_bundle_id=%s\n", bundleID.UTF8String);
    }

    XCUIApplication *app = [[XCUIApplication alloc] initWithBundleIdentifier:bundleID];

    NSMutableDictionary<NSString *, NSString *> *launchEnv = [NSMutableDictionary dictionary];
    for (NSString *key in env) {
        if ([key hasPrefix:@"CN1_"]) {
            launchEnv[key] = env[key];
        }
    }
    if (launchEnv.count > 0) {
        app.launchEnvironment = launchEnv;
    }

    self.app = app;
    self.app.launchArguments = @[@"-AppleLocale", @"en_US", @"-AppleLanguages", @"(en)"];

    NSString *tmpPath = NSTemporaryDirectory();
    NSURL *tmpURL = [NSURL fileURLWithPath:tmpPath isDirectory:YES];
    NSString *tag = env[@"CN1SS_OUTPUT_DIR"];
    NSString *dirName = (tag.length > 0) ? tag : @"cn1screens";
    self.outputDirectory = [tmpURL URLByAppendingPathComponent:dirName isDirectory:YES];
    [[NSFileManager defaultManager] createDirectoryAtURL:self.outputDirectory withIntermediateDirectories:YES attributes:nil error:nil];

    [self.app launch];
    [self.app activate];

    NSString *resolvedBundleIdentifier = [self resolvedBundleIdentifier];
    if (resolvedBundleIdentifier.length > 0) {
        printf("CN1SS:INFO:ui_test_resolved_bundle_id=%s\n", resolvedBundleIdentifier.UTF8String);
    }
    NSURL *resolvedBundleURL = [self resolvedBundleURL];
    if (resolvedBundleURL != nil) {
        printf("CN1SS:INFO:ui_test_resolved_bundle_url=%s\n", resolvedBundleURL.path.UTF8String);
    }

    [self waitForAppToEnterForegroundWithTimeout:40.0];
    [self waitForRenderedContentInContext:@"launch" timeout:45.0 settle:1.2];
}

- (void)tearDownWithError:(NSError *__autoreleasing  _Nullable *)error {
    [self.app terminate];
    self.app = nil;
    [super tearDownWithError:error];
}

- (void)testMainScreenScreenshot {
    BOOL rendered = [self waitForRenderedContentInContext:@"MainActivity" timeout:45.0 settle:1.0];
    if (!rendered) {
        XCTFail(@"Codename One UI did not render before capturing MainActivity");
    }
    [self captureScreenshotNamed:@"MainActivity"];
}

- (void)testBrowserComponentScreenshot {
    BOOL renderedBeforeTap = [self waitForRenderedContentInContext:@"BrowserComponent_pre_tap" timeout:30.0 settle:0.5];
    if (!renderedBeforeTap) {
        XCTFail(@"Codename One UI did not render before BrowserComponent tap");
    }
    [self tapNormalizedX:0.5 y:0.70];
    [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:2.0]];
    BOOL renderedAfterTap = [self waitForRenderedContentInContext:@"BrowserComponent" timeout:40.0 settle:0.8];
    if (!renderedAfterTap) {
        XCTFail(@"BrowserComponent UI did not render after navigation");
    }
    [self captureScreenshotNamed:@"BrowserComponent"];
}

#pragma mark - Helpers

- (void)waitForAppToEnterForegroundWithTimeout:(NSTimeInterval)timeout {
    NSDate *deadline = [NSDate dateWithTimeIntervalSinceNow:timeout];
    NSUInteger attempt = 0;
    while ([[NSDate date] compare:deadline] == NSOrderedAscending) {
        XCUIApplicationState state = self.app.state;
        if (state == XCUIApplicationStateRunningForeground) {
            printf("CN1SS:INFO:launch_state attempt=%lu state=running_foreground\n", (unsigned long)(attempt + 1));
            return;
        }
        [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.5]];
        attempt += 1;
    }
    printf("CN1SS:WARN:launch_state_timeout=true attempts=%lu timeout=%.1f\n", (unsigned long)attempt, timeout);
}

- (BOOL)waitForRenderedContentInContext:(NSString *)context timeout:(NSTimeInterval)timeout settle:(NSTimeInterval)settle {
    NSDate *deadline = [NSDate dateWithTimeIntervalSinceNow:timeout];
    NSUInteger attempt = 0;
    BOOL detected = NO;
    while ([[NSDate date] compare:deadline] == NSOrderedAscending) {
        attempt += 1;
        XCUIScreenshot *shot = self.app.screenshot;
        if (shot == nil) {
            shot = [XCUIScreen mainScreen].screenshot;
        }
        UIImage *image = shot.image;
        if (image == nil) {
            printf("CN1SS:WARN:context=%s missing_image_for_variance attempt=%lu\n",
                   context.UTF8String,
                   (unsigned long)attempt);
            [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.75]];
            continue;
        }
        double variance = 0.0;
        double mean = 0.0;
        double range = 0.0;
        [self luminanceStatsForImage:image sampleStride:8 variance:&variance mean:&mean range:&range];
        printf("CN1SS:INFO:context=%s attempt=%lu luma_variance=%.3f luma_mean=%.2f luma_range=%.2f size=%.0fx%.0f\n",
               context.UTF8String,
               (unsigned long)attempt,
               variance,
               mean,
               range,
               image.size.width,
               image.size.height);
        if (variance > 8.0 && range > 12.0 && mean < 240.0) {
            detected = YES;
            break;
        }
        [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.75]];
    }
    if (!detected) {
        printf("CN1SS:WARN:context=%s rendered_content_timeout=true attempts=%lu\n",
               context.UTF8String,
               (unsigned long)attempt);
    }
    if (settle > 0) {
        [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:settle]];
    }
    return detected;
}

- (void)tapNormalizedX:(CGFloat)dx y:(CGFloat)dy {
    XCUICoordinate *origin = [self.app coordinateWithNormalizedOffset:CGVectorMake(0, 0)];
    CGSize size = self.app.frame.size;
    XCUICoordinate *target = [origin coordinateWithOffset:CGVectorMake(size.width * dx, size.height * dy)];
    [target tap];
}

- (void)captureScreenshotNamed:(NSString *)name {
    XCUIScreenshot *shot = self.app.screenshot;
    if (shot == nil) {
        shot = [XCUIScreen mainScreen].screenshot;
    }
    NSData *pngData = shot.PNGRepresentation;

    UIImage *image = shot.image;
    double captureVariance = 0.0;
    double captureMean = 0.0;
    double captureRange = 0.0;
    [self luminanceStatsForImage:image sampleStride:6 variance:&captureVariance mean:&captureMean range:&captureRange];
    printf("CN1SS:INFO:test=%s capture_luma_variance=%.3f capture_luma_mean=%.2f capture_luma_range=%.2f\n",
           name.UTF8String,
           captureVariance,
           captureMean,
           captureRange);

    NSURL *pngURL = [self.outputDirectory URLByAppendingPathComponent:[name stringByAppendingString:@".png"]];
    [pngData writeToURL:pngURL atomically:NO];

    XCTAttachment *attachment = [XCTAttachment attachmentWithScreenshot:shot];
    attachment.name = name;
    attachment.lifetime = XCTAttachmentLifetimeKeepAlways;
    [self addAttachment:attachment];

    [self emitScreenshotPayloadsForShot:shot name:name pngData:pngData];
}

- (NSString *)resolvedBundleIdentifier {
    if (self.app == nil) {
        return @"";
    }
    SEL selectors[] = { NSSelectorFromString(@"bundleIdentifier"), NSSelectorFromString(@"bundleID") };
    for (NSUInteger i = 0; i < sizeof(selectors) / sizeof(selectors[0]); i++) {
        SEL selector = selectors[i];
        if ([self.app respondsToSelector:selector]) {
            id result = ((id (*)(id, SEL))objc_msgSend)(self.app, selector);
            if ([result isKindOfClass:[NSString class]]) {
                return (NSString *)result;
            }
        }
    }
    return @"";
}

- (NSURL *)resolvedBundleURL {
    if (self.app == nil) {
        return nil;
    }
    SEL selector = NSSelectorFromString(@"bundleURL");
    if ([self.app respondsToSelector:selector]) {
        id result = ((id (*)(id, SEL))objc_msgSend)(self.app, selector);
        if ([result isKindOfClass:[NSURL class]]) {
            return (NSURL *)result;
        }
    }
    return nil;
}

- (NSString *)sanitizeTestName:(NSString *)name {
    NSMutableString *result = [NSMutableString stringWithCapacity:name.length];
    NSCharacterSet *allowed = [NSCharacterSet characterSetWithCharactersInString:@"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-"];
    for (NSUInteger i = 0; i < name.length; i++) {
        unichar ch = [name characterAtIndex:i];
        if ([allowed characterIsMember:ch]) {
            [result appendFormat:@"%C", ch];
        } else {
            [result appendString:@"_"];
        }
    }
    return result;
}

- (void)emitScreenshotPayloadsForShot:(XCUIScreenshot *)shot name:(NSString *)name pngData:(NSData *)pngData {
    NSString *safeName = [self sanitizeTestName:name];
    printf("CN1SS:INFO:test=%s png_bytes=%lu\n", safeName.UTF8String, (unsigned long)pngData.length);
    [self emitScreenshotChannelWithData:pngData name:safeName channel:@""];

    NSData *previewData = nil;
    NSInteger previewQuality = 0;
    UIImage *image = [UIImage imageWithData:pngData];
    if (image) {
        NSUInteger smallest = NSUIntegerMax;
        for (NSNumber *qualityNumber in _previewQualities) {
            CGFloat quality = qualityNumber.doubleValue / 100.0;
            NSData *jpeg = UIImageJPEGRepresentation(image, quality);
            if (!jpeg) {
                continue;
            }
            NSUInteger length = jpeg.length;
            if (length < smallest) {
                smallest = length;
                previewData = jpeg;
                previewQuality = (NSInteger)lrint(quality * 100.0);
            }
            if (length <= _maxPreviewBytes) {
                break;
            }
        }
    }

    if (previewData.length > 0) {
        printf("CN1SS:INFO:test=%s preview_jpeg_bytes=%lu preview_quality=%ld\n", safeName.UTF8String, (unsigned long)previewData.length, (long)previewQuality);
        if (previewData.length > _maxPreviewBytes) {
            printf("CN1SS:WARN:test=%s preview_exceeds_limit_bytes=%lu max_preview_bytes=%lu\n", safeName.UTF8String, (unsigned long)previewData.length, (unsigned long)_maxPreviewBytes);
        }
        [self emitScreenshotChannelWithData:previewData name:safeName channel:@"PREVIEW"];
    } else {
        printf("CN1SS:INFO:test=%s preview_jpeg_bytes=0 preview_quality=0\n", safeName.UTF8String);
    }
}

- (void)emitScreenshotChannelWithData:(NSData *)data name:(NSString *)name channel:(NSString *)channel {
    NSMutableString *prefix = [NSMutableString stringWithString:@"CN1SS"];
    if (channel.length > 0) {
        [prefix appendString:channel];
    }
    if (data.length == 0) {
        printf("%s:END:%s\n", prefix.UTF8String, name.UTF8String);
        return;
    }

    NSString *base64 = [data base64EncodedStringWithOptions:0];
    NSUInteger position = 0;
    NSUInteger chunkCount = 0;
    while (position < base64.length) {
        NSUInteger length = MIN(_chunkSize, base64.length - position);
        NSRange range = NSMakeRange(position, length);
        NSString *chunk = [base64 substringWithRange:range];
        printf("%s:%s:%06lu:%s\n", prefix.UTF8String, name.UTF8String, (unsigned long)position, chunk.UTF8String);
        position += length;
        chunkCount += 1;
    }
    printf("CN1SS:INFO:test=%s chunks=%lu total_b64_len=%lu\n", name.UTF8String, (unsigned long)chunkCount, (unsigned long)base64.length);
    printf("%s:END:%s\n", prefix.UTF8String, name.UTF8String);
}

- (void)luminanceStatsForImage:(UIImage *)image
                   sampleStride:(NSUInteger)stride
                       variance:(double *)varianceOut
                           mean:(double *)meanOut
                          range:(double *)rangeOut {
    if (varianceOut) { *varianceOut = 0.0; }
    if (meanOut) { *meanOut = 0.0; }
    if (rangeOut) { *rangeOut = 0.0; }
    if (image == nil) {
        return;
    }
    CGImageRef cgImage = image.CGImage;
    if (cgImage == nil) {
        return;
    }
    CGDataProviderRef provider = CGImageGetDataProvider(cgImage);
    if (provider == nil) {
        return;
    }
    CFDataRef dataRef = CGDataProviderCopyData(provider);
    if (dataRef == nil) {
        return;
    }

    const UInt8 *bytes = CFDataGetBytePtr(dataRef);
    size_t length = CFDataGetLength(dataRef);
    size_t bytesPerRow = CGImageGetBytesPerRow(cgImage);
    size_t bitsPerPixel = CGImageGetBitsPerPixel(cgImage);
    size_t components = bitsPerPixel / 8;
    if (length == 0 || components < 3) {
        CFRelease(dataRef);
        return;
    }

    if (stride == 0) {
        stride = 1;
    }

    size_t width = CGImageGetWidth(cgImage);
    size_t height = CGImageGetHeight(cgImage);

    size_t marginX = width / 8;
    size_t marginY = height / 8;
    size_t xStart = marginX;
    size_t xEnd = width > marginX ? width - marginX : width;
    size_t yStart = marginY;
    size_t yEnd = height > marginY ? height - marginY : height;
    if (xStart >= xEnd) { xStart = 0; xEnd = width; }
    if (yStart >= yEnd) { yStart = 0; yEnd = height; }

    NSUInteger effectiveStride = stride;
    NSUInteger regionWidth = (NSUInteger)(xEnd > xStart ? (xEnd - xStart) : width);
    NSUInteger regionHeight = (NSUInteger)(yEnd > yStart ? (yEnd - yStart) : height);
    if (effectiveStride > regionWidth && regionWidth > 0) {
        effectiveStride = regionWidth;
    }
    if (effectiveStride > regionHeight && regionHeight > 0) {
        effectiveStride = regionHeight;
    }

    CGBitmapInfo info = CGImageGetBitmapInfo(cgImage);
    BOOL littleEndian = (info & kCGBitmapByteOrderMask) == kCGBitmapByteOrder32Little;

    double sum = 0.0;
    double sumSq = 0.0;
    double minLuma = DBL_MAX;
    double maxLuma = 0.0;
    NSUInteger count = 0;

    for (size_t y = yStart; y < yEnd; y += effectiveStride) {
        const UInt8 *row = bytes + y * bytesPerRow;
        for (size_t x = xStart; x < xEnd; x += effectiveStride) {
            const UInt8 *pixel = row + x * components;
            double r = littleEndian ? pixel[2] : pixel[0];
            double g = pixel[1];
            double b = littleEndian ? pixel[0] : pixel[2];
            double luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            sum += luma;
            sumSq += luma * luma;
            if (luma < minLuma) { minLuma = luma; }
            if (luma > maxLuma) { maxLuma = luma; }
            count += 1;
        }
    }

    CFRelease(dataRef);

    if (count == 0) {
        return;
    }

    double mean = sum / (double)count;
    double variance = (sumSq / (double)count) - (mean * mean);
    double range = maxLuma - minLuma;

    if (varianceOut) { *varianceOut = variance; }
    if (meanOut) { *meanOut = mean; }
    if (rangeOut) { *rangeOut = range; }
}

@end
