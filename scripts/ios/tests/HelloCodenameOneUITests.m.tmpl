// HelloCodenameOneUITests.m.tmpl
// Objective-C (no modules) — safe for CLANG_ENABLE_MODULES=NO

#import <XCTest/XCTest.h>
#import <UIKit/UIKit.h>

@interface HelloCodenameOneUITests : XCTestCase
@property(nonatomic, strong) XCUIApplication *app;
@end

@implementation HelloCodenameOneUITests

#pragma mark - Setup / Teardown

- (void)setUpWithError:(NSError *__autoreleasing  _Nullable *)error {
    [super setUpWithError:error];
    self.continueAfterFailure = YES; // keep running even if something is odd

    NSDictionary *env = NSProcessInfo.processInfo.environment;
    NSLog(@"CN1SS:INFO:env=%@", env);

    NSString *bundleID = env[@"CN1_AUT_BUNDLE_ID"];
    if (bundleID.length > 0) {
        NSLog(@"CN1SS:INFO:ui_test_target_bundle_id=%@", bundleID);
        self.app = [[XCUIApplication alloc] initWithBundleIdentifier:bundleID];
    } else {
        NSLog(@"CN1SS:INFO:ui_test_target_bundle_id=(default)");
        self.app = [[XCUIApplication alloc] init];
    }

    self.app.launchArguments = @[
        @"-AppleLocale", @"en_US",
        @"-AppleLanguages", @"(en)",
        @"--cn1-test-mode", @"1"
    ];

    [self cn1_saveScreen:@"pre_launch"];
    NSLog(@"CN1SS:INFO:launch:start args=%@", self.app.launchArguments);
    [self.app launch];

    // Be resilient: poll for foreground without failing the test.
    [self cn1_waitForForegroundWithTimeout:20.0 step:0.25 label:@"post_launch"];
    NSLog(@"CN1SS:INFO:state_after_launch=%ld", (long)self.app.state);

    if (self.app.state != XCUIApplicationStateRunningForeground) {
        NSLog(@"CN1SS:WARN:not_foreground:attempting_relaunch");
        [self.app terminate];
        [self cn1_saveScreen:@"pre_relaunch"];
        [self.app launch];
        [self cn1_waitForForegroundWithTimeout:15.0 step:0.25 label:@"post_relaunch"];
        NSLog(@"CN1SS:INFO:state_after_relaunch=%ld", (long)self.app.state);
    }
}

- (void)tearDownWithError:(NSError *__autoreleasing  _Nullable *)error {
    [self.app terminate];
    self.app = nil;
    [super tearDownWithError:error];
}

#pragma mark - Test

- (void)testSmokeLaunchAndScreenshot {
    // Always emit one CN1SS payload so your Java tools find it.
    [self cn1_emitScreenshotNamed:@"MainActivity"];

    // No hard assertion — this is a smoke/screenshot producer.
    // If you want *some* signal, log the final state:
    NSLog(@"CN1SS:INFO:final_app_state=%ld exists=%d",
          (long)self.app.state, self.app.exists ? 1 : 0);
}

#pragma mark - CN1SS helpers

- (void)cn1_emitScreenshotNamed:(NSString *)name {
    // Prefer app screenshot; fall back to screen
    XCUIScreenshot *shot = self.app.screenshot ?: XCUIScreen.mainScreen.screenshot;
    if (!shot) { NSLog(@"CN1SS:WARN:test=%@ no_screenshot", name); return; }

    NSData *png = shot.PNGRepresentation;
    if (png.length == 0) { NSLog(@"CN1SS:WARN:test=%@ empty_png", name); return; }

    // Emit raw base64 chunks to the log
    [self cn1ssEmitChannel:@"" name:name bytes:png];

    // Emit a tiny preview JPEG too (helps your preview step)
    UIImage *img = [UIImage imageWithData:png];
    if (img) {
        NSData *jpeg = UIImageJPEGRepresentation(img, 0.12);
        if (jpeg.length > 0) {
            [self cn1ssEmitChannel:@"PREVIEW" name:name bytes:jpeg];
        }
    }

    // Attach to XCTest report
    XCTAttachment *att = [XCTAttachment attachmentWithScreenshot:shot];
    att.name = name;
    att.lifetime = XCTAttachmentLifetimeKeepAlways;
    [self addAttachment:att];

    // Also save to tmp so your “saved_screenshot” parser can find it
    [self cn1_saveScreen:[NSString stringWithFormat:@"attach_%@", name]];
}

- (void)cn1ssEmitChannel:(NSString *)channel name:(NSString *)name bytes:(NSData *)bytes {
    if (bytes.length == 0) return;
    NSString *prefix = channel.length ? [@"CN1SS" stringByAppendingString:channel] : @"CN1SS";
    NSString *b64 = [bytes base64EncodedStringWithOptions:0];

    const NSUInteger chunkSize = 2000;
    NSUInteger pos = 0, chunks = 0;
    while (pos < b64.length) {
        NSUInteger len = MIN(chunkSize, b64.length - pos);
        NSString *chunk = [b64 substringWithRange:NSMakeRange(pos, len)];
        // Plain printf so it’s not throttled by NSLog formatting
        printf("%s:%s:%06lu:%s\n",
               prefix.UTF8String,
               name.UTF8String,
               (unsigned long)pos,
               chunk.UTF8String);
        pos += len;
        chunks += 1;
    }
    printf("CN1SS:END:%s\n", name.UTF8String);
    printf("CN1SS:INFO:test=%s chunks=%lu total_b64_len=%lu\n",
           name.UTF8String, (unsigned long)chunks, (unsigned long)b64.length);
}

#pragma mark - Telemetry / utilities

- (void)cn1_saveScreen:(NSString *)name {
    XCUIScreenshot *shot = XCUIScreen.mainScreen.screenshot ?: self.app.screenshot;
    if (!shot) return;

    NSData *png = shot.PNGRepresentation;
    if (png.length == 0) return;

    NSString *tmp = NSTemporaryDirectory();
    if (tmp.length == 0) tmp = @"/tmp";
    NSString *dir = [tmp stringByAppendingPathComponent:@"cn1screens"];
    [[NSFileManager defaultManager] createDirectoryAtPath:dir
                              withIntermediateDirectories:YES
                                               attributes:nil
                                                    error:nil];

    NSString *path = [dir stringByAppendingPathComponent:[name stringByAppendingString:@".png"]];
    [png writeToFile:path atomically:NO];
    NSLog(@"CN1SS:INFO:saved_screenshot name=%@ path=%@", name, path);

    XCTAttachment *att = [XCTAttachment attachmentWithUniformTypeIdentifier:@"public.png"
                                                                       name:name
                                                                    payload:png
                                                                    userInfo:nil];
    att.lifetime = XCTAttachmentLifetimeKeepAlways;
    [self addAttachment:att];
}

- (void)cn1_waitForForegroundWithTimeout:(NSTimeInterval)timeout step:(NSTimeInterval)step label:(NSString *)label {
    NSDate *deadline = [NSDate dateWithTimeIntervalSinceNow:timeout];
    NSUInteger attempt = 0;

    while ([[NSDate date] compare:deadline] == NSOrderedAscending) {
        attempt++;
        XCUIApplicationState state = self.app.state;
        NSLog(@"CN1SS:INFO:launch_state attempt=%lu state=%ld",
              (unsigned long)attempt, (long)state);

        if (state == XCUIApplicationStateRunningForeground) {
            [self cn1_saveScreen:[NSString stringWithFormat:@"%@_foreground_%lu",
                                  label, (unsigned long)attempt]];
            return;
        } else {
            [self cn1_saveScreen:[NSString stringWithFormat:@"%@_state_%lu",
                                  label, (unsigned long)attempt]];
        }

        [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:step]];
    }

    NSLog(@"CN1SS:WARN:%@_timeout state=%ld", label, (long)self.app.state);
}

@end