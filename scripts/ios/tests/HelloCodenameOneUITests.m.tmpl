#import <XCTest/XCTest.h>
#import <UIKit/UIKit.h>

@interface HelloCodenameOneUITests : XCTestCase
@property(nonatomic, strong) XCUIApplication *app;
@end

@implementation HelloCodenameOneUITests

- (void)setUpWithError:(NSError *__autoreleasing  _Nullable *)error {
    [super setUpWithError:error];
    self.continueAfterFailure = NO;

    NSDictionary *env = NSProcessInfo.processInfo.environment;
    NSLog(@"CN1SS:INFO:env=%@", env);

    NSString *bundleID = env[@"CN1_AUT_BUNDLE_ID"];
    if (bundleID.length > 0) {
        NSLog(@"CN1SS:INFO:ui_test_target_bundle_id=%@", bundleID);
        self.app = [[XCUIApplication alloc] initWithBundleIdentifier:bundleID];
    } else {
        NSLog(@"CN1SS:INFO:ui_test_target_bundle_id=(default)");
        self.app = [[XCUIApplication alloc] init];
    }

    // Make args visible in logs and to the app
    NSMutableArray *args = [@[
        @"-AppleLocale", @"en_US",
        @"-AppleLanguages", @"(en)",
        @"--cn1-test-mode", @"1"
    ] mutableCopy];
    self.app.launchArguments = args;

    // Pre-attach screenshot for proof of simulator state
    [self saveScreen:@"pre_launch"];

    NSLog(@"CN1SS:INFO:launch:start args=%@", self.app.launchArguments);
    [self.app launch];

    // Try hard to reach foreground, with periodic screenshots
    [self waitForAppToEnterForegroundWithTimeout:60.0 step:1.5 label:@"post_launch"];
    NSLog(@"CN1SS:INFO:state_after_launch=%ld", (long)self.app.state);

    if (self.app.state != XCUIApplicationStateRunningForeground) {
        NSLog(@"CN1SS:WARN:not_foreground:attempting_relaunch");
        [self.app terminate];
        [self saveScreen:@"pre_relaunch"];
        [self.app launch];
        [self waitForAppToEnterForegroundWithTimeout:40.0 step:1.5 label:@"post_relaunch"];
        NSLog(@"CN1SS:INFO:state_after_relaunch=%ld", (long)self.app.state);
    }

    // First-frame settle
    [self waitForRenderedContentInContext:@"launch" timeout:45.0 settle:1.2];
}

- (void)tearDownWithError:(NSError *__autoreleasing  _Nullable *)error {
    [self.app terminate];
    self.app = nil;
    [super tearDownWithError:error];
}

#pragma mark - Telemetry helpers

- (void)saveScreen:(NSString *)name {
    XCUIScreenshot *shot = XCUIScreen.mainScreen.screenshot ?: self.app.screenshot;
    if (!shot) return;
    NSData *png = shot.PNGRepresentation;
    NSString *tmp = NSTemporaryDirectory();
    NSString *dir = [tmp stringByAppendingPathComponent:@"cn1screens"];
    [[NSFileManager defaultManager] createDirectoryAtPath:dir withIntermediateDirectories:YES attributes:nil error:nil];
    NSString *path = [dir stringByAppendingPathComponent:[name stringByAppendingString:@".png"]];
    [png writeToFile:path atomically:NO];
    NSLog(@"CN1SS:INFO:saved_screenshot name=%@ path=%@", name, path);
    XCTAttachment *att = [XCTAttachment attachmentWithScreenshot:shot];
    att.name = name;
    att.lifetime = XCTAttachmentLifetimeKeepAlways;
    [self addAttachment:att];
}

- (void)waitForAppToEnterForegroundWithTimeout:(NSTimeInterval)timeout step:(NSTimeInterval)step label:(NSString *)label {
    NSDate *deadline = [NSDate dateWithTimeIntervalSinceNow:timeout];
    NSUInteger attempt = 0;
    while ([[NSDate date] compare:deadline] == NSOrderedAscending) {
        attempt++;
        XCUIApplicationState state = self.app.state;
        NSLog(@"CN1SS:INFO:launch_state attempt=%lu state=%ld", (unsigned long)attempt, (long)state);
        if (state == XCUIApplicationStateRunningForeground) {
            [self saveScreen:[NSString stringWithFormat:@"%@_foreground_%lu", label, (unsigned long)attempt]];
            return;
        }
        [self saveScreen:[NSString stringWithFormat:@"%@_state_%lu", label, (unsigned long)attempt]];
        [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:step]];
    }
    NSLog(@"CN1SS:WARN:%@_timeout", label);
}

- (BOOL)waitForRenderedContentInContext:(NSString *)context timeout:(NSTimeInterval)timeout settle:(NSTimeInterval)settle {
    // keep your variance logic as-is; also call [self saveScreen:...] inside the loop every few attempts
    // ...
    return YES;
}

@end