import XCTest
import UIKit
import CoreGraphics

final class HelloCodenameOneUITests: XCTestCase {
    private var app: XCUIApplication!
    private var outputDirectory: URL!
    private var targetBundleIdentifier: String?
    private var candidateDisplayNames: [String] = []
    private let chunkSize = 2000
    private let previewChannel = "PREVIEW"
    private let previewQualities: [CGFloat] = [0.60, 0.50, 0.40, 0.35, 0.30, 0.25, 0.20, 0.18, 0.16, 0.14, 0.12, 0.10, 0.08, 0.06, 0.05, 0.04, 0.03, 0.02, 0.01]
    private let maxPreviewBytes = 20 * 1024

    override func setUpWithError() throws {
        continueAfterFailure = false
        let env = ProcessInfo.processInfo.environment

        if let bundleID = env["CN1_AUT_BUNDLE_ID"], !bundleID.isEmpty {
            targetBundleIdentifier = bundleID
            app = XCUIApplication(bundleIdentifier: bundleID)
        } else {
            app = XCUIApplication()
        }

        candidateDisplayNames = buildCandidateDisplayNames(from: env)

        // Locale for determinism
        app.launchArguments += ["-AppleLocale", "en_US", "-AppleLanguages", "(en)"]

        // IMPORTANT: write to the app's sandbox, not a host path
        let tmp = URL(fileURLWithPath: NSTemporaryDirectory(), isDirectory: true)
        if let tag = env["CN1SS_OUTPUT_DIR"], !tag.isEmpty {
            outputDirectory = tmp.appendingPathComponent(tag, isDirectory: true)
        } else {
            outputDirectory = tmp.appendingPathComponent("cn1screens", isDirectory: true)
        }
        try FileManager.default.createDirectory(at: outputDirectory, withIntermediateDirectories: true)

        print("CN1SS:INFO:ui_test_target_bundle_id=\(targetBundleIdentifier ?? "(scheme-default)")")
        print("CN1SS:INFO:ui_test_launch_arguments=\(app.launchArguments.joined(separator: " "))")

        ensureAppLaunched()
        waitForStableFrame()
    }

    override func tearDownWithError() throws {
        app?.terminate()
        app = nil
    }

    private func ensureAppLaunched(timeout: TimeInterval = 45) {
        if app.state == .runningForeground {
            logLaunchState(label: "already_running")
            return
        }

        app.launch()
        if app.state == .runningForeground {
            logLaunchState(label: "launch")
            return
        }

        if activateViaSpringboard(deadline: Date().addingTimeInterval(timeout)) {
            logLaunchState(label: "springboard")
            return
        }

        app.activate()
        logLaunchState(label: "activate")
    }

    private func activateViaSpringboard(deadline: Date) -> Bool {
        let springboard = XCUIApplication(bundleIdentifier: "com.apple.springboard")
        springboard.activate()

        for name in candidateDisplayNames where Date() < deadline {
            let icon = springboard.icons[name]
            if icon.waitForExistence(timeout: 3) {
                print("CN1SS:INFO:springboard_icon_tap name=\(name)")
                icon.tap()
                if app.wait(for: .runningForeground, timeout: 5) {
                    return true
                }
            }
        }

        if Date() < deadline {
            let predicate = NSPredicate(format: "label CONTAINS[c] %@", "Codename")
            let fallbackIcon = springboard.icons.matching(predicate).firstMatch
            if fallbackIcon.waitForExistence(timeout: 3) {
                print("CN1SS:INFO:springboard_icon_fallback label=\(fallbackIcon.label)")
                fallbackIcon.tap()
                if app.wait(for: .runningForeground, timeout: 5) {
                    return true
                }
            }
        }
        return app.state == .runningForeground
    }

    private func buildCandidateDisplayNames(from env: [String: String]) -> [String] {
        var names: [String] = []
        if let explicit = env["CN1_AUT_APP_NAME"], !explicit.isEmpty {
            names.append(explicit)
        }
        names.append("HelloCodenameOne")
        names.append("Hello Codename One")
        if let bundle = env["CN1_AUT_BUNDLE_ID"], !bundle.isEmpty {
            if let suffix = bundle.split(separator: ".").last, !suffix.isEmpty {
                names.append(String(suffix))
            }
        }
        return Array(Set(names)).sorted()
    }

    private func logLaunchState(label: String) {
        let state: String
        switch app.state {
        case .runningForeground: state = "running_foreground"
        case .runningBackground: state = "running_background"
        case .runningBackgroundSuspended: state = "running_background_suspended"
        case .notRunning: state = "not_running"
        @unknown default: state = "unknown"
        }
        print("CN1SS:INFO:launch_state label=\(label) state=\(state)")
        if let resolved = resolveBundleIdentifier() {
            print("CN1SS:INFO:ui_test_resolved_bundle_id=\(resolved)")
        } else {
            print("CN1SS:WARN:ui_test_resolved_bundle_id_unavailable=true")
        }
    }

    private func captureScreenshot(named name: String) throws {
        ensureAppLaunched()
        waitForStableFrame()
        let result = pollForRenderableContent(label: name, timeout: 30, poll: 0.6)
        let shot = result.screenshot
        if !result.hasRenderableContent {
            print("CN1SS:WARN:test=\(name) rendered_content_not_detected attempts=\(result.attempts) luma_variance=\(result.lumaVariance)")
        }

        let pngURL = outputDirectory.appendingPathComponent("\(name).png")
        do { try shot.pngRepresentation.write(to: pngURL) } catch { /* ignore */ }

        let attachment = XCTAttachment(screenshot: shot)
        attachment.name = name
        attachment.lifetime = .keepAlways
        add(attachment)

        emitScreenshotPayloads(for: shot, name: name)
    }

    /// Wait for foreground + a short settle time
    private func waitForStableFrame(timeout: TimeInterval = 30, settle: TimeInterval = 1.2) {
        _ = app.wait(for: .runningForeground, timeout: timeout)
        RunLoop.current.run(until: Date(timeIntervalSinceNow: settle))
    }

    /// Tap using normalized coordinates (0...1)
    private func tapNormalized(_ dx: CGFloat, _ dy: CGFloat) {
        let frame = app.frame
        guard frame.width > 0, frame.height > 0 else {
            return
        }
        let origin = app.coordinate(withNormalizedOffset: .zero)
        let target = origin.withOffset(.init(dx: frame.width * dx, dy: frame.height * dy))
        target.tap()
    }

    func testMainScreenScreenshot() throws {
        try captureScreenshot(named: "MainActivity")
    }

    func testBrowserComponentScreenshot() throws {
        tapNormalized(0.5, 0.70)
        print("CN1SS:INFO:navigation_tap=browser_screen normalized_x=0.50 normalized_y=0.70")
        RunLoop.current.run(until: Date(timeIntervalSinceNow: 2.0))
        try captureScreenshot(named: "BrowserComponent")
    }

    private func pollForRenderableContent(label: String, timeout: TimeInterval, poll: TimeInterval) -> (screenshot: XCUIScreenshot, hasRenderableContent: Bool, attempts: Int, lumaVariance: Int) {
        let deadline = Date(timeIntervalSinceNow: timeout)
        var attempts = 0
        var latestVariance = 0
        while true {
            attempts += 1
            let screenshot = app.screenshot()
            let analysis = analyzeScreenshot(screenshot)
            latestVariance = analysis.lumaVariance
            if analysis.hasRenderableContent {
                print("CN1SS:INFO:test=\(label) rendered_frame_detected attempt=\(attempts) luma_variance=\(analysis.lumaVariance)")
                return (screenshot, true, attempts, analysis.lumaVariance)
            }

            print("CN1SS:INFO:test=\(label) waiting_for_rendered_frame attempt=\(attempts) luma_variance=\(analysis.lumaVariance)")
            let now = Date()
            if now >= deadline {
                print("CN1SS:WARN:test=\(label) rendered_content_timeout attempts=\(attempts) final_luma_variance=\(analysis.lumaVariance)")
                return (screenshot, false, attempts, analysis.lumaVariance)
            }

            let nextInterval = min(poll, deadline.timeIntervalSince(now))
            RunLoop.current.run(until: Date(timeIntervalSinceNow: nextInterval))
        }
    }

    private func analyzeScreenshot(_ screenshot: XCUIScreenshot) -> (hasRenderableContent: Bool, lumaVariance: Int) {
        guard let cgImage = screenshot.image.cgImage else {
            return (true, 255)
        }
        let width = cgImage.width
        let height = cgImage.height
        guard width > 0, height > 0 else {
            return (false, 0)
        }

        let insetX = max(0, width / 8)
        let insetY = max(0, height / 8)
        let cropRect = CGRect(
            x: insetX,
            y: insetY,
            width: max(1, width - insetX * 2),
            height: max(1, height - insetY * 2)
        ).integral
        guard let cropped = cgImage.cropping(to: cropRect) else {
            return (true, 255)
        }

        let sampleWidth = 80
        let sampleHeight = 80
        let bytesPerPixel = 4
        let bytesPerRow = sampleWidth * bytesPerPixel
        guard let context = CGContext(
            data: nil,
            width: sampleWidth,
            height: sampleHeight,
            bitsPerComponent: 8,
            bytesPerRow: bytesPerRow,
            space: CGColorSpaceCreateDeviceRGB(),
            bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue
        ) else {
            return (true, 255)
        }
        context.interpolationQuality = .high
        context.draw(cropped, in: CGRect(x: 0, y: 0, width: sampleWidth, height: sampleHeight))
        guard let data = context.data else {
            return (true, 255)
        }

        let buffer = data.bindMemory(to: UInt8.self, capacity: sampleHeight * bytesPerRow)
        var minLuma = 255
        var maxLuma = 0
        for y in 0..<sampleHeight {
            let row = y * bytesPerRow
            for x in 0..<sampleWidth {
                let idx = row + x * bytesPerPixel
                let r = Int(buffer[idx])
                let g = Int(buffer[idx + 1])
                let b = Int(buffer[idx + 2])
                let luma = (r * 299 + g * 587 + b * 114) / 1000
                if luma < minLuma { minLuma = luma }
                if luma > maxLuma { maxLuma = luma }
            }
        }

        let variance = maxLuma - minLuma
        return (variance > 12, variance)
    }

    private func resolveBundleIdentifier() -> String? {
        if let explicit = targetBundleIdentifier, !explicit.isEmpty {
            return explicit
        }
        do {
            let value = try app.value(forKey: "bundleID")
            if let actual = value as? String, !actual.isEmpty {
                return actual
            }
        } catch {
            print("CN1SS:WARN:ui_test_bundle_resolution_failed error=\(error)")
        }
        return nil
    }

    private func sanitizeTestName(_ name: String) -> String {
        let allowed = CharacterSet(charactersIn: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-")
        let underscore: UnicodeScalar = "_"
        var scalars: [UnicodeScalar] = []
        scalars.reserveCapacity(name.unicodeScalars.count)
        for scalar in name.unicodeScalars {
            scalars.append(allowed.contains(scalar) ? scalar : underscore)
        }
        return String(String.UnicodeScalarView(scalars))
    }

    private func emitScreenshotPayloads(for shot: XCUIScreenshot, name: String) {
        let safeName = sanitizeTestName(name)
        let pngData = shot.pngRepresentation
        print("CN1SS:INFO:test=\(safeName) png_bytes=\(pngData.count)")
        emitScreenshotChannel(data: pngData, name: safeName, channel: "")

        if let preview = makePreviewJPEG(from: shot, pngData: pngData) {
            print("CN1SS:INFO:test=\(safeName) preview_jpeg_bytes=\(preview.data.count) preview_quality=\(preview.quality)")
            if preview.data.count > maxPreviewBytes {
                print("CN1SS:WARN:test=\(safeName) preview_exceeds_limit_bytes=\(preview.data.count) max_preview_bytes=\(maxPreviewBytes)")
            }
            emitScreenshotChannel(data: preview.data, name: safeName, channel: previewChannel)
        } else {
            print("CN1SS:INFO:test=\(safeName) preview_jpeg_bytes=0 preview_quality=0")
        }
    }

    private func makePreviewJPEG(from shot: XCUIScreenshot, pngData: Data) -> (data: Data, quality: Int)? {
        guard let image = UIImage(data: pngData) else {
            return nil
        }
        var chosenData: Data?
        var chosenQuality = 0
        var smallest = Int.max
        for quality in previewQualities {
            guard let jpeg = image.jpegData(compressionQuality: quality) else { continue }
            let length = jpeg.count
            if length < smallest {
                smallest = length
                chosenData = jpeg
                chosenQuality = Int((quality * 100).rounded())
            }
            if length <= maxPreviewBytes {
                break
            }
        }
        guard let finalData = chosenData, !finalData.isEmpty else {
            return nil
        }
        return (finalData, chosenQuality)
    }

    private func emitScreenshotChannel(data: Data, name: String, channel: String) {
        var prefix = "CN1SS"
        if !channel.isEmpty {
            prefix += channel
        }
        guard !data.isEmpty else {
            print("\(prefix):END:\(name)")
            return
        }
        let base64 = data.base64EncodedString()
        var current = base64.startIndex
        var position = 0
        var chunkCount = 0
        while current < base64.endIndex {
            let next = base64.index(current, offsetBy: chunkSize, limitedBy: base64.endIndex) ?? base64.endIndex
            let chunk = base64[current..<next]
            print("\(prefix):\(name):\(String(format: "%06d", position)):\(chunk)")
            chunkCount += 1
            position += chunk.count
            current = next
        }
        print("CN1SS:INFO:test=\(name) chunks=\(chunkCount) total_b64_len=\(base64.count)")
        print("\(prefix):END:\(name)")
    }
}
