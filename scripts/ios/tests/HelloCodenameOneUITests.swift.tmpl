import XCTest
import UIKit
import CoreGraphics
import Foundation

final class HelloCodenameOneUITests: XCTestCase {
    private var app: XCUIApplication!
    private var outputDirectory: URL!
    private let chunkSize = 2000
    private let previewChannel = "PREVIEW"
    private let previewQualities: [CGFloat] = [0.60, 0.50, 0.40, 0.35, 0.30, 0.25, 0.20, 0.18, 0.16, 0.14, 0.12, 0.10, 0.08, 0.06, 0.05, 0.04, 0.03, 0.02, 0.01]
    private let maxPreviewBytes = 20 * 1024

    override func setUpWithError() throws {
        continueAfterFailure = false
        app = XCUIApplication()

        // Locale for determinism
        app.launchArguments += ["-AppleLocale", "en_US", "-AppleLanguages", "(en)"]
        // Tip: force light mode or content size if you need pixel-stable shots
        // app.launchArguments += ["-uiuserInterfaceStyle", "Light"]

        // IMPORTANT: write to the app's sandbox, not a host path
        let tmp = URL(fileURLWithPath: NSTemporaryDirectory(), isDirectory: true)
        if let tag = ProcessInfo.processInfo.environment["CN1SS_OUTPUT_DIR"], !tag.isEmpty {
            outputDirectory = tmp.appendingPathComponent(tag, isDirectory: true)
        } else {
            outputDirectory = tmp.appendingPathComponent("cn1screens", isDirectory: true)
        }
        try FileManager.default.createDirectory(at: outputDirectory, withIntermediateDirectories: true)

        app.launch()
        waitForStableFrame()
    }

    override func tearDownWithError() throws {
        app?.terminate()
        app = nil
    }

    private enum ScreenshotSource {
        case xcui(shot: XCUIScreenshot)
        case raw(data: Data, image: UIImage)

        var pngData: Data {
            switch self {
            case .xcui(let shot):
                return shot.pngRepresentation
            case .raw(let data, _):
                return data
            }
        }

        var previewImage: UIImage? {
            switch self {
            case .xcui(let shot):
                return shot.image
            case .raw(_, let image):
                return image
            }
        }
    }

    private func captureScreenshot(named name: String) throws {
        let source = try produceScreenshot(named: name)
        let pngData = source.pngData

        // Save into sandbox tmp (optional â€“ mainly for local debugging)
        let pngURL = outputDirectory.appendingPathComponent("\(name).png")
        do { try pngData.write(to: pngURL) } catch { /* ignore */ }

        switch source {
        case .xcui(let shot):
            let att = XCTAttachment(screenshot: shot)
            att.name = name
            att.lifetime = .keepAlways
            add(att)
            emitScreenshotPayloads(for: shot, fallbackPNG: pngData, fallbackImage: shot.image, name: name)
        case .raw(let data, let image):
            let att = XCTAttachment(data: data, uniformTypeIdentifier: "public.png")
            att.name = name
            att.lifetime = .keepAlways
            add(att)
            emitScreenshotPayloads(for: nil, fallbackPNG: data, fallbackImage: image, name: name)
        }
    }

    /// Wait for foreground + a short settle time
    private func waitForStableFrame(timeout: TimeInterval = 30, settle: TimeInterval = 1.2) {
        _ = app.wait(for: .runningForeground, timeout: timeout)
        RunLoop.current.run(until: Date(timeIntervalSinceNow: settle))
    }

    /// Tap using normalized coordinates (0...1)
    private func tapNormalized(_ dx: CGFloat, _ dy: CGFloat) {
        let origin = app.coordinate(withNormalizedOffset: .zero)
        let target = origin.withOffset(.init(dx: app.frame.size.width * dx,
                                             dy: app.frame.size.height * dy))
        target.tap()
    }

    func testMainScreenScreenshot() throws {
        waitForStableFrame()
        try captureScreenshot(named: "MainActivity")
    }

    func testBrowserComponentScreenshot() throws {
        waitForStableFrame()
        tapNormalized(0.5, 0.70)
        // tiny retry to allow BrowserComponent to render
        RunLoop.current.run(until: Date(timeIntervalSinceNow: 2.0))
        try captureScreenshot(named: "BrowserComponent")
    }

    private func sanitizeTestName(_ name: String) -> String {
        let allowed = CharacterSet(charactersIn: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-")
        let underscore: UnicodeScalar = "_"
        var scalars: [UnicodeScalar] = []
        scalars.reserveCapacity(name.unicodeScalars.count)
        for scalar in name.unicodeScalars {
            scalars.append(allowed.contains(scalar) ? scalar : underscore)
        }
        return String(String.UnicodeScalarView(scalars))
    }

    private func emitScreenshotPayloads(for shot: XCUIScreenshot?, fallbackPNG: Data, fallbackImage: UIImage?, name: String) {
        let safeName = sanitizeTestName(name)
        let pngData = shot?.pngRepresentation ?? fallbackPNG
        print("CN1SS:INFO:test=\(safeName) png_bytes=\(pngData.count)")
        emitScreenshotChannel(data: pngData, name: safeName, channel: "")

        if let preview = makePreviewJPEG(from: shot, fallbackImage: fallbackImage, pngData: pngData) {
            print("CN1SS:INFO:test=\(safeName) preview_jpeg_bytes=\(preview.data.count) preview_quality=\(preview.quality)")
            if preview.data.count > maxPreviewBytes {
                print("CN1SS:WARN:test=\(safeName) preview_exceeds_limit_bytes=\(preview.data.count) max_preview_bytes=\(maxPreviewBytes)")
            }
            emitScreenshotChannel(data: preview.data, name: safeName, channel: previewChannel)
        } else {
            print("CN1SS:INFO:test=\(safeName) preview_jpeg_bytes=0 preview_quality=0")
        }
    }

    private func makePreviewJPEG(from shot: XCUIScreenshot?, fallbackImage: UIImage?, pngData: Data) -> (data: Data, quality: Int)? {
        let baseImage: UIImage?
        if let s = shot {
            baseImage = s.image
        } else {
            baseImage = fallbackImage ?? UIImage(data: pngData)
        }

        guard let image = baseImage else {
            return nil
        }
        var chosenData: Data?
        var chosenQuality = 0
        var smallest = Int.max
        for quality in previewQualities {
            guard let jpeg = image.jpegData(compressionQuality: quality) else { continue }
            let length = jpeg.count
            if length < smallest {
                smallest = length
                chosenData = jpeg
                chosenQuality = Int((quality * 100).rounded())
            }
            if length <= maxPreviewBytes {
                break
            }
        }
        guard let finalData = chosenData, !finalData.isEmpty else {
            return nil
        }
        return (finalData, chosenQuality)
    }

    private func emitScreenshotChannel(data: Data, name: String, channel: String) {
        var prefix = "CN1SS"
        if !channel.isEmpty {
            prefix += channel
        }
        guard !data.isEmpty else {
            print("\(prefix):END:\(name)")
            return
        }
        let base64 = data.base64EncodedString()
        var current = base64.startIndex
        var position = 0
        var chunkCount = 0
        while current < base64.endIndex {
            let next = base64.index(current, offsetBy: chunkSize, limitedBy: base64.endIndex) ?? base64.endIndex
            let chunk = base64[current..<next]
            print("\(prefix):\(name):\(String(format: "%06d", position)):\(chunk)")
            chunkCount += 1
            position += chunk.count
            current = next
        }
        print("CN1SS:INFO:test=\(name) chunks=\(chunkCount) total_b64_len=\(base64.count)")
        print("\(prefix):END:\(name)")
    }

    private func produceScreenshot(named name: String) throws -> ScreenshotSource {
        let initialShot = XCUIScreen.main.screenshot()
        if let image = initialShot.image.cgImage, isMeaningful(image: image) {
            return .xcui(shot: initialShot)
        }

        if let fallbackData = try? simctlScreenshot(),
           let fallbackImage = UIImage(data: fallbackData),
           let cg = fallbackImage.cgImage,
           isMeaningful(image: cg) {
            print("CN1SS:INFO:test=\(name) used_simctl_fallback=true")
            return .raw(data: fallbackData, image: fallbackImage)
        }

        // If both captures look blank, return the initial shot so downstream logic
        // still emits artifacts, but flag the condition for debugging.
        print("CN1SS:WARN:test=\(name) screenshot_variance_low=true")
        return .xcui(shot: initialShot)
    }

    private func simctlScreenshot() throws -> Data {
        let tmpDir = URL(fileURLWithPath: NSTemporaryDirectory(), isDirectory: true)
        let dest = tmpDir.appendingPathComponent("cn1ss-simctl-\(UUID().uuidString).png")
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/xcrun")
        process.arguments = ["simctl", "io", "booted", "screenshot", dest.path]
        let stderrPipe = Pipe()
        process.standardError = stderrPipe
        try process.run()
        process.waitUntilExit()
        if process.terminationStatus != 0 {
            let data = stderrPipe.fileHandleForReading.readDataToEndOfFile()
            if let message = String(data: data, encoding: .utf8), !message.isEmpty {
                print("CN1SS:WARN:simctl_screenshot_failed status=\(process.terminationStatus) stderr=\(message.trimmingCharacters(in: .whitespacesAndNewlines))")
            } else {
                print("CN1SS:WARN:simctl_screenshot_failed status=\(process.terminationStatus)")
            }
            throw NSError(domain: "HelloCodenameOneUITests", code: Int(process.terminationStatus), userInfo: [NSLocalizedDescriptionKey: "simctl screenshot failed"])
        }
        let png = try Data(contentsOf: dest)
        try? FileManager.default.removeItem(at: dest)
        return png
    }

    private func isMeaningful(image cgImage: CGImage) -> Bool {
        guard let dataProvider = cgImage.dataProvider,
              let data = dataProvider.data,
              let bytes = CFDataGetBytePtr(data) else {
            return true
        }

        let width = cgImage.width
        let height = cgImage.height
        let bytesPerRow = cgImage.bytesPerRow
        let bitsPerPixel = cgImage.bitsPerPixel
        guard bitsPerPixel >= 24 else { return true }

        let components = bitsPerPixel / 8
        if components < 3 { return true }

        let stride = max(1, min(8, min(width, height) / 50))
        let marginX = width / 8
        let marginY = height / 8
        var sum: Double = 0
        var sumSquares: Double = 0
        var minLuma: Double = 255
        var maxLuma: Double = 0
        var samples = 0

        let startX = marginX
        let endX = max(startX, width - marginX)
        let startY = marginY
        let endY = max(startY, height - marginY)

        var y = startY
        while y < endY {
            var x = startX
            while x < endX {
                let offset = y * bytesPerRow + x * components
                let r = Double(bytes[offset])
                let g = Double(bytes[offset + 1])
                let b = Double(bytes[offset + 2])
                let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b
                sum += luma
                sumSquares += luma * luma
                if luma < minLuma { minLuma = luma }
                if luma > maxLuma { maxLuma = luma }
                samples += 1
                x += stride
            }
            y += stride
        }

        guard samples > 0 else { return true }
        let mean = sum / Double(samples)
        let variance = (sumSquares / Double(samples)) - (mean * mean)
        let range = maxLuma - minLuma
        return variance > 8.0 && range > 12.0 && mean < 240.0
    }
}
