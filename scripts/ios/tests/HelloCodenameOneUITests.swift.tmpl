import XCTest
import UIKit

final class HelloCodenameOneUITests: XCTestCase {
    private var app: XCUIApplication!
    private var outputDirectory: URL!
    private let chunkSize = 2000
    private let previewChannel = "PREVIEW"
    private let defaultAppBundleIdentifier = "com.codenameone.examples.HelloCodenameOne"
    private let previewQualities: [CGFloat] = [0.60, 0.50, 0.40, 0.35, 0.30, 0.25, 0.20, 0.18, 0.16, 0.14, 0.12, 0.10, 0.08, 0.06, 0.05, 0.04, 0.03, 0.02, 0.01]
    private let maxPreviewBytes = 20 * 1024

    override func setUpWithError() throws {
        continueAfterFailure = false
        app = makeApplication()

        // Locale for determinism
        app.launchArguments += ["-AppleLocale", "en_US", "-AppleLanguages", "(en)"]
        // Tip: force light mode or content size if you need pixel-stable shots
        // app.launchArguments += ["-uiuserInterfaceStyle", "Light"]

        // IMPORTANT: write to the app's sandbox, not a host path
        let tmp = URL(fileURLWithPath: NSTemporaryDirectory(), isDirectory: true)
        if let tag = ProcessInfo.processInfo.environment["CN1SS_OUTPUT_DIR"], !tag.isEmpty {
            outputDirectory = tmp.appendingPathComponent(tag, isDirectory: true)
        } else {
            outputDirectory = tmp.appendingPathComponent("cn1screens", isDirectory: true)
        }
        try FileManager.default.createDirectory(at: outputDirectory, withIntermediateDirectories: true)

        launchAppAndStabilize()
    }

    override func tearDownWithError() throws {
        app?.terminate()
        app = nil
    }

    private func captureScreenshot(named name: String) throws {
        let shot = bestScreenshot()

        // Save into sandbox tmp (optional â€“ mainly for local debugging)
        let pngURL = outputDirectory.appendingPathComponent("\(name).png")
        do { try shot.pngRepresentation.write(to: pngURL) } catch { /* ignore */ }

        // ALWAYS attach so we can export from the .xcresult
        let att = XCTAttachment(screenshot: shot)
        att.name = name
        att.lifetime = .keepAlways
        add(att)

        emitScreenshotPayloads(for: shot, name: name)
    }

    private func bestScreenshot() -> XCUIScreenshot {
        let screenShot = XCUIScreen.main.screenshot()
        let appShot = app.screenshot()
        let screenBytes = screenShot.pngRepresentation.count
        let appBytes = appShot.pngRepresentation.count

        if appBytes > screenBytes && appBytes > 0 {
            return appShot
        }
        if screenBytes == 0 && appBytes > 0 {
            return appShot
        }
        if appBytes == 0 && screenBytes > 0 {
            return screenShot
        }
        return screenBytes >= appBytes ? screenShot : appShot
    }

    /// Wait for foreground + a short settle time
    private func waitForStableFrame(timeout: TimeInterval = 30, settle: TimeInterval = 1.2) {
        _ = app.wait(for: .runningForeground, timeout: timeout)
        RunLoop.current.run(until: Date(timeIntervalSinceNow: settle))
    }

    private func launchAppAndStabilize() {
        let originalArguments = app.launchArguments
        let originalEnvironment = app.launchEnvironment
        app.launch()
        if app.state != .runningForeground {
            let fallback = XCUIApplication()
            fallback.launchArguments = originalArguments
            fallback.launchEnvironment = originalEnvironment
            fallback.launch()
            if fallback.state == .runningForeground {
                print("CN1SS:INFO:using_fallback_application state=\(fallback.state.rawValue)")
                app = fallback
            }
        }
        if let bundle = app.bundleIdentifier {
            print("CN1SS:INFO:active_bundle=\(bundle) state=\(app.state.rawValue)")
        } else {
            print("CN1SS:INFO:active_bundle=unknown state=\(app.state.rawValue)")
        }
        waitForStableFrame()
    }

    private func makeApplication() -> XCUIApplication {
        let env = ProcessInfo.processInfo.environment
        if let identifier = preferredBundleIdentifier(from: env) {
            return XCUIApplication(bundleIdentifier: identifier)
        }
        return XCUIApplication()
    }

    private func preferredBundleIdentifier(from environment: [String: String]) -> String? {
        if let explicit = environment["CN1_APP_BUNDLE_ID"]?.trimmingCharacters(in: .whitespacesAndNewlines), !explicit.isEmpty {
            return explicit
        }
        return defaultAppBundleIdentifier
    }

    /// Tap using normalized coordinates (0...1)
    private func tapNormalized(_ dx: CGFloat, _ dy: CGFloat) {
        let origin = app.coordinate(withNormalizedOffset: .zero)
        let target = origin.withOffset(.init(dx: app.frame.size.width * dx,
                                             dy: app.frame.size.height * dy))
        target.tap()
    }

    func testMainScreenScreenshot() throws {
        waitForStableFrame()
        try captureScreenshot(named: "MainActivity")
    }

    func testBrowserComponentScreenshot() throws {
        waitForStableFrame()
        tapNormalized(0.5, 0.70)
        // tiny retry to allow BrowserComponent to render
        RunLoop.current.run(until: Date(timeIntervalSinceNow: 2.0))
        try captureScreenshot(named: "BrowserComponent")
    }

    private func sanitizeTestName(_ name: String) -> String {
        let allowed = CharacterSet(charactersIn: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-")
        let underscore: UnicodeScalar = "_"
        var scalars: [UnicodeScalar] = []
        scalars.reserveCapacity(name.unicodeScalars.count)
        for scalar in name.unicodeScalars {
            scalars.append(allowed.contains(scalar) ? scalar : underscore)
        }
        return String(String.UnicodeScalarView(scalars))
    }

    private func emitScreenshotPayloads(for shot: XCUIScreenshot, name: String) {
        let safeName = sanitizeTestName(name)
        let pngData = shot.pngRepresentation
        print("CN1SS:INFO:test=\(safeName) png_bytes=\(pngData.count)")
        emitScreenshotChannel(data: pngData, name: safeName, channel: "")

        if let preview = makePreviewJPEG(from: shot, pngData: pngData) {
            print("CN1SS:INFO:test=\(safeName) preview_jpeg_bytes=\(preview.data.count) preview_quality=\(preview.quality)")
            if preview.data.count > maxPreviewBytes {
                print("CN1SS:WARN:test=\(safeName) preview_exceeds_limit_bytes=\(preview.data.count) max_preview_bytes=\(maxPreviewBytes)")
            }
            emitScreenshotChannel(data: preview.data, name: safeName, channel: previewChannel)
        } else {
            print("CN1SS:INFO:test=\(safeName) preview_jpeg_bytes=0 preview_quality=0")
        }
    }

    private func makePreviewJPEG(from shot: XCUIScreenshot, pngData: Data) -> (data: Data, quality: Int)? {
        guard let image = UIImage(data: pngData) else {
            return nil
        }
        var chosenData: Data?
        var chosenQuality = 0
        var smallest = Int.max
        for quality in previewQualities {
            guard let jpeg = image.jpegData(compressionQuality: quality) else { continue }
            let length = jpeg.count
            if length < smallest {
                smallest = length
                chosenData = jpeg
                chosenQuality = Int((quality * 100).rounded())
            }
            if length <= maxPreviewBytes {
                break
            }
        }
        guard let finalData = chosenData, !finalData.isEmpty else {
            return nil
        }
        return (finalData, chosenQuality)
    }

    private func emitScreenshotChannel(data: Data, name: String, channel: String) {
        var prefix = "CN1SS"
        if !channel.isEmpty {
            prefix += channel
        }
        guard !data.isEmpty else {
            print("\(prefix):END:\(name)")
            return
        }
        let base64 = data.base64EncodedString()
        var current = base64.startIndex
        var position = 0
        var chunkCount = 0
        while current < base64.endIndex {
            let next = base64.index(current, offsetBy: chunkSize, limitedBy: base64.endIndex) ?? base64.endIndex
            let chunk = base64[current..<next]
            print("\(prefix):\(name):\(String(format: "%06d", position)):\(chunk)")
            chunkCount += 1
            position += chunk.count
            current = next
        }
        print("CN1SS:INFO:test=\(name) chunks=\(chunkCount) total_b64_len=\(base64.count)")
        print("\(prefix):END:\(name)")
    }
}
