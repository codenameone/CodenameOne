import XCTest
import UIKit
import CoreGraphics
import Darwin
import Foundation

final class HelloCodenameOneUITests: XCTestCase {
    private var app: XCUIApplication!
    private var outputDirectory: URL!
    private var targetBundleIdentifier: String?
    private var candidateDisplayNames: [String] = []
    private let chunkSize = 2000
    private let previewChannel = "PREVIEW"
    private let previewQualities: [CGFloat] = [0.60, 0.50, 0.40, 0.35, 0.30, 0.25, 0.20, 0.18, 0.16, 0.14, 0.12, 0.10, 0.08, 0.06, 0.05, 0.04, 0.03, 0.02, 0.01]
    private let maxPreviewBytes = 20 * 1024

    override func setUpWithError() throws {
        continueAfterFailure = false
        let env = ProcessInfo.processInfo.environment

        if let bundleID = env["CN1_AUT_BUNDLE_ID"], !bundleID.isEmpty {
            targetBundleIdentifier = bundleID
            app = XCUIApplication(bundleIdentifier: bundleID)
        } else {
            app = XCUIApplication()
        }

        candidateDisplayNames = buildCandidateDisplayNames(from: env)

        // Locale for determinism
        app.launchArguments += ["-AppleLocale", "en_US", "-AppleLanguages", "(en)"]

        // IMPORTANT: write to the app's sandbox, not a host path
        let tmp = URL(fileURLWithPath: NSTemporaryDirectory(), isDirectory: true)
        if let tag = env["CN1SS_OUTPUT_DIR"], !tag.isEmpty {
            outputDirectory = tmp.appendingPathComponent(tag, isDirectory: true)
        } else {
            outputDirectory = tmp.appendingPathComponent("cn1screens", isDirectory: true)
        }
        try FileManager.default.createDirectory(at: outputDirectory, withIntermediateDirectories: true)

        print("CN1SS:INFO:ui_test_target_bundle_id=\(targetBundleIdentifier ?? "(scheme-default)")")
        print("CN1SS:INFO:ui_test_launch_arguments=\(app.launchArguments.joined(separator: " "))")

        ensureAppLaunched()
        triggerCodenameOneMainIfPossible()
        waitForStableFrame()
    }

    override func tearDownWithError() throws {
        app?.terminate()
        app = nil
    }

    private func ensureAppLaunched(timeout: TimeInterval = 45) {
        if app.state == .runningForeground {
            logLaunchState(label: "already_running")
            return
        }

        app.launch()
        if app.state == .runningForeground {
            logLaunchState(label: "launch")
            return
        }

        if activateViaSpringboard(deadline: Date().addingTimeInterval(timeout)) {
            logLaunchState(label: "springboard")
            return
        }

        app.activate()
        logLaunchState(label: "activate")
    }

    private func activateViaSpringboard(deadline: Date) -> Bool {
        let springboard = XCUIApplication(bundleIdentifier: "com.apple.springboard")
        springboard.activate()

        for name in candidateDisplayNames where Date() < deadline {
            let icon = springboard.icons[name]
            if icon.waitForExistence(timeout: 3) {
                print("CN1SS:INFO:springboard_icon_tap name=\(name)")
                icon.tap()
                if app.wait(for: .runningForeground, timeout: 5) {
                    return true
                }
            }
        }

        if Date() < deadline {
            let predicate = NSPredicate(format: "label CONTAINS[c] %@", "Codename")
            let fallbackIcon = springboard.icons.matching(predicate).firstMatch
            if fallbackIcon.waitForExistence(timeout: 3) {
                print("CN1SS:INFO:springboard_icon_fallback label=\(fallbackIcon.label)")
                fallbackIcon.tap()
                if app.wait(for: .runningForeground, timeout: 5) {
                    return true
                }
            }
        }
        return app.state == .runningForeground
    }

    private func buildCandidateDisplayNames(from env: [String: String]) -> [String] {
        var names: [String] = []
        if let explicit = env["CN1_AUT_APP_NAME"], !explicit.isEmpty {
            names.append(explicit)
        }
        names.append("HelloCodenameOne")
        names.append("Hello Codename One")
        if let bundle = env["CN1_AUT_BUNDLE_ID"], !bundle.isEmpty {
            if let suffix = bundle.split(separator: ".").last, !suffix.isEmpty {
                names.append(String(suffix))
            }
        }
        return Array(Set(names)).sorted()
    }

    private func logLaunchState(label: String) {
        let state: String
        switch app.state {
        case .runningForeground: state = "running_foreground"
        case .runningBackground: state = "running_background"
        case .runningBackgroundSuspended: state = "running_background_suspended"
        case .notRunning: state = "not_running"
        @unknown default: state = "unknown"
        }
        print("CN1SS:INFO:launch_state label=\(label) state=\(state)")
        if let resolved = resolveBundleIdentifier() {
            print("CN1SS:INFO:ui_test_resolved_bundle_id=\(resolved)")
        } else {
            print("CN1SS:WARN:ui_test_resolved_bundle_id_unavailable=true")
        }
    }

    private func captureScreenshot(named name: String) throws {
        ensureAppLaunched()
        triggerCodenameOneMainIfPossible()
        waitForStableFrame()
        let result = pollForRenderableContent(label: name, timeout: 30, poll: 0.6)
        let shot = result.screenshot
        if !result.hasRenderableContent {
            print("CN1SS:WARN:test=\(name) rendered_content_not_detected attempts=\(result.attempts) luma_variance=\(result.lumaVariance)")
        }

        let pngURL = outputDirectory.appendingPathComponent("\(name).png")
        do { try shot.pngRepresentation.write(to: pngURL) } catch { /* ignore */ }

        let attachment = XCTAttachment(screenshot: shot)
        attachment.name = name
        attachment.lifetime = .keepAlways
        add(attachment)

        emitScreenshotPayloads(for: shot, name: name)
    }

    /// Wait for foreground + a short settle time
    private func waitForStableFrame(timeout: TimeInterval = 30, settle: TimeInterval = 1.2) {
        _ = app.wait(for: .runningForeground, timeout: timeout)
        RunLoop.current.run(until: Date(timeIntervalSinceNow: settle))
    }

    /// Tap using normalized coordinates (0...1)
    private func tapNormalized(_ dx: CGFloat, _ dy: CGFloat) {
        let frame = app.frame
        guard frame.width > 0, frame.height > 0 else {
            return
        }
        let origin = app.coordinate(withNormalizedOffset: .zero)
        let target = origin.withOffset(.init(dx: frame.width * dx, dy: frame.height * dy))
        target.tap()
    }

    func testMainScreenScreenshot() throws {
        try captureScreenshot(named: "MainActivity")
    }

    func testBrowserComponentScreenshot() throws {
        tapNormalized(0.5, 0.70)
        print("CN1SS:INFO:navigation_tap=browser_screen normalized_x=0.50 normalized_y=0.70")
        RunLoop.current.run(until: Date(timeIntervalSinceNow: 2.0))
        try captureScreenshot(named: "BrowserComponent")
    }

    private func pollForRenderableContent(label: String, timeout: TimeInterval, poll: TimeInterval) -> (screenshot: XCUIScreenshot, hasRenderableContent: Bool, attempts: Int, lumaVariance: Int) {
        let deadline = Date(timeIntervalSinceNow: timeout)
        var attempts = 0
        var latestVariance = 0
        while true {
            attempts += 1
            let screenshot = app.screenshot()
            let analysis = analyzeScreenshot(screenshot)
            latestVariance = analysis.lumaVariance
            if analysis.hasRenderableContent {
                print("CN1SS:INFO:test=\(label) rendered_frame_detected attempt=\(attempts) luma_variance=\(analysis.lumaVariance)")
                return (screenshot, true, attempts, analysis.lumaVariance)
            }

            print("CN1SS:INFO:test=\(label) waiting_for_rendered_frame attempt=\(attempts) luma_variance=\(analysis.lumaVariance)")
            let now = Date()
            if now >= deadline {
                print("CN1SS:WARN:test=\(label) rendered_content_timeout attempts=\(attempts) final_luma_variance=\(analysis.lumaVariance)")
                return (screenshot, false, attempts, analysis.lumaVariance)
            }

            let nextInterval = min(poll, deadline.timeIntervalSince(now))
            RunLoop.current.run(until: Date(timeIntervalSinceNow: nextInterval))
        }
    }

    private func analyzeScreenshot(_ screenshot: XCUIScreenshot) -> (hasRenderableContent: Bool, lumaVariance: Int) {
        guard let cgImage = screenshot.image.cgImage else {
            return (true, 255)
        }
        let width = cgImage.width
        let height = cgImage.height
        guard width > 0, height > 0 else {
            return (false, 0)
        }

        let insetX = max(0, width / 8)
        let insetY = max(0, height / 8)
        let cropRect = CGRect(
            x: insetX,
            y: insetY,
            width: max(1, width - insetX * 2),
            height: max(1, height - insetY * 2)
        ).integral
        guard let cropped = cgImage.cropping(to: cropRect) else {
            return (true, 255)
        }

        let sampleWidth = 80
        let sampleHeight = 80
        let bytesPerPixel = 4
        let bytesPerRow = sampleWidth * bytesPerPixel
        guard let context = CGContext(
            data: nil,
            width: sampleWidth,
            height: sampleHeight,
            bitsPerComponent: 8,
            bytesPerRow: bytesPerRow,
            space: CGColorSpaceCreateDeviceRGB(),
            bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue
        ) else {
            return (true, 255)
        }
        context.interpolationQuality = .high
        context.draw(cropped, in: CGRect(x: 0, y: 0, width: sampleWidth, height: sampleHeight))
        guard let data = context.data else {
            return (true, 255)
        }

        let buffer = data.bindMemory(to: UInt8.self, capacity: sampleHeight * bytesPerRow)
        var minLuma = 255
        var maxLuma = 0
        for y in 0..<sampleHeight {
            let row = y * bytesPerRow
            for x in 0..<sampleWidth {
                let idx = row + x * bytesPerPixel
                let r = Int(buffer[idx])
                let g = Int(buffer[idx + 1])
                let b = Int(buffer[idx + 2])
                let luma = (r * 299 + g * 587 + b * 114) / 1000
                if luma < minLuma { minLuma = luma }
                if luma > maxLuma { maxLuma = luma }
            }
        }

        let variance = maxLuma - minLuma
        return (variance > 12, variance)
    }

    private func resolveBundleIdentifier() -> String? {
        if let explicit = targetBundleIdentifier, !explicit.isEmpty {
            return explicit
        }
        if let bundle: String = dynamicAppValue("bundleID") {
            if !bundle.isEmpty {
                return bundle
            }
        }
        return nil
    }

    private func triggerCodenameOneMainIfPossible() {
        guard let bundleID = resolveBundleIdentifier(), !bundleID.isEmpty else {
            print("CN1SS:WARN:codenameone_main_skipped reason=no_bundle_identifier")
            return
        }
        CodenameOneMainInvoker.shared.invokeIfNeeded(app: app, bundleIdentifier: bundleID)
    }

    private func sanitizeTestName(_ name: String) -> String {
        let allowed = CharacterSet(charactersIn: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-")
        let underscore: UnicodeScalar = "_"
        var scalars: [UnicodeScalar] = []
        scalars.reserveCapacity(name.unicodeScalars.count)
        for scalar in name.unicodeScalars {
            scalars.append(allowed.contains(scalar) ? scalar : underscore)
        }
        return String(String.UnicodeScalarView(scalars))
    }

    private func emitScreenshotPayloads(for shot: XCUIScreenshot, name: String) {
        let safeName = sanitizeTestName(name)
        let pngData = shot.pngRepresentation
        print("CN1SS:INFO:test=\(safeName) png_bytes=\(pngData.count)")
        emitScreenshotChannel(data: pngData, name: safeName, channel: "")

        if let preview = makePreviewJPEG(from: shot, pngData: pngData) {
            print("CN1SS:INFO:test=\(safeName) preview_jpeg_bytes=\(preview.data.count) preview_quality=\(preview.quality)")
            if preview.data.count > maxPreviewBytes {
                print("CN1SS:WARN:test=\(safeName) preview_exceeds_limit_bytes=\(preview.data.count) max_preview_bytes=\(maxPreviewBytes)")
            }
            emitScreenshotChannel(data: preview.data, name: safeName, channel: previewChannel)
        } else {
            print("CN1SS:INFO:test=\(safeName) preview_jpeg_bytes=0 preview_quality=0")
        }
    }

    private func makePreviewJPEG(from shot: XCUIScreenshot, pngData: Data) -> (data: Data, quality: Int)? {
        guard let image = UIImage(data: pngData) else {
            return nil
        }
        var chosenData: Data?
        var chosenQuality = 0
        var smallest = Int.max
        for quality in previewQualities {
            guard let jpeg = image.jpegData(compressionQuality: quality) else { continue }
            let length = jpeg.count
            if length < smallest {
                smallest = length
                chosenData = jpeg
                chosenQuality = Int((quality * 100).rounded())
            }
            if length <= maxPreviewBytes {
                break
            }
        }
        guard let finalData = chosenData, !finalData.isEmpty else {
            return nil
        }
        return (finalData, chosenQuality)
    }

    private func emitScreenshotChannel(data: Data, name: String, channel: String) {
        var prefix = "CN1SS"
        if !channel.isEmpty {
            prefix += channel
        }
        guard !data.isEmpty else {
            print("\(prefix):END:\(name)")
            return
        }
        let base64 = data.base64EncodedString()
        var current = base64.startIndex
        var position = 0
        var chunkCount = 0
        while current < base64.endIndex {
            let next = base64.index(current, offsetBy: chunkSize, limitedBy: base64.endIndex) ?? base64.endIndex
            let chunk = base64[current..<next]
            print("\(prefix):\(name):\(String(format: "%06d", position)):\(chunk)")
            chunkCount += 1
            position += chunk.count
            current = next
        }
        print("CN1SS:INFO:test=\(name) chunks=\(chunkCount) total_b64_len=\(base64.count)")
        print("\(prefix):END:\(name)")
    }
}

private final class CodenameOneMainInvoker {
    static let shared = CodenameOneMainInvoker()

    private let queue = DispatchQueue(label: "codenameone.main.invoker")
    private var invokedBundles: Set<String> = []
    private var handles: [String: UnsafeMutableRawPointer] = [:]

    private init() {}

    func invokeIfNeeded(app: XCUIApplication, bundleIdentifier: String) {
        var alreadyInvoked = false
        queue.sync {
            alreadyInvoked = invokedBundles.contains(bundleIdentifier)
        }
        if alreadyInvoked {
            return
        }

        guard let context = prepareInvocation(app: app, bundleIdentifier: bundleIdentifier) else {
            return
        }

        context.invoke()

        queue.sync {
            invokedBundles.insert(bundleIdentifier)
            handles[bundleIdentifier] = context.handle
        }
        print("CN1SS:INFO:codenameone_main_invoked bundle=\(bundleIdentifier)")
    }

    private func prepareInvocation(app: XCUIApplication, bundleIdentifier: String) -> InvocationContext? {
        guard let container = locateAppContainer(app: app, bundleIdentifier: bundleIdentifier) else {
            print("CN1SS:WARN:codenameone_main_skipped reason=container_missing bundle=\(bundleIdentifier)")
            return nil
        }

        guard let executable = readExecutableName(appContainer: container) else {
            print("CN1SS:WARN:codenameone_main_skipped reason=executable_missing bundle=\(bundleIdentifier)")
            return nil
        }

        let binaryPath = (container as NSString).appendingPathComponent(executable)
        guard let handle = dlopen(binaryPath, RTLD_NOW | RTLD_GLOBAL) else {
            if let error = dlerror() {
                print("CN1SS:WARN:codenameone_main_skipped reason=dlopen_failed bundle=\(bundleIdentifier) error=\(String(cString: error))")
            } else {
                print("CN1SS:WARN:codenameone_main_skipped reason=dlopen_failed bundle=\(bundleIdentifier)")
            }
            return nil
        }

        guard let initPtr = dlsym(handle, "initConstantPool") else {
            print("CN1SS:WARN:codenameone_main_skipped reason=missing_initConstantPool bundle=\(bundleIdentifier)")
            return nil
        }

        guard let threadPtr = dlsym(handle, "getThreadLocalData") else {
            print("CN1SS:WARN:codenameone_main_skipped reason=missing_getThreadLocalData bundle=\(bundleIdentifier)")
            return nil
        }

        let mainSymbol = "com_codenameone_examples_HelloCodenameOne_main___java_lang_String_1ARRAY"
        guard let mainPtr = dlsym(handle, mainSymbol) else {
            print("CN1SS:WARN:codenameone_main_skipped reason=missing_main_symbol bundle=\(bundleIdentifier) symbol=\(mainSymbol)")
            return nil
        }

        let initFn = unsafeBitCast(initPtr, to: InvocationContext.InitConstantPoolFn.self)
        let threadFn = unsafeBitCast(threadPtr, to: InvocationContext.GetThreadLocalDataFn.self)
        let mainFn = unsafeBitCast(mainPtr, to: InvocationContext.CodenameOneMainFn.self)

        return InvocationContext(handle: handle, initConstantPool: initFn, getThreadLocalData: threadFn, mainFunction: mainFn)
    }

    private func locateAppContainer(app: XCUIApplication, bundleIdentifier: String) -> String? {
        if let bundleURL: URL = dynamicAppValue("bundleURL"), !bundleURL.path.isEmpty {
            return bundleURL.path
        }

        if let bundlePath: String = dynamicAppValue("bundlePath"), !bundlePath.isEmpty {
            return bundlePath
        }

        if let container = locateViaSimctl(bundleIdentifier: bundleIdentifier) {
            return container
        }

        if let fallback = Bundle.main.infoDictionary?["CFBundleExecutable"] as? String {
            print("CN1SS:WARN:codenameone_main_skipped reason=bundle_path_unavailable bundle=\(bundleIdentifier) fallbackExecutable=\(fallback)")
        } else {
            print("CN1SS:WARN:codenameone_main_skipped reason=bundle_path_unavailable bundle=\(bundleIdentifier)")
        }
        return nil
    }

    private func readExecutableName(appContainer: String) -> String? {
        let infoPath = (appContainer as NSString).appendingPathComponent("Info.plist")
        guard let info = NSDictionary(contentsOfFile: infoPath) as? [String: Any] else {
            print("CN1SS:WARN:codenameone_main_skipped reason=info_plist_unreadable path=\(infoPath)")
            return nil
        }
        guard let executable = info["CFBundleExecutable"] as? String, !executable.isEmpty else {
            print("CN1SS:WARN:codenameone_main_skipped reason=cfbundleexecutablenotfound path=\(infoPath)")
            return nil
        }
        return executable
    }

    private func locateViaSimctl(bundleIdentifier: String) -> String? {
        let env = ProcessInfo.processInfo.environment
        guard let udid = env["SIMULATOR_UDID"], !udid.isEmpty else {
            return nil
        }

        let task = Process()
        task.executableURL = URL(fileURLWithPath: "/usr/bin/xcrun")
        task.arguments = ["simctl", "get_app_container", udid, bundleIdentifier]

        let stdoutPipe = Pipe()
        let stderrPipe = Pipe()
        task.standardOutput = stdoutPipe
        task.standardError = stderrPipe

        do {
            try task.run()
        } catch {
            print("CN1SS:WARN:codenameone_main_simctl_failed bundle=\(bundleIdentifier) error=\(error)")
            return nil
        }

        task.waitUntilExit()
        if task.terminationStatus != 0 {
            let data = stderrPipe.fileHandleForReading.readDataToEndOfFile()
            if let message = String(data: data, encoding: .utf8)?.trimmingCharacters(in: .whitespacesAndNewlines), !message.isEmpty {
                print("CN1SS:WARN:codenameone_main_simctl_failed bundle=\(bundleIdentifier) status=\(task.terminationStatus) stderr=\(message)")
            } else {
                print("CN1SS:WARN:codenameone_main_simctl_failed bundle=\(bundleIdentifier) status=\(task.terminationStatus)")
            }
            return nil
        }

        let data = stdoutPipe.fileHandleForReading.readDataToEndOfFile()
        guard let output = String(data: data, encoding: .utf8)?.trimmingCharacters(in: .whitespacesAndNewlines), !output.isEmpty else {
            print("CN1SS:WARN:codenameone_main_simctl_empty bundle=\(bundleIdentifier)")
            return nil
        }

        return output
    }

    private func dynamicAppValue<T>(_ selectorName: String) -> T? {
        let selector = NSSelectorFromString(selectorName)
        guard app.responds(to: selector) else {
            return nil
        }
        guard let unmanaged = app.perform(selector) else {
            return nil
        }
        let value = unmanaged.takeUnretainedValue()
        switch value {
        case let typed as T:
            return typed
        case let number as NSNumber where T.self == Bool.self:
            return (number.boolValue as? T)
        case let string as NSString where T.self == String.self:
            return (string as String) as? T
        case let url as NSURL where T.self == URL.self:
            return (url as URL) as? T
        default:
            return nil
        }
    }

    private struct InvocationContext {
        typealias InitConstantPoolFn = @convention(c) () -> Void
        typealias GetThreadLocalDataFn = @convention(c) () -> UnsafeMutableRawPointer?
        typealias CodenameOneMainFn = @convention(c) (UnsafeMutableRawPointer?, UnsafeMutableRawPointer?) -> Void

        let handle: UnsafeMutableRawPointer
        let initConstantPool: InitConstantPoolFn
        let getThreadLocalData: GetThreadLocalDataFn
        let mainFunction: CodenameOneMainFn

        func invoke() {
            initConstantPool()
            let threadState = getThreadLocalData()
            mainFunction(threadState, nil)
        }
    }
}
