<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CodenameOneImplementation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.impl</a> &gt; <span class="el_source">CodenameOneImplementation.java</span></div><h1>CodenameOneImplementation.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores
 * CA 94065 USA or visit www.oracle.com if you need additional information or
 * have any questions.
 */
package com.codename1.impl;

import com.codename1.capture.VideoCaptureConstraints;
import com.codename1.codescan.CodeScanner;
import com.codename1.components.AudioRecorderComponent;
import com.codename1.components.FileTree;
import com.codename1.components.FileTreeModel;
import com.codename1.contacts.Contact;
import com.codename1.db.Cursor;
import com.codename1.db.Database;
import com.codename1.io.ConnectionRequest;
import com.codename1.io.Cookie;
import com.codename1.io.FileSystemStorage;
import com.codename1.io.Log;
import com.codename1.io.NetworkManager;
import com.codename1.io.Preferences;
import com.codename1.io.Storage;
import com.codename1.io.Util;
import com.codename1.io.tar.TarEntry;
import com.codename1.io.tar.TarInputStream;
import com.codename1.l10n.L10NManager;
import com.codename1.location.LocationManager;
import com.codename1.media.Media;
import com.codename1.media.MediaManager;
import com.codename1.media.MediaRecorderBuilder;
import com.codename1.media.RemoteControlListener;
import com.codename1.messaging.Message;
import com.codename1.notifications.LocalNotification;
import com.codename1.payment.Purchase;
import com.codename1.payment.PurchaseCallback;
import com.codename1.push.PushCallback;
import com.codename1.ui.BrowserComponent;
import com.codename1.ui.BrowserWindow;
import com.codename1.ui.Button;
import com.codename1.ui.CN;
import com.codename1.ui.CN1Constants;
import com.codename1.ui.Command;
import com.codename1.ui.Component;
import com.codename1.ui.ComponentSelector;
import com.codename1.ui.Container;
import com.codename1.ui.Dialog;
import com.codename1.ui.Display;
import com.codename1.ui.EncodedImage;
import com.codename1.ui.Font;
import com.codename1.ui.Form;
import com.codename1.ui.Graphics;
import com.codename1.ui.Image;
import com.codename1.ui.Label;
import com.codename1.ui.PeerComponent;
import com.codename1.ui.Sheet;
import com.codename1.ui.Stroke;
import com.codename1.ui.TextArea;
import com.codename1.ui.TextField;
import com.codename1.ui.TextSelection;
import com.codename1.ui.Transform;
import com.codename1.ui.URLImage;
import com.codename1.ui.animations.Animation;
import com.codename1.ui.animations.Transition;
import com.codename1.ui.events.ActionEvent;
import com.codename1.ui.events.ActionListener;
import com.codename1.ui.events.MessageEvent;
import com.codename1.ui.geom.Dimension;
import com.codename1.ui.geom.Rectangle;
import com.codename1.ui.geom.Shape;
import com.codename1.ui.layouts.BorderLayout;
import com.codename1.ui.plaf.Style;
import com.codename1.ui.util.ImageIO;
import com.codename1.util.AsyncResource;
import com.codename1.util.FailureCallback;
import com.codename1.util.StringUtil;
import com.codename1.util.SuccessCallback;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.lang.ref.WeakReference;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Map;
import java.util.Vector;

/**
 * Represents a vendor extension mechanizm for Codename One, &lt;b&gt;WARNING: this class is for internal
 * use only and is subject to change in future API revisions&lt;/b&gt;. To replace the way in which
 * Codename One performs its task this class can be extended and its functionality replaced or
 * enhanced.
 * &lt;p&gt;It is the responsibility of the implementation class to grab and fire all events to the
 * Display specifically for key, pointer events and screen resolution.
 *
 * @author Shai Almog
 */
<span class="fc" id="L120">public abstract class CodenameOneImplementation {</span>
    /**
     * Indicates the range of &quot;hard&quot; RTL bidi characters in unicode
     */
    private static final int RTL_RANGE_BEGIN = 0x590;
    private static final int RTL_RANGE_END = 0x7BF;
    private static Object displayLock;
    private static boolean bidi;
    private static boolean pollingThreadRunning;
    private static PushCallback callback;
    private static PurchaseCallback purchaseCallback;
    private static Runnable onCurrentFormChange;
    private static Runnable onExit;
    private Object lightweightClipboard;
    private Hashtable linearGradientCache;
    private Hashtable radialGradientCache;
<span class="fc" id="L136">    private boolean builtinSoundEnabled = true;</span>
<span class="fc" id="L137">    private boolean dragStarted = false;</span>
<span class="fc" id="L138">    private int dragActivationCounter = 0;</span>
<span class="fc" id="L139">    private int dragActivationX = 0;</span>
<span class="fc" id="L140">    private int dragActivationY = 0;</span>
<span class="fc" id="L141">    private int dragStartPercentage = 3;</span>
    private Form currentForm;
<span class="fc" id="L143">    private Animation[] paintQueue = new Animation[200];</span>
<span class="fc" id="L144">    private Animation[] paintQueueTemp = new Animation[200];</span>
<span class="fc" id="L145">    private int paintQueueFill = 0;</span>
    private Graphics codenameOneGraphics;
    private String packageName;
    private Component editingText;
    private String appArg;
    /**
     * Useful since the content of a single element touch event is often recycled
     * and always arrives on 1 thread. Even on multi-tocuh devices a single coordinate
     * touch event should be very efficient
     */
<span class="fc" id="L155">    private final int[] xPointerEvent = new int[1];</span>
    /**
     * Useful since the content of a single element touch event is often recycled
     * and always arrives on 1 thread. Even on multi-tocuh devices a single coordinate
     * touch event should be very efficient
     */
<span class="fc" id="L161">    private final int[] yPointerEvent = new int[1];</span>
    private int pointerPressedX;
    private int pointerPressedY;
<span class="fc" id="L164">    private final Hashtable builtinSounds = new Hashtable();</span>
    private Object storageData;
    private Hashtable cookies;
    private ActionListener logger;
<span class="fc" id="L168">    private int commandBehavior = Display.COMMAND_BEHAVIOR_DEFAULT;</span>
<span class="fc" id="L169">    private boolean useNativeCookieStore = true;</span>
<span class="fc" id="L170">    private boolean initiailized = false;</span>
    /**
     * For use inside paintDirty() so that we don't have to instantiate
     * a rectangle each time it is called.
     */
<span class="fc" id="L175">    private final Rectangle paintDirtyTmpRect = new Rectangle();</span>
    private BrowserComponent sharedJavascriptContext;

    static void setOnCurrentFormChange(Runnable on) {
<span class="nc" id="L179">        onCurrentFormChange = on;</span>
<span class="nc" id="L180">    }</span>

    /**
     * Set a task to be executed once the implementation is being destroyed
     */
    public static void setOnExit(Runnable on) {
<span class="nc" id="L186">        onExit = on;</span>
<span class="nc" id="L187">    }</span>

    /**
     * Allows the system to register to receive push callbacks
     *
     * @param push the callback object
     */
    public static void setPushCallback(PushCallback push) {
<span class="nc" id="L195">        callback = push;</span>
<span class="nc" id="L196">    }</span>

    /**
     * Returns the purchase callback instance
     */
    public static PurchaseCallback getPurchaseCallback() {
<span class="nc" id="L202">        return purchaseCallback;</span>
    }

    /**
     * Allows the system to register the purchase callback instance
     *
     * @param pc the pc callback
     */
    public static void setPurchaseCallback(PurchaseCallback pc) {
<span class="nc" id="L211">        purchaseCallback = pc;</span>
<span class="nc" id="L212">    }</span>

    private static int round(double d) {
<span class="fc" id="L215">        double f = Math.floor(d);</span>
<span class="fc" id="L216">        double c = Math.ceil(d);</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (c - d &lt; d - f) {</span>
<span class="fc" id="L218">            return (int) c;</span>
        }
<span class="fc" id="L220">        return (int) f;</span>
    }

    /**
     * This is a temporary workaround for an XMLVM Bug!
     */
    public static Class getStringArrayClass() {
        try {
<span class="nc" id="L228">            return String[].class;</span>
<span class="nc" id="L229">        } catch (Throwable t) {</span>
<span class="nc" id="L230">            return new String[0].getClass();</span>
        }
    }

    /**
     * This is a temporary workaround for an XMLVM Bug!
     */
    public static Class getStringArray2DClass() {
        try {
<span class="nc" id="L239">            return String[][].class;</span>
<span class="nc" id="L240">        } catch (Throwable t) {</span>
<span class="nc" id="L241">            return new String[1][].getClass();</span>
        }
    }

    /**
     * This is a temporary workaround for an XMLVM Bug!
     */
    public static Class getImageArrayClass() {
        try {
<span class="nc" id="L250">            return Image[].class;</span>
<span class="nc" id="L251">        } catch (Throwable t) {</span>
<span class="nc" id="L252">            return new Image[0].getClass();</span>
        }
    }

    /**
     * This is a temporary workaround for an XMLVM Bug!
     */
    public static Class getObjectArrayClass() {
        try {
<span class="nc" id="L261">            return Object[].class;</span>
<span class="nc" id="L262">        } catch (Throwable t) {</span>
<span class="nc" id="L263">            return new Object[0].getClass();</span>
        }
    }

    /**
     * Stops the polling push loop
     */
    protected static void stopPolling() {
<span class="nc" id="L271">        pollingThreadRunning = false;</span>
<span class="nc" id="L272">    }</span>

    /**
     * Returns the key for the application comprised of the builders email coupled with the
     * package name. It should uniquely identify the application across different builds
     * which allows interaction with the cloud.
     *
     * @return a unique string with the format builders_email/packagename
     */
    protected static String getApplicationKey() {
<span class="nc" id="L282">        Display d = Display.getInstance();</span>
<span class="nc" id="L283">        return d.getProperty(&quot;built_by_user&quot;, &quot;Unknown Build Key&quot;) + '/' +</span>
<span class="nc" id="L284">                d.getProperty(&quot;package_name&quot;, &quot;Unknown Build Key&quot;);</span>
    }

    /**
     * Sends a server request to register push support. This is a method for use
     * by implementations.
     *
     * @param id             the platform specific push ID
     * @param applicationKey the unique id of the application
     * @param pushType       for server side type
     * @param packageName    the application package name used by the push service
     * @return true for success, false otherwise
     */
    public static boolean registerServerPush(String id, String applicationKey, byte pushType, String udid,
                                             String packageName) {
        //Log.p(&quot;registerPushOnServer invoked for id: &quot; + id + &quot; app key: &quot; + applicationKey + &quot; push type: &quot; + pushType);
<span class="nc" id="L300">        Preferences.set(&quot;push_key&quot;, id);</span>
        /*if(Preferences.get(&quot;push_id&quot;, (long)-1) == -1) {
            Preferences.set(&quot;push_key&quot;, id);
            ConnectionRequest r = new ConnectionRequest() {
                protected void readResponse(InputStream input) throws IOException  {
                    DataInputStream d = new DataInputStream(input);
                    long pid = d.readLong();
                    Preferences.set(&quot;push_id&quot;, pid);
                    Log.p(&quot;registerPushOnServer push id received from server: &quot; + pid);
                }
            };
            r.setPost(false);
            r.setFailSilently(true);
            r.setReadResponseForErrors(false);
            r.setUrl(Display.getInstance().getProperty(&quot;cloudServerURL&quot;, &quot;https://codename-one.appspot.com/&quot;) + &quot;registerPush&quot;);
            long val = Preferences.get(&quot;push_id&quot;, (long)-1);
            if(val &gt; -1) {
                r.addArgument(&quot;i&quot;, &quot;&quot; + val);
            }
            r.addArgument(&quot;p&quot;, id);
            r.addArgument(&quot;k&quot;, applicationKey);
            r.addArgument(&quot;os&quot;, Display.getInstance().getPlatformName());
            r.addArgument(&quot;t&quot;, &quot;&quot; + pushType);
            r.addArgument(&quot;ud&quot;, udid);
            r.addArgument(&quot;r&quot;, packageName);
            NetworkManager.getInstance().addToQueueAndWait(r);
            return r.getResponseCode() == 200;
        }*/
<span class="nc" id="L328">        return true;</span>
    }

    /**
     * Sends a server request to register push support. This is a method for use
     * by implementations.
     *
     * @param id             the platform specific push ID
     * @param applicationKey the unique id of the application
     * @param pushType       for server side type
     * @param packageName    the application package name used by the push service
     */
    public static void registerPushOnServer(String id, String applicationKey, byte pushType, String udid,
                                            String packageName) {
<span class="nc" id="L342">        registerServerPush(id, applicationKey, pushType, udid, packageName);</span>
<span class="nc" id="L343">    }</span>

    /**
     * For use by implementations, stop receiving push notifications from the server
     */
    public static void deregisterPushFromServer() {
        /*long i = Preferences.get(&quot;push_id&quot;, (long)-1);
        if(i &gt; -1) {
            ConnectionRequest r = new ConnectionRequest();
            r.setPost(false);
            r.setUrl(Display.getInstance().getProperty(&quot;cloudServerURL&quot;, &quot;https://codename-one.appspot.com/&quot;) + &quot;deregisterPush&quot;);
            r.addArgument(&quot;p&quot;, &quot;&quot; + i);
            r.addArgument(&quot;a&quot;, getApplicationKey());
            NetworkManager.getInstance().addToQueue(r);
            Preferences.delete(&quot;push_id&quot;);
            Preferences.delete(&quot;push_key&quot;);
        }*/
<span class="nc" id="L360">    }</span>

    /**
     * Registers a polling thread to simulate push notification
     *
     * @deprecated this functionality is no longer supported
     */
    protected static void registerPollingFallback() {
<span class="nc" id="L368">    }</span>

    /**
     * Invoked by the display init method allowing the implementation to &quot;bind&quot;
     *
     * @param m the object passed to the Display init method
     */
    public final void initImpl(Object m) {
<span class="fc" id="L376">        init(m);</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">        if (m != null) {</span>
<span class="nc" id="L378">            String clsName = m.getClass().getName();</span>
<span class="nc" id="L379">            packageName = clsName.substring(0, clsName.lastIndexOf('.'));</span>
        }
<span class="fc" id="L381">        initiailized = true;</span>
<span class="fc" id="L382">    }</span>

    /**
     * Returns true if the implementation is initialized.
     */
    public boolean isInitialized() {
<span class="fc" id="L388">        return initiailized;</span>
    }

    /**
     * Allows implementations to send an error to the push callback
     *
     * @param message   the error message
     * @param errorCode the error code
     */
    protected void sendPushRegistrationError(String message, int errorCode) {
<span class="nc bnc" id="L398" title="All 2 branches missed.">        if (callback != null) {</span>
<span class="nc" id="L399">            callback.pushRegistrationError(message, errorCode);</span>
        }
<span class="nc" id="L401">    }</span>

    /**
     * Invoked by the display init method allowing the implementation to &quot;bind&quot;
     *
     * @param m the object passed to the Display init method
     */
    public abstract void init(Object m);

    /**
     * Some implementations might need to perform initializations of the EDT thread
     */
    public void initEDT() {
<span class="fc" id="L414">    }</span>

    /**
     * Allows subclasses to cleanup if necessary
     */
    public void deinitialize() {
<span class="fc" id="L420">        initiailized = false;</span>
<span class="fc" id="L421">    }</span>

    /**
     * Invoked when a dialog is shown, this method allows a dialog to play a sound
     *
     * @param type the type of the dialog matching the dialog classes defined types
     */
    public void playDialogSound(final int type) {
<span class="nc" id="L429">    }</span>

    /**
     * Vibrates the device for the given length of time
     *
     * @param duration length of time to vibrate
     */
    public void vibrate(int duration) {
<span class="nc" id="L437">    }</span>

    /**
     * Flash the backlight of the device for the given length of time
     *
     * @param duration length of time to flash the backlight
     */
    public void flashBacklight(int duration) {
<span class="nc" id="L445">    }</span>

    /**
     * Returns the width dimension of the display controlled by this implementation
     *
     * @return the width
     */
    public abstract int getDisplayWidth();

    /**
     * Returns the height dimension of the display controlled by this implementation
     *
     * @return the height
     */
    public abstract int getDisplayHeight();

    /**
     * Returns the display height ignoring manipulations performed by the VKB
     *
     * @return the height
     */
    public int getActualDisplayHeight() {
<span class="nc" id="L467">        return getDisplayHeight();</span>
    }

    /**
     * Invoked when an exception occurs on the EDT, allows the implementation to
     * take control of the device to produce testing information.
     *
     * @param err the exception that was caught in the EDT loop
     * @return false by default, true if the exception shouldn't be handled further
     * by the EDT
     */
    public boolean handleEDTException(Throwable err) {
<span class="nc" id="L479">        return false;</span>
    }

    /**
     * Encapsulates the editing code which is specific to the platform, some platforms
     * would allow &quot;in place editing&quot; MIDP does not.
     *
     * @param cmp               the {@link TextArea} component
     * @param maxSize           the maximum size from the text area
     * @param constraint        the constraints of the text area
     * @param text              the string to edit
     * @param initiatingKeycode the keycode used to initiate the edit.
     */
    public final void editStringImpl(Component cmp, int maxSize, int constraint, String text, int initiatingKeycode) {
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (cmp instanceof TextArea) {</span>
<span class="nc" id="L494">            ((TextArea) cmp).registerAsInputDevice();</span>
        }
<span class="nc" id="L496">        editingText = cmp;</span>
<span class="nc" id="L497">        editString(cmp, maxSize, constraint, text, initiatingKeycode);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">        if (!isAsyncEditMode()) {</span>
<span class="nc" id="L499">            editingText = null;</span>
        }
<span class="nc" id="L501">    }</span>

    /**
     * Sets current editingText value and sets it focused.
     * NB! it not call editString, that is it should be called only internally and
     * actually the methdo should not be added :)
     */
    public void setFocusedEditingText(Component cmp) {
<span class="nc" id="L509">        editingText = cmp;</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">        if (cmp != null) {</span>
<span class="nc" id="L511">            Form form = cmp.getComponentForm();</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">            if (form != null) {</span>
<span class="nc" id="L513">                form.setFocused(cmp);</span>
            }
        }
<span class="nc" id="L516">    }</span>

    /**
     * Invoked for special cases to stop text editing and clear native editing state
     */
    public void stopTextEditing() {
<span class="nc" id="L522">    }</span>

    /**
     * Invoked for special cases to stop text editing and clear native editing state
     */
    public void stopTextEditing(Runnable onFinish) {
<span class="nc" id="L528">        stopTextEditing();</span>
<span class="nc" id="L529">        onFinish.run();</span>
<span class="nc" id="L530">    }</span>

    /**
     * Using invokeAndBlock inside EditString creates peculiar behaviour that needs
     * to be worked around.  Ideally no port should use invokeAndBlock for this
     * but currently JavaSE and UWP both do.  Need to be able to detect this
     * for workarounds.
     *
     * @return
     */
    public boolean usesInvokeAndBlockForEditString() {
<span class="nc" id="L541">        return false;</span>
    }

    /**
     * Encapsulates the editing code which is specific to the platform, some platforms
     * would allow &quot;in place editing&quot; MIDP does not.
     *
     * @param cmp               the {@link TextArea} component
     * @param maxSize           the maximum size from the text area
     * @param constraint        the constraints of the text area
     * @param text              the string to edit
     * @param initiatingKeycode the keycode used to initiate the edit.
     */
    public abstract void editString(Component cmp, int maxSize, int constraint, String text, int initiatingKeycode);

    public boolean nativeEditorPaintsHint() {
<span class="nc" id="L557">        return true;</span>
    }

    /**
     * Returns true if we are currently editing a component
     *
     * @return whether a component is being edited
     */
    public boolean isEditingText() {
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">        return editingText != null;</span>
    }

    /**
     * Checks to see if this is a platform that uses the {@link TextField#setInputMode(java.lang.String) }.
     */
    public boolean platformUsesInputMode() {
<span class="nc" id="L573">        Display d = Display.getInstance();</span>
<span class="nc" id="L574">        String platform = d.getPlatformName();</span>
<span class="nc bnc" id="L575" title="All 4 branches missed.">        return &quot;me&quot;.equals(platform) || &quot;rim&quot;.equals(platform);</span>
    }

    /**
     * Checks whether the native text editor is currently visible over top of the
     * given component (usually a {@code TextArea}
     *
     * @param c The textarea/component we are checking
     * @return True if the native editor is visible.
     */
    public boolean isNativeEditorVisible(Component c) {
<span class="pc bpc" id="L586" title="3 of 4 branches missed.">        return this.isNativeInputSupported() &amp;&amp; this.isEditingText(c);</span>
    }

    /**
     * Called when TextArea text is changed.  Can be used by the native
     * implementation to trigger an update to the native editor if in async edit
     * mode.
     *
     * @param c    The TextArea that is being edited.
     * @param text
     */
    public void updateNativeEditorText(Component c, String text) {

<span class="nc" id="L599">    }</span>

    /**
     * In case of scrolling we can hide the text editor unless the user starts typing again,
     * this is only relevant for the async mode...
     */
    public void hideTextEditor() {
<span class="nc" id="L606">        Component c = editingText;</span>
<span class="nc" id="L607">        editingText = null;</span>

        // this might happen when the component is no longer a part of the form e.g. in the case of table editing.
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L611">            c.repaint();</span>
        }
<span class="nc" id="L613">    }</span>

    public String getAppArg() {
<span class="fc" id="L616">        return appArg;</span>
    }

    public void setAppArg(String arg) {
<span class="fc" id="L620">        appArg = arg;</span>
<span class="fc" id="L621">    }</span>

    /**
     * Allows the implementation to refresh the text field
     */
    protected final void repaintTextEditor(final boolean focus) {
<span class="nc" id="L627">        Display.getInstance().callSerially(new Runnable() {</span>
            public void run() {
<span class="nc bnc" id="L629" title="All 2 branches missed.">                if (editingText != null) {</span>
<span class="nc" id="L630">                    editingText.repaint();</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">                    if (focus) {</span>
<span class="nc" id="L632">                        editingText.requestFocus();</span>
                    }
                }
<span class="nc" id="L635">            }</span>
        });
<span class="nc" id="L637">    }</span>

    /**
     * Returns true if we are currently editing this component
     *
     * @return whether a component is being edited
     */
    public boolean isEditingText(Component c) {
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">        return editingText == c;</span>
    }

    /**
     * Gets the component that is currently editing text
     *
     * @return
     */
    public Component getEditingText() {
<span class="nc" id="L654">        return editingText;</span>
    }

    /**
     * Returns true if edit string will return immediately and broadcast editing events directly to the text field
     *
     * @return false by default
     */
    public boolean isAsyncEditMode() {
<span class="fc" id="L663">        return false;</span>
    }

    /**
     * Returns the height of the VKB when it is open for an implementation that requires
     * us to allow scrolling further
     *
     * @return height in pixels
     */
    public int getInvisibleAreaUnderVKB() {
<span class="fc" id="L673">        return 0;</span>
    }

    /**
     * Invoked if Codename One needs to dispose the native text editing but would like the editor
     * to store its state.
     */
    public void saveTextEditingState() {
<span class="nc" id="L681">    }</span>

    /**
     * Returns true if the implementation still has elements to paint.
     *
     * @return false by default
     */
    public boolean hasPendingPaints() {
<span class="fc bfc" id="L689" title="All 2 branches covered.">        return paintQueueFill != 0;</span>
    }

    /**
     * Return the number of alpha levels supported by the implementation.
     *
     * @return the number of alpha levels supported by the implementation
     * @deprecated this method isn't implemented in most modern devices
     */
    public int numAlphaLevels() {
<span class="nc" id="L699">        return 255;</span>
    }

    /**
     * Returns the number of colors applicable on the device, note that the API
     * does not support gray scale devices.
     *
     * @return the number of colors applicable on the device
     * @deprecated this method isn't implemented in most modern devices
     */
    public int numColors() {
<span class="nc" id="L710">        return 65536;</span>
    }

    /**
     * This method allows customizing/creating a graphics context per component which is useful for
     * some elaborate implementations of Codename One. This method is only relevant for elborate components
     * such as container which render their own components rather than invoke repaint()
     *
     * @param cmp            component being rendered
     * @param currentContext the current graphics context
     * @return a graphics object thats appropriate for the given component.
     */
    public Graphics getComponentScreenGraphics(Component cmp, Graphics currentContext) {
<span class="fc" id="L723">        return currentContext;</span>
    }

    /**
     * Allows for painting an overlay on top of the implementation for notices during
     * testing etc.
     *
     * @param g graphics context on which to draw the overlay
     */
    protected void paintOverlay(Graphics g) {
<span class="fc" id="L733">    }</span>

    /**
     * Calculates the paintable bounds of a component.  The paintable bounds is
     * the bounds (in screen coordinates) that will be vislble on the screen.  This
     * accounts for possible clipping by parent components.
     *
     * @param c   The component whose paintable bounds we are interested in.
     * @param out A rectangle to return the bounds in.
     */
    private void getPaintableBounds(Component c, Rectangle out) {
<span class="fc" id="L744">        int x = c.getAbsoluteX() + c.getScrollX();</span>
<span class="fc" id="L745">        int y = c.getAbsoluteY() + c.getScrollY();</span>
<span class="fc" id="L746">        int x2 = x + c.getWidth();</span>
<span class="fc" id="L747">        int y2 = y + c.getHeight();</span>

<span class="fc" id="L749">        Container parent = null;</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">        if ((parent = c.getParent()) != null) {</span>
<span class="fc" id="L751">            getPaintableBounds(parent, out);</span>
<span class="fc" id="L752">            x = Math.max(out.getX(), x);</span>
<span class="fc" id="L753">            y = Math.max(out.getY(), y);</span>
<span class="fc" id="L754">            x2 = Math.min(out.getX() + out.getWidth(), x2);</span>
<span class="fc" id="L755">            y2 = Math.min(out.getY() + out.getHeight(), y2);</span>


        }
<span class="fc" id="L759">        out.setBounds(x, y, x2 - x, y2 - y);</span>

<span class="fc" id="L761">    }</span>

    /**
     * Invoked by the EDT to paint the dirty regions
     */
    public void paintDirty() {
<span class="fc" id="L767">        int size = 0;</span>
<span class="fc" id="L768">        synchronized (displayLock) {</span>
<span class="fc" id="L769">            size = paintQueueFill;</span>
<span class="fc" id="L770">            Animation[] array = paintQueue;</span>
<span class="fc" id="L771">            paintQueue = paintQueueTemp;</span>
<span class="fc" id="L772">            paintQueueTemp = array;</span>
<span class="fc" id="L773">            paintQueueFill = 0;</span>
<span class="fc" id="L774">        }</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">        if (size &gt; 0) {</span>
<span class="fc" id="L776">            Graphics wrapper = getCodenameOneGraphics();</span>
<span class="fc" id="L777">            int dwidth = getDisplayWidth();</span>
<span class="fc" id="L778">            int dheight = getDisplayHeight();</span>
<span class="fc" id="L779">            int topX = dwidth;</span>
<span class="fc" id="L780">            int topY = dheight;</span>
<span class="fc" id="L781">            int bottomX = 0;</span>
<span class="fc" id="L782">            int bottomY = 0;</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">            for (int iter = 0; iter &lt; size; iter++) {</span>
<span class="fc" id="L784">                Animation ani = paintQueueTemp[iter];</span>

                // might happen due to paint queue removal
<span class="pc bpc" id="L787" title="1 of 2 branches missed.">                if (ani == null) {</span>
<span class="nc" id="L788">                    continue;</span>
                }
<span class="fc" id="L790">                paintQueueTemp[iter] = null;</span>
<span class="fc" id="L791">                wrapper.translate(-wrapper.getTranslateX(), -wrapper.getTranslateY());</span>
<span class="fc" id="L792">                wrapper.resetAffine();</span>
<span class="fc" id="L793">                wrapper.setClip(0, 0, dwidth, dheight);</span>
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">                if (ani instanceof Component) {</span>
<span class="fc" id="L795">                    Component cmp = (Component) ani;</span>
<span class="fc" id="L796">                    Rectangle dirty = cmp.getDirtyRegion();</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">                    if (dirty != null) {</span>
<span class="nc" id="L798">                        Dimension d = dirty.getSize();</span>
<span class="nc" id="L799">                        wrapper.setClip(dirty.getX(), dirty.getY(), d.getWidth(), d.getHeight());</span>
<span class="nc" id="L800">                        cmp.setDirtyRegion(null);</span>
                    }
<span class="fc" id="L802">                    cmp.paintComponent(wrapper);</span>
<span class="fc" id="L803">                    getPaintableBounds(cmp, paintDirtyTmpRect);</span>
<span class="fc" id="L804">                    int cmpAbsX = paintDirtyTmpRect.getX();</span>
<span class="fc" id="L805">                    topX = Math.min(cmpAbsX, topX);</span>
<span class="fc" id="L806">                    bottomX = Math.max(cmpAbsX + paintDirtyTmpRect.getWidth(), bottomX);</span>
<span class="fc" id="L807">                    int cmpAbsY = paintDirtyTmpRect.getY();</span>
<span class="fc" id="L808">                    topY = Math.min(cmpAbsY, topY);</span>
<span class="fc" id="L809">                    bottomY = Math.max(cmpAbsY + paintDirtyTmpRect.getHeight(), bottomY);</span>
<span class="fc" id="L810">                } else {</span>
<span class="nc" id="L811">                    bottomX = dwidth;</span>
<span class="nc" id="L812">                    bottomY = dheight;</span>
<span class="nc" id="L813">                    topX = 0;</span>
<span class="nc" id="L814">                    topY = 0;</span>
<span class="nc" id="L815">                    ani.paint(wrapper);</span>
                }
            }

<span class="fc" id="L819">            paintOverlay(wrapper);</span>
            //Log.p(&quot;Flushing graphics : &quot;+topX+&quot;,&quot;+topY+&quot;,&quot;+bottomX+&quot;,&quot;+bottomY);
<span class="fc" id="L821">            flushGraphics(topX, topY, bottomX - topX, bottomY - topY);</span>
        }
<span class="fc" id="L823">    }</span>

    /**
     * This method is a callback from the edt before the edt enters to an idle
     * state
     *
     * @param enter true before the edt sleeps and false when exits from the
     *              idle state
     */
    public void edtIdle(boolean enter) {
<span class="fc" id="L833">    }</span>

    /**
     * Flush the currently painted drawing onto the screen if using a double buffer
     *
     * @param x      position of the dirty region
     * @param y      position of the dirty region
     * @param width  width of the dirty region
     * @param height height of the dirty region
     */
    public abstract void flushGraphics(int x, int y, int width, int height);

    /**
     * Flush the currently painted drawing onto the screen if using a double buffer
     */
    public abstract void flushGraphics();

    /**
     * Returns a graphics object for use by the painting
     *
     * @return a graphics object, either recycled or new, this object will be
     * used on the EDT
     */
    protected Graphics getCodenameOneGraphics() {
<span class="fc" id="L857">        return codenameOneGraphics;</span>
    }

    /**
     * Installs the Codename One graphics object into the implementation
     *
     * @param g graphics object for use by the implementation
     */
    public void setCodenameOneGraphics(Graphics g) {
<span class="fc" id="L866">        codenameOneGraphics = g;</span>
<span class="fc" id="L867">    }</span>

    /**
     * A flag that can be overridden by a platform to indicate that native
     * peers are rendered behind the main codename one graphics layer.  The main
     * effect of this is that Graphics will call clearRect() any time a native
     * component is &quot;painted&quot; to poke a hole through the CN1 layer.
     *
     * @return
     */
    public boolean paintNativePeersBehind() {
<span class="fc" id="L878">        return false;</span>
    }

    /**
     * Returns a lock object which can be synchronized against, this lock is used
     * by the EDT.
     *
     * @return a lock object
     */
    public Object getDisplayLock() {
<span class="nc" id="L888">        return displayLock;</span>
    }

    /**
     * Installs the display lock allowing implementors to synchronize against the
     * Display mutex, this method is invoked internally and should not be used.
     *
     * @param lock the mutex from display
     */
    public void setDisplayLock(Object lock) {
<span class="fc" id="L898">        displayLock = lock;</span>
<span class="fc" id="L899">    }</span>

    /**
     * Removes an entry from the paint queue if it exists, this is important for cases
     * in which a component was repainted and immediately removed from its parent container
     * afterwards. This happens sometimes in cases where a replace() operation changes
     * a component to a new component that has an animation() the animation might have triggered
     * a repaint before the removeComponent method was invoked
     *
     * @param cmp the component to
     */
    public void cancelRepaint(Animation cmp) {
<span class="fc" id="L911">        synchronized (displayLock) {</span>
<span class="pc bpc" id="L912" title="1 of 2 branches missed.">            for (int iter = 0; iter &lt; paintQueueFill; iter++) {</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">                if (paintQueue[iter] == cmp) {</span>
<span class="nc" id="L914">                    paintQueue[iter] = null;</span>
<span class="nc" id="L915">                    return;</span>
                }
            }

<span class="fc" id="L919">        }</span>
<span class="fc" id="L920">    }</span>

    /**
     * Invoked to add an element to the paintQueue
     *
     * @param cmp component or animation to push into the paint queue
     */
    public void repaint(Animation cmp) {
<span class="fc" id="L928">        synchronized (displayLock) {</span>
<span class="pc bfc" id="L929" title="All 2 branches covered.">            for (int iter = 0; iter &lt; paintQueueFill; iter++) {</span>
<span class="fc" id="L930">                Animation ani = paintQueue[iter];</span>
<span class="fc bfc" id="L931" title="All 2 branches covered.">                if (ani == cmp) {</span>
<span class="fc" id="L932">                    return;</span>
                }
                //no need to paint a Component if one of its parent is already in the queue
<span class="pc bpc" id="L935" title="2 of 4 branches missed.">                if (ani instanceof Container &amp;&amp; cmp instanceof Component) {</span>
<span class="fc" id="L936">                    Component parent = ((Component) cmp).getParent();</span>
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">                    while (parent != null) {</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">                        if (parent == ani) {</span>
<span class="fc" id="L939">                            return;</span>
                        }
<span class="fc" id="L941">                        parent = parent.getParent();</span>
                    }
                }
            }
            // overcrowding the queue don't try to grow the array!
<span class="pc bpc" id="L946" title="1 of 2 branches missed.">            if (paintQueueFill &gt;= paintQueue.length) {</span>
<span class="nc" id="L947">                System.out.println(&quot;Warning paint queue size exceeded, please watch the amount of repaint calls&quot;);</span>
<span class="nc" id="L948">                return;</span>
            }

<span class="fc" id="L951">            paintQueue[paintQueueFill] = cmp;</span>
<span class="fc" id="L952">            paintQueueFill++;</span>
<span class="fc" id="L953">            displayLock.notify();</span>
<span class="fc" id="L954">        }</span>
<span class="fc" id="L955">    }</span>

    /**
     * Extracts RGB data from the given native image and places it in the given array
     *
     * @param nativeImage native platform image object
     * @param arr         int array to store RGB data
     * @param offset      position within the array to start
     * @param x           x position within the image
     * @param y           y position within the image
     * @param width       width to extract
     * @param height      height to extract
     */
    public abstract void getRGB(Object nativeImage, int[] arr, int offset, int x, int y, int width, int height);

    /**
     * Create a platform native image object from the given RGB data
     *
     * @param rgb    ARGB data from which to create a platform image
     * @param width  width for the resulting image
     * @param height height for the resulting image
     * @return platform image object
     */
    public abstract Object createImage(int[] rgb, int width, int height);

    /**
     * Creates a native image from a file in the system jar or file system storage.
     *
     * @param path If path begins with {@literal file:} this will load a file from FileSystemStorage.  Otherwise it will load from jar.
     * @return native system image
     * @throws java.io.IOException if thrown by loading
     */
    public abstract Object createImage(String path) throws IOException;

    /**
     * Creates a native image from a given input stream
     *
     * @param i input stream from which to load the image
     * @return native system image
     * @throws java.io.IOException if thrown by loading
     */
    public abstract Object createImage(InputStream i) throws IOException;

    /**
     * Creates a modifable native image that can return a graphics object
     *
     * @param width     the width of the mutable image
     * @param height    the height of the mutable image
     * @param fillColor the ARGB fill color, alpha may be ignored based on the value of
     *                  isAlphaMutableImageSupported
     * @return the native image
     */
    public abstract Object createMutableImage(int width, int height, int fillColor);

    /**
     * Indicates whether mutable images respect alpha values when constructed
     *
     * @return true if mutable images can have an alpha value when initially created
     */
    public boolean isAlphaMutableImageSupported() {
<span class="fc" id="L1015">        return false;</span>
    }

    /**
     * Create a nativate image from its compressed byte data
     *
     * @param bytes  the byte array representing the image data
     * @param offset offset within the byte array
     * @param len    the length for the image within the byte array
     * @return a native image
     */
    public abstract Object createImage(byte[] bytes, int offset, int len);

    /**
     * Returns the width of a native image
     *
     * @param i the native image
     * @return the width of the native image
     */
    public abstract int getImageWidth(Object i);

    /**
     * Returns the height of a native image
     *
     * @param i the native image
     * @return the height of the native image
     */
    public abstract int getImageHeight(Object i);

    /**
     * Scales a native image and returns the scaled version
     *
     * @param nativeImage image to scale
     * @param width       width of the resulting image
     * @param height      height of the resulting image
     * @return scaled image instance
     */
    public abstract Object scale(Object nativeImage, int width, int height);

    /**
     * Returns an instance of this image rotated by the given number of degrees. By default 90 degree
     * angle divisions are supported, anything else is implementation dependent. This method assumes
     * a square image. Notice that it is inefficient in the current implementation to rotate to
     * non-square angles,
     * &lt;p&gt;E.g. rotating an image to 45, 90 and 135 degrees is inefficient. Use rotatate to 45, 90
     * and then rotate the 45 to another 90 degrees to achieve the same effect with less memory.
     *
     * @param degrees A degree in right angle must be larger than 0 and up to 359 degrees
     * @return new image instance with the closest possible rotation
     */
    public Object rotate(Object image, int degrees) {
<span class="fc" id="L1066">        int width = getImageWidth(image);</span>
<span class="fc" id="L1067">        int height = getImageHeight(image);</span>
<span class="fc" id="L1068">        int[] arr = new int[width * height];</span>
<span class="fc" id="L1069">        int[] dest = new int[arr.length];</span>
<span class="fc" id="L1070">        getRGB(image, arr, 0, 0, 0, width, height);</span>
<span class="fc" id="L1071">        int centerX = width / 2;</span>
<span class="fc" id="L1072">        int centerY = height / 2;</span>

<span class="fc" id="L1074">        double radians = Math.toRadians(-degrees);</span>
<span class="fc" id="L1075">        double cosDeg = Math.cos(radians);</span>
<span class="fc" id="L1076">        double sinDeg = Math.sin(radians);</span>
<span class="fc bfc" id="L1077" title="All 2 branches covered.">        for (int x = 0; x &lt; width; x++) {</span>
<span class="fc bfc" id="L1078" title="All 2 branches covered.">            for (int y = 0; y &lt; height; y++) {</span>
<span class="fc" id="L1079">                int x2 = round(cosDeg * (x - centerX) - sinDeg * (y - centerY) + centerX);</span>
<span class="fc" id="L1080">                int y2 = round(sinDeg * (x - centerX) + cosDeg * (y - centerY) + centerY);</span>
<span class="pc bpc" id="L1081" title="1 of 8 branches missed.">                if (!(x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= width || y2 &gt;= height)) {</span>
<span class="fc" id="L1082">                    int destOffset = x2 + y2 * width;</span>
<span class="pc bpc" id="L1083" title="2 of 4 branches missed.">                    if (destOffset &gt;= 0 &amp;&amp; destOffset &lt; dest.length) {</span>
<span class="fc" id="L1084">                        dest[x + y * width] = arr[destOffset];</span>
                    }
                }
            }
        }
<span class="fc" id="L1089">        return createImage(dest, width, height);</span>
    }

    /**
     * Rotates the given image by 90 degrees while changing the ratio of the picture
     *
     * @param image           the image
     * @param maintainOpacity whether the opacity in the image should be maintained
     * @return a new image rotated by 90 degrees
     */
    public Image rotate90Degrees(Image image, boolean maintainOpacity) {
<span class="nc" id="L1100">        int[] rgb = image.getRGB();</span>
<span class="nc" id="L1101">        int[] newRGB = new int[rgb.length];</span>
<span class="nc" id="L1102">        int width = image.getWidth();</span>
<span class="nc" id="L1103">        int height = image.getHeight();</span>

<span class="nc bnc" id="L1105" title="All 2 branches missed.">        for (int y = 0; y &lt; height; y++) {</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc" id="L1107">                int destX = height - y - 1;</span>
<span class="nc" id="L1108">                newRGB[destX + x * height] = rgb[x + y * width];</span>
            }
        }

        // we reverse width/height
<span class="nc bnc" id="L1113" title="All 2 branches missed.">        return EncodedImage.createFromRGB(newRGB, height, width, !maintainOpacity);</span>
    }

    /**
     * Rotates the given image by 180 degrees
     *
     * @param image           the image
     * @param maintainOpacity whether the opacity in the image should be maintained
     * @return a new image rotated by 180 degrees
     */
    public Image rotate180Degrees(Image image, boolean maintainOpacity) {
<span class="nc" id="L1124">        int[] rgb = image.getRGB();</span>
<span class="nc" id="L1125">        int[] newRGB = new int[rgb.length];</span>
<span class="nc" id="L1126">        int width = image.getWidth();</span>
<span class="nc" id="L1127">        int height = image.getHeight();</span>

<span class="nc bnc" id="L1129" title="All 2 branches missed.">        for (int y = 0; y &lt; height; y++) {</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc" id="L1131">                int destX = width - x - 1;</span>
<span class="nc" id="L1132">                newRGB[destX + (height - y - 1) * width] = rgb[x + y * width];</span>
            }
        }

<span class="nc bnc" id="L1136" title="All 2 branches missed.">        return EncodedImage.createFromRGB(newRGB, width, height, !maintainOpacity);</span>
    }

    /**
     * Rotates the given image by 270 degrees while changing the ratio of the picture
     *
     * @param image           the image
     * @param maintainOpacity whether the opacity in the image should be maintained
     * @return a new image rotated by 270 degrees
     */
    public Image rotate270Degrees(Image image, boolean maintainOpacity) {
<span class="nc" id="L1147">        int[] rgb = image.getRGB();</span>
<span class="nc" id="L1148">        int[] newRGB = new int[rgb.length];</span>
<span class="nc" id="L1149">        int width = image.getWidth();</span>
<span class="nc" id="L1150">        int height = image.getHeight();</span>

<span class="nc bnc" id="L1152" title="All 2 branches missed.">        for (int y = 0; y &lt; height; y++) {</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc" id="L1154">                newRGB[y + (width - x - 1) * height] = rgb[x + y * width];</span>
            }
        }

        // we reverse width/height
<span class="nc bnc" id="L1159" title="All 2 branches missed.">        return EncodedImage.createFromRGB(newRGB, height, width, !maintainOpacity);</span>
    }

    /**
     * Flips the given image on the horizontal axis
     *
     * @param image           the image
     * @param maintainOpacity whether the opacity in the image should be maintained
     * @return a new image flipped
     */
    public Image flipImageHorizontally(Image image, boolean maintainOpacity) {
<span class="nc" id="L1170">        int[] rgb = image.getRGB();</span>
<span class="nc" id="L1171">        int[] newRGB = new int[rgb.length];</span>
<span class="nc" id="L1172">        int width = image.getWidth();</span>
<span class="nc" id="L1173">        int height = image.getHeight();</span>

<span class="nc bnc" id="L1175" title="All 2 branches missed.">        for (int y = 0; y &lt; height; y++) {</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x++) {</span>
<span class="nc" id="L1177">                newRGB[(width - x - 1) + y * width] = rgb[x + y * width];</span>
            }
        }

<span class="nc bnc" id="L1181" title="All 2 branches missed.">        return EncodedImage.createFromRGB(newRGB, width, height, !maintainOpacity);</span>
    }

    /**
     * Flips the given image on the vertical axis
     *
     * @param image           the image
     * @param maintainOpacity whether the opacity in the image should be maintained
     * @return a new image flipped
     */
    public Image flipImageVertically(Image image, boolean maintainOpacity) {
<span class="nc" id="L1192">        int[] rgb = image.getRGB();</span>
<span class="nc" id="L1193">        int[] newRGB = new int[rgb.length];</span>
<span class="nc" id="L1194">        int width = image.getWidth();</span>
<span class="nc" id="L1195">        int height = image.getHeight();</span>

<span class="nc bnc" id="L1197" title="All 2 branches missed.">        for (int y = 0; y &lt; height; y++) {</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">            if (width &gt;= 0) System.arraycopy(rgb, 0 + y * width, newRGB, 0 + (height - y - 1) * width, width);</span>
        }

<span class="nc bnc" id="L1201" title="All 2 branches missed.">        return EncodedImage.createFromRGB(newRGB, width, height, !maintainOpacity);</span>
    }

    /**
     * Returns true if the platform supports a native image cache.  The native image cache
     * is different than just {@link FileSystemStorage#hasCachesDir()}.  A native image cache
     * is an image cache that the platform provides that is full transparent to Codename One
     * with respect to how images are stored, and whether they are cached.  Currently only
     * the Javascript port supprts a native image cache.
     *
     * &lt;p&gt;This is used by {@link URLImage#createCachedImage(java.lang.String, java.lang.String, com.codename1.ui.Image, int) }
     * to determine if it should use a cached image, or to defer to its storage and filesystem methods.&lt;/p&gt;
     *
     * @return True on platforms that support a native image cache.  Currently only Javascript.
     * @see Display#supportsNativeImageCache()
     */
    public boolean supportsNativeImageCache() {
<span class="nc" id="L1218">        return false;</span>
    }

    /**
     * Downloads an image from a URL to the cache. Platforms
     * that support a native image cache {@link #supportsNativeImageCache() } (e.g. Javascript) override this method to defer to the
     * platform's handling of cached images.  Platforms that have a caches directory ({@link FileSystemStorage#hasCachesDir() }
     * will use that directory to cache the image.  Other platforms will just download to storage.
     *
     * @param url       The URL of the image to download.
     * @param onSuccess Callback on success.
     * @param onFail    Callback on fail.
     * @see URLImage#createToCache(com.codename1.ui.EncodedImage, java.lang.String, com.codename1.ui.URLImage.ImageAdapter)
     */
    public void downloadImageToCache(String url, SuccessCallback&lt;Image&gt; onSuccess, final FailureCallback&lt;Image&gt; onFail) {
<span class="nc" id="L1233">        FileSystemStorage fs = FileSystemStorage.getInstance();</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">        if (fs.hasCachesDir()) {</span>
<span class="nc" id="L1235">            String name = &quot;cn1_image_cache[&quot; + url + &quot;]&quot;;</span>
<span class="nc" id="L1236">            name = StringUtil.replaceAll(name, &quot;/&quot;, &quot;_&quot;);</span>
<span class="nc" id="L1237">            name = StringUtil.replaceAll(name, &quot;\\&quot;, &quot;_&quot;);</span>
<span class="nc" id="L1238">            name = StringUtil.replaceAll(name, &quot;%&quot;, &quot;_&quot;);</span>
<span class="nc" id="L1239">            name = StringUtil.replaceAll(name, &quot;?&quot;, &quot;_&quot;);</span>
<span class="nc" id="L1240">            name = StringUtil.replaceAll(name, &quot;*&quot;, &quot;_&quot;);</span>
<span class="nc" id="L1241">            name = StringUtil.replaceAll(name, &quot;:&quot;, &quot;_&quot;);</span>
<span class="nc" id="L1242">            name = StringUtil.replaceAll(name, &quot;=&quot;, &quot;_&quot;);</span>

<span class="nc" id="L1244">            String filePath = fs.getCachesDir() + fs.getFileSystemSeparator() + name;</span>

            // We use Util.downloadImageToFileSystem rather than CodenameOneImplementation.downloadImageToFileSystem
            // because we want it to try to load from file system first.
<span class="nc" id="L1248">            Util.downloadImageToFileSystem(url, filePath, onSuccess, onFail);</span>
<span class="nc" id="L1249">        } else {</span>
            // We use Util.downloadImageToStorage rather than CodenameOneImplementation.downloadImageToStorage
            // because we want it to try to load from storage first.
<span class="nc" id="L1252">            Util.downloadImageToStorage(url, &quot;cn1_image_cache[&quot; + url + &quot;]&quot;, onSuccess, onFail);</span>
        }
<span class="nc" id="L1254">    }</span>

    /**
     * Downloads an image to storage. This will *not* first check to see if the image is located in storage
     * already.  It will download and overwrite any existing image at the provided location.
     *
     * &lt;p&gt;Some platforms may override this method to use platform-level caching.  E.g. Javascript will use
     * the browser cache for downloading the image.&lt;/p&gt;
     *
     * @param url       The URL of the image to download.
     * @param fileName  The storage key to be used to store the image.
     * @param onSuccess Callback on success.  Will be executed on EDT.
     * @param onFail    Callback on failure.  Will be executed on EDT.
     */
    public void downloadImageToStorage(String url, String fileName, SuccessCallback&lt;Image&gt; onSuccess, FailureCallback&lt;Image&gt; onFail) {
<span class="nc" id="L1269">        ConnectionRequest cr = new ConnectionRequest();</span>
<span class="nc" id="L1270">        cr.setPost(false);</span>
<span class="nc" id="L1271">        cr.setFailSilently(true);</span>
<span class="nc" id="L1272">        cr.setReadResponseForErrors(false);</span>
<span class="nc" id="L1273">        cr.setDuplicateSupported(true);</span>
<span class="nc" id="L1274">        cr.setUrl(url);</span>
<span class="nc" id="L1275">        cr.downloadImageToStorage(fileName, onSuccess, onFail);</span>
<span class="nc" id="L1276">    }</span>

    /**
     * Downloads an image to file system. This will *not* first check to see if the file exists already.
     * It will download and overwrite any existing image at the provided location.
     *
     * &lt;p&gt;Some platforms may override this method to use platform-level caching.  E.g. Javascript will use
     * the browser cache for downloading the image.&lt;/p&gt;
     *
     * @param url       The URL of the image to download.
     * @param fileName  The storage key to be used to store the image.
     * @param onSuccess Callback on success.  Will be executed on EDT.
     * @param onFail    Callback on failure.  Will be executed on EDT.
     */
    public void downloadImageToFileSystem(String url, String fileName, SuccessCallback&lt;Image&gt; onSuccess, FailureCallback&lt;Image&gt; onFail) {
<span class="nc" id="L1291">        ConnectionRequest cr = new ConnectionRequest();</span>
<span class="nc" id="L1292">        cr.setPost(false);</span>
<span class="nc" id="L1293">        cr.setFailSilently(true);</span>
<span class="nc" id="L1294">        cr.setReadResponseForErrors(false);</span>
<span class="nc" id="L1295">        cr.setDuplicateSupported(true);</span>
<span class="nc" id="L1296">        cr.setUrl(url);</span>
<span class="nc" id="L1297">        cr.downloadImageToFileSystem(fileName, onSuccess, onFail);</span>
<span class="nc" id="L1298">    }</span>

    /**
     * Returns the number of softkeys on the device
     *
     * @return the number of softkey buttons on the device
     */
    public abstract int getSoftkeyCount();

    /**
     * Returns the softkey keycode for the given softkey index
     *
     * @param index the index of the softkey
     * @return the set of keycodes which can indicate the softkey, multiple keycodes
     * might apply to the same functionality
     */
    public abstract int[] getSoftkeyCode(int index);

    /**
     * Returns the keycode for the clear key
     *
     * @return the system key code for this device
     */
    public abstract int getClearKeyCode();

    /**
     * Returns the keycode for the backspace key
     *
     * @return the system key code for this device
     */
    public abstract int getBackspaceKeyCode();

    /**
     * Returns the keycode for the back key
     *
     * @return the system key code for this device
     */
    public abstract int getBackKeyCode();

    /**
     * Returns the display game action for the given keyCode if applicable to match
     * the contrct of Codename One for the game action behavior
     *
     * @param keyCode the device keycode
     * @return a game action or 0
     */
    public abstract int getGameAction(int keyCode);

    /**
     * Returns a keycode which can be sent to getGameAction
     *
     * @param gameAction the game action
     * @return key code matching the given game action
     */
    public abstract int getKeyCode(int gameAction);

    /**
     * Returns true if the device will send touch events
     *
     * @return true if the device will send touch events
     */
    public abstract boolean isTouchDevice();

    /**
     * Callback before showing a specific form
     *
     * @param f the form shown
     */
    public void onShow(Form f) {
<span class="pc bpc" id="L1367" title="1 of 2 branches missed.">        if (onCurrentFormChange != null) {</span>
<span class="nc" id="L1368">            onCurrentFormChange.run();</span>
        }
<span class="fc" id="L1370">    }</span>

    /**
     * Callback method allowing the implementation to confirm that it controls the
     * view just before a new form is installed.
     */
    public void confirmControlView() {
<span class="fc" id="L1377">    }</span>

    /**
     * Returns the current form, this method is for internal use only and does not
     * take transitions/menus into consideration
     *
     * @return The internal current form
     */
    public Form getCurrentForm() {
<span class="fc" id="L1386">        return currentForm;</span>
    }

    /**
     * This method is used internally to determine the actual current form
     * it doesn't perform the logic of transitions etc. and shouldn't be invoked
     * by developers
     *
     * @param f the current form
     */
    public void setCurrentForm(Form f) {
<span class="fc" id="L1397">        currentForm = f;</span>
<span class="fc" id="L1398">    }</span>

    /**
     * Codename One can translate all coordinates and never requires a call to translate
     * this works well for some devices which have hairy issues with translate.
     * However for some platforms where translate can be leveraged with affine transforms
     * this can be a problem. These platforms can choose to translate on their own
     *
     * @return true if the implementation is interested in receiving translate calls
     * and handling them.
     */
    public boolean isTranslationSupported() {
<span class="nc" id="L1410">        return false;</span>
    }

    /**
     * Translates the X/Y location for drawing on the underlying surface. Translation
     * is incremental so the new value will be added to the current translation and
     * in order to reset translation we have to invoke
     * {@code translate(-getTranslateX(), -getTranslateY()) }
     *
     * @param graphics the graphics context
     * @param x        the x coordinate
     * @param y        the y coordinate
     */
    public void translate(Object graphics, int x, int y) {
<span class="nc" id="L1424">    }</span>

    /**
     * Returns the current x translate value
     *
     * @param graphics the graphics context
     * @return the current x translate value
     */
    public int getTranslateX(Object graphics) {
<span class="nc" id="L1433">        return 0;</span>
    }

    /**
     * Returns the current y translate value
     *
     * @param graphics the graphics context
     * @return the current y translate value
     */
    public int getTranslateY(Object graphics) {
<span class="nc" id="L1443">        return 0;</span>
    }

    /**
     * Returns the current color
     *
     * @param graphics the graphics context
     * @return the RGB graphics color
     */
    public abstract int getColor(Object graphics);

    /**
     * Sets the current rgb color while ignoring any potential alpha component within
     * said color value.
     *
     * @param graphics the graphics context
     * @param RGB      the RGB value for the color.
     */
    public abstract void setColor(Object graphics, int RGB);

    /**
     * Alpha value from 0-255 can be ignored for some operations
     *
     * @param graphics the graphics context
     * @param alpha    the alpha channel
     */
    public abstract void setAlpha(Object graphics, int alpha);

    /**
     * Concatenates alpha value to current alpha.
     *
     * @param graphics The graphics context
     * @param alpha    The alpha to concatenate.
     * @return The previous alpha value.
     */
    public final int concatenateAlpha(Object graphics, int alpha) {
<span class="pc bpc" id="L1479" title="1 of 2 branches missed.">        if (alpha == 255) return getAlpha(graphics);</span>
<span class="nc" id="L1480">        int oldAlpha = getAlpha(graphics);</span>
<span class="nc" id="L1481">        setAlpha(graphics, (int) (oldAlpha * (alpha / 255f)));</span>
<span class="nc" id="L1482">        return oldAlpha;</span>
    }

    /**
     * Alpha value from 0-255 can be ignored for some operations
     *
     * @param graphics the graphics context
     * @return the alpha channel
     */
    public abstract int getAlpha(Object graphics);

    /**
     * Returns true if alpha can be applied for all elements globally and efficiently
     * otherwise alpha should be ignored.
     * Notice that fillRect MUST always support alpha regardless of the value of this
     * variable!
     *
     * @return true if alpha support is natively implemented
     */
    public boolean isAlphaGlobal() {
<span class="fc" id="L1502">        return false;</span>
    }

    /**
     * Indicates whether the underlying implementation allows for anti-aliasing in regular
     * drawing operations
     *
     * @return false by default
     */
    public boolean isAntiAliasingSupported() {
<span class="nc" id="L1512">        return false;</span>
    }

    public boolean isAntiAliasingSupported(Object graphics) {
<span class="nc" id="L1516">        return isAntiAliasingSupported();</span>
    }

    /**
     * Indicates whether the underlying implementation allows for anti-aliased fonts
     *
     * @return false by default
     */
    public boolean isAntiAliasedTextSupported() {
<span class="nc" id="L1525">        return false;</span>
    }

    public boolean isAntiAliasedTextSupported(Object graphics) {
<span class="nc" id="L1529">        return isAntiAliasedTextSupported();</span>
    }
    
    /*
    public void setClipShape(Object graphics, Shape shape){
        if ( shape.isRectangle() ){
            setClipRect(graphics, (Rectangle)shape);
        } else {
            throw new RuntimeException(&quot;Only rectangle clips supported in this port&quot;);
        }
    }
    
    public Shape getClipShape(Object graphics){
        return this.getClipRect(graphics);
    }
    */

    /**
     * Toggles anti-aliasing mode for regular rendering operations
     *
     * @param graphics the graphics context
     * @param a        true to activate Anti-aliasing, false to disable it
     */
    public void setAntiAliased(Object graphics, boolean a) {
<span class="nc" id="L1553">    }</span>

    /**
     * Returns anti-aliasing mode for regular rendering operations
     *
     * @param graphics the graphics context
     * @return true if Anti-aliasing is active, false otherwise
     */
    public boolean isAntiAliased(Object graphics) {
<span class="nc" id="L1562">        return false;</span>
    }

    /**
     * Toggles anti-aliasing mode for font rendering operations
     *
     * @param graphics the graphics context
     * @param a        true to activate Anti-aliasing, false to disable it
     */
    public void setAntiAliasedText(Object graphics, boolean a) {
<span class="nc" id="L1572">    }</span>

    /**
     * Returns anti-aliasing mode for font rendering operations
     *
     * @param graphics the graphics context
     * @return true if Anti-aliasing is active, false otherwise
     */
    public boolean isAntiAliasedText(Object graphics) {
<span class="nc" id="L1581">        return false;</span>
    }

    // ----- BEGIN CLIP STACK METHODS ---  ADDED TO HELP SUPPORT TRANSFORMATIONS
    // in the clip.

    /**
     * Installs a native font object
     *
     * @param graphics the graphics context
     * @param font     the native font object
     */
    public abstract void setNativeFont(Object graphics, Object font);

    /**
     * Returns the internal clipping rectangle. This method must create a new
     * rectangle object to prevent corruption by modification.
     *
     * @param graphics the graphics context
     * @return the clipping rectangle.
     */
    public Rectangle getClipRect(Object graphics) {
<span class="nc" id="L1603">        return new Rectangle(getClipX(graphics), getClipY(graphics), new Dimension(getClipWidth(graphics), getClipHeight(graphics)));</span>
    }

    /**
     * Returns the clipping coordinate
     *
     * @param graphics the graphics context
     * @return the clipping coordinate
     */
    public abstract int getClipX(Object graphics);


    // ----- END CLIP STACK METHODS

    /**
     * Returns the clipping coordinate
     *
     * @param graphics the graphics context
     * @return the clipping coordinate
     */
    public abstract int getClipY(Object graphics);

    /**
     * Returns the clipping coordinate
     *
     * @param graphics the graphics context
     * @return the clipping coordinate
     */
    public abstract int getClipWidth(Object graphics);

    /**
     * Returns the clipping coordinate
     *
     * @param graphics the graphics context
     * @return the clipping coordinate
     */
    public abstract int getClipHeight(Object graphics);

    /**
     * Installs a new clipping rectangle
     *
     * @param graphics the graphics context
     * @param rect     rectangle representing the new clipping area
     */
    public void setClipRect(Object graphics, Rectangle rect) {
<span class="nc" id="L1648">        Dimension d = rect.getSize();</span>
<span class="nc" id="L1649">        setClip(graphics, rect.getX(), rect.getY(), d.getWidth(), d.getHeight());</span>
<span class="nc" id="L1650">    }</span>

    /**
     * Installs a new clipping rectangle
     *
     * @param graphics the graphics context
     * @param x        coordinate
     * @param y        coordinate
     * @param width    size
     * @param height   size
     * @param rect     rectangle representing the new clipping area
     */
    public abstract void setClip(Object graphics, int x, int y, int width, int height);

    /**
     * Clips the Graphics context to the Shape.
     *
     * @param graphics the graphics context
     * @param shape    The shape to clip.
     */
    public void setClip(Object graphics, Shape shape) {
<span class="nc" id="L1671">        System.out.println(&quot;Shape clip is not supported&quot;);</span>
<span class="nc" id="L1672">    }</span>

    /**
     * Changes the current clipping rectangle to subset the current clipping with
     * the given clipping.
     *
     * @param graphics the graphics context
     * @param rect     rectangle representing the new clipping area
     */
    public void clipRect(Object graphics, Rectangle rect) {
<span class="nc" id="L1682">        Dimension d = rect.getSize();</span>
<span class="nc" id="L1683">        clipRect(graphics, rect.getX(), rect.getY(), d.getWidth(), d.getHeight());</span>
<span class="nc" id="L1684">    }</span>

    /**
     * Changes the current clipping rectangle to subset the current clipping with
     * the given clipping.
     *
     * @param graphics the graphics context
     * @param x        coordinate
     * @param y        coordinate
     * @param width    size
     * @param height   size
     * @param rect     rectangle representing the new clipping area
     */
    public abstract void clipRect(Object graphics, int x, int y, int width, int height);

    /**
     * Pushes the current clip onto the clip stack so that it can be retrieved later
     * by {@link #popClip}.
     *
     * @param graphics The native graphics context.
     */
    public void pushClip(Object graphics) {

<span class="nc" id="L1707">    }</span>

    /**
     * Cleans up resources used by graphics object
     *
     * @param graphics
     */
    public void disposeGraphics(Object graphics) {

<span class="fc" id="L1716">    }</span>

    /**
     * Pops the clip from the top of the clip stack and sets it as the current clip.
     *
     * @param graphics The native graphics context.
     * @return The clip that was popped off the top of the clip stack.
     */
    public void popClip(Object graphics) {
        // NOt implemented yet... need to implement.


<span class="nc" id="L1728">    }</span>

    /**
     * Draws a line between the 2 X/Y coordinates
     *
     * @param graphics the graphics context
     * @param x1       first x position
     * @param y1       first y position
     * @param x2       second x position
     * @param y2       second y position
     */
    public abstract void drawLine(Object graphics, int x1, int y1, int x2, int y2);


    // METHODS FOR DEALING WITH 2-D Paths

    /**
     * Fills the rectangle from the given position according to the width/height
     * minus 1 pixel according to the convention in Java.
     *
     * @param graphics the graphics context
     * @param x        the x coordinate of the rectangle to be filled.
     * @param y        the y coordinate of the rectangle to be filled.
     * @param width    the width of the rectangle to be filled.
     * @param height   the height of the rectangle to be filled.
     */
    public abstract void fillRect(Object graphics, int x, int y, int width, int height);

    public void clearRect(Object graphics, int x, int y, int width, int height) {
<span class="nc" id="L1757">        System.out.println(&quot;clearRect() not implemented on this platform&quot;);</span>
<span class="nc" id="L1758">    }</span>

    /**
     * Draws a rectangle in the given coordinates
     *
     * @param graphics the graphics context
     * @param x        the x coordinate of the rectangle to be drawn.
     * @param y        the y coordinate of the rectangle to be drawn.
     * @param width    the width of the rectangle to be drawn.
     * @param height   the height of the rectangle to be drawn.
     */
    public abstract void drawRect(Object graphics, int x, int y, int width, int height);

    /**
     * Draws a rectangle in the given coordinates
     *
     * @param graphics  the graphics context
     * @param x         the x coordinate of the rectangle to be drawn.
     * @param y         the y coordinate of the rectangle to be drawn.
     * @param width     the width of the rectangle to be drawn.
     * @param height    the height of the rectangle to be drawn.
     * @param thickness the thickness in pixels
     */
    public void drawRect(Object graphics, int x, int y, int width, int height, int thickness) {
<span class="nc" id="L1782">        width--;</span>
<span class="nc" id="L1783">        height--;</span>
<span class="nc bnc" id="L1784" title="All 2 branches missed.">        for (int iter = 0; iter &lt; thickness; iter++) {</span>
<span class="nc" id="L1785">            drawRect(graphics, x + iter, y + iter, width, height);</span>
<span class="nc" id="L1786">            width -= 2;</span>
<span class="nc" id="L1787">            height -= 2;</span>
        }
<span class="nc" id="L1789">    }</span>

    /**
     * Draws a rounded corner rectangle in the given coordinates with the arcWidth/height
     * matching the last two arguments respectively.
     *
     * @param graphics  the graphics context
     * @param x         the x coordinate of the rectangle to be drawn.
     * @param y         the y coordinate of the rectangle to be drawn.
     * @param width     the width of the rectangle to be drawn.
     * @param height    the height of the rectangle to be drawn.
     * @param arcWidth  the horizontal diameter of the arc at the four corners.
     * @param arcHeight the vertical diameter of the arc at the four corners.
     */
    public abstract void drawRoundRect(Object graphics, int x, int y, int width, int height, int arcWidth, int arcHeight);

    /**
     * Fills a rounded rectangle in the same way as drawRoundRect
     *
     * @param graphics  the graphics context
     * @param x         the x coordinate of the rectangle to be filled.
     * @param y         the y coordinate of the rectangle to be filled.
     * @param width     the width of the rectangle to be filled.
     * @param height    the height of the rectangle to be filled.
     * @param arcWidth  the horizontal diameter of the arc at the four corners.
     * @param arcHeight the vertical diameter of the arc at the four corners.
     * @see #drawRoundRect
     */
    public abstract void fillRoundRect(Object graphics, int x, int y, int width, int height, int arcWidth, int arcHeight);

    /**
     * Fills a circular or elliptical arc based on the given angles and bounding
     * box. The resulting arc begins at startAngle and extends for arcAngle
     * degrees.
     *
     * @param graphics   the graphics context
     * @param x          the x coordinate of the upper-left corner of the arc to be filled.
     * @param y          the y coordinate of the upper-left corner of the arc to be filled.
     * @param width      the width of the arc to be filled.
     * @param height     the height of the arc to be filled.
     * @param startAngle the beginning angle.
     * @param arcAngle   the angular extent of the arc, relative to the start angle.
     */
    public abstract void fillArc(Object graphics, int x, int y, int width, int height, int startAngle, int arcAngle);

    /**
     * Draws a circular or elliptical arc based on the given angles and bounding
     * box
     *
     * @param graphics   the graphics context
     * @param x          the x coordinate of the upper-left corner of the arc to be drawn.
     * @param y          the y coordinate of the upper-left corner of the arc to be drawn.
     * @param width      the width of the arc to be drawn.
     * @param height     the height of the arc to be drawn.
     * @param startAngle the beginning angle.
     * @param arcAngle   the angular extent of the arc, relative to the start angle.
     */
    public abstract void drawArc(Object graphics, int x, int y, int width, int height, int startAngle, int arcAngle);

    /**
     * Draw a string using the current font and color in the x,y coordinates. The font is drawn
     * from the top position and not the baseline.
     *
     * @param graphics the graphics context
     * @param str      the string to be drawn.
     * @param x        the x coordinate.
     * @param y        the y coordinate.
     */
    public abstract void drawString(Object graphics, String str, int x, int y);

    /**
     * Draws the image so its top left coordinate corresponds to x/y
     *
     * @param graphics the graphics context
     * @param img      the specified native image to be drawn
     * @param x        the x coordinate.
     * @param y        the y coordinate.
     */
    public abstract void drawImage(Object graphics, Object img, int x, int y);

    /**
     * Draws the image so its top left coordinate corresponds to x/y
     *
     * @param graphics the graphics context
     * @param img      the specified native image to be drawn
     * @param x        the x coordinate.
     * @param y        the y coordinate.
     * @param w        the width
     * @param h        the height
     */
    public void drawImage(Object graphics, Object img, int x, int y, int w, int h) {
<span class="nc" id="L1880">    }</span>

    public Image createImage(Shape shape, Stroke stroke, int color) {

<span class="nc" id="L1884">        return null;</span>
    }


    // END METHODS FOR DEALING WITH 2-D Paths

    /**
     * Draws outline of shape on the given graphics context.
     * &lt;p&gt;The last 4 parameters specify a bounding box for drawing the Shape.  The shape's bounds will
     * be made to fit this box exactly for drawing.  This allows for resizing the shape on the GPU
     * if graphics acceleration is supported.&lt;/p&gt;
     *
     * @param graphics the graphics context
     * @param shape    the shape to draw.
     * @param stroke   The stroke to use for drawing the contour.
     * @see isShapeSupported() to determine of the graphics context supports drawing
     * shapes.
     */
    public void drawShape(Object graphics, Shape shape, Stroke stroke) {
<span class="nc" id="L1903">    }</span>

    /**
     * Fills the given shape in the specified graphics context using the graphics context's
     * currently selected color and alpha.
     *
     * @param graphics
     * @param shape
     * @see drawShape To learn what x, y, w, and h do.
     */
    public void fillShape(Object graphics, Shape shape) {
<span class="nc" id="L1914">    }</span>

    /**
     * Draws a drop shadow for an image onto the given graphics context.
     *
     * &lt;p&gt;This is used for the elevation feature.&lt;/p&gt;
     *
     * &lt;p&gt;Note: This operation is expensive on most platforms as it is not hardware accelerated.  Codename One's elevation functionality
     * uses this method to generate shadow images which it reuses as much as possible for maximum performance.&lt;/p&gt;
     *
     * &lt;p&gt;Note: Currently this is not supported on all platforms.  Use {@link #isDrawShadowSupported()} to check for platform support at
     * runtime.  Use {@link #isDrawShadowFast()} to check for hardware acceleration.&lt;/p&gt;
     *
     * &lt;p&gt;Note: On iOS, this is only supported for drawing to mutable images - not the global graphics context.&lt;/p&gt;
     *
     * @param graphics     The graphics context.
     * @param image        The image whose raster should be used to generate the shadow.  The alpha channel of this image is used as the
     *                     bases for the shadow projection.
     * @param x            x-coordinate of the graphics context where shadow should be painted.
     * @param y            y-coordinate of the graphics context where shadow should be painted.
     * @param offsetX      The shadow offset X in pixels.
     * @param offsetY      The shadow offset Y in pixels.
     * @param blurRadius   The blur radius in pixels.
     * @param spreadRadius The shadow spread in pixels.
     * @param color        The shadow color.
     * @param opacity      The shadow opacity.
     * @see Component#paintShadows(Graphics, int, int)
     * @see Container#paintSurfaceShadows(Graphics)
     * @see #isDrawShadowSupported()
     * @see #isDrawShadowFast()
     * @since 8.0
     */
    public void drawShadow(Object graphics, Object image, int x, int y, int offsetX, int offsetY, int blurRadius, int spreadRadius, int color, float opacity) {

<span class="nc" id="L1948">    }</span>

    /**
     * Checks to see if drawing shadows is supported on this platform.
     *
     * @return True if the platform supports drawing shadows.
     * @see #drawShadow(Object, Object, int, int, int, int, int, int, int, float)
     * @since 8.0
     */
    public boolean isDrawShadowSupported() {
<span class="nc" id="L1958">        return false;</span>
    }

    /**
     * Checks to see if drawing shadows on this platform is hardware accelerated.
     *
     * @return True if drawing shadows is hardware accelerated.
     * @since 8.0
     */
    public boolean isDrawShadowFast() {
<span class="nc" id="L1968">        return false;</span>
    }

    /**
     * Sets the transformation matrix to be applied to all drawing operations. If
     * originX, originY are non-zero, then the the transformation will first be translated
     * to the origin, then applied, and then translated back.
     *
     * &lt;p&gt;If isTransformSupported() returns false, then this method won't do anything.&lt;/p&gt;
     * &lt;p&gt;If isPerspectiveTransformSupported() returns false, then this method will only
     * deal with 2D transformation matrices (i.e. the upper left 3x3 matrix of the provided
     * transformation matrix.&lt;/p&gt;
     *
     * @param graphics
     * @param m        The transformation matrix.  Can be 3x3 or 4x4.
     * @see isTransformSupported() To check if this graphics context supports transformations.
     * @see isPerspectiveTransformSupported() To check if this graphics context
     * supports perspective/3D transformations.
     */
    public void setTransform(Object graphics, Transform transform) {

<span class="nc" id="L1989">    }</span>

    /**
     * Gets the current transformation matrix.  This will populate the provided
     * matrix with the data of the current transformation.
     *
     * @param graphics
     * @see isTransformSupported()
     * @see isPerspectiveTransformSupported()
     * @deprecated Use {@link #getTransform(java.lang.Object, com.codename1.ui.Transform) } instead.
     */
    public Transform getTransform(Object graphics) {
<span class="nc" id="L2001">        return Transform.makeIdentity();</span>
    }

    /**
     * Checks if matrix transformations are supported in the provided graphics context.
     *
     * @param graphics
     * @return True if matrix transformations are supported by this graphics context.
     * @see setTransform()
     * @see getTransform()
     * @see isPerspectiveTransformSupported()
     */
    public boolean isTransformSupported(Object graphics) {
<span class="nc" id="L2014">        return false;</span>
    }

    /**
     * Checks if 3d/perspective transformations are supported in the provided graphics context.
     *
     * @param graphics
     * @return
     * @see setTransform()
     * @see getTransform()
     * @see isTransformSupported()
     */
    public boolean isPerspectiveTransformSupported(Object graphics) {
<span class="nc" id="L2027">        return false;</span>
    }

    /**
     * Checks if drawing shapes is supported by the provided graphics context.
     *
     * @param graphics
     * @return
     */
    public boolean isShapeSupported(Object graphics) {
<span class="nc" id="L2037">        return false;</span>
    }

    /**
     * Checks if clipping shapes is supported by the provided graphics context.
     *
     * @param graphics
     * @return
     */
    public boolean isShapeClipSupported(Object graphics) {
<span class="nc" id="L2047">        return false;</span>
    }

    /**
     * Allows an implementation to optimize image tiling rendering logic
     *
     * @param graphics the graphics object
     * @param img      the image
     * @param x        coordinate to tile the image along
     * @param y        coordinate to tile the image along
     * @param w        coordinate to tile the image along
     * @param h        coordinate to tile the image along
     */
    public void tileImage(Object graphics, Object img, int x, int y, int w, int h) {
<span class="nc" id="L2061">        int iW = getImageWidth(img);</span>
<span class="nc" id="L2062">        int iH = getImageHeight(img);</span>
<span class="nc" id="L2063">        int clipX = getClipX(graphics);</span>
<span class="nc" id="L2064">        int clipW = getClipWidth(graphics);</span>
<span class="nc" id="L2065">        int clipY = getClipY(graphics);</span>
<span class="nc" id="L2066">        int clipH = getClipHeight(graphics);</span>
<span class="nc" id="L2067">        clipRect(graphics, x, y, w, h);</span>
<span class="nc bnc" id="L2068" title="All 2 branches missed.">        for (int xPos = 0; xPos &lt;= w; xPos += iW) {</span>
<span class="nc bnc" id="L2069" title="All 2 branches missed.">            for (int yPos = 0; yPos &lt; h; yPos += iH) {</span>
<span class="nc" id="L2070">                int actualX = xPos + x;</span>
<span class="nc" id="L2071">                int actualY = yPos + y;</span>
<span class="nc bnc" id="L2072" title="All 2 branches missed.">                if (actualX &gt; clipX + clipW) {</span>
<span class="nc" id="L2073">                    continue;</span>
                }
<span class="nc bnc" id="L2075" title="All 2 branches missed.">                if (actualX + iW &lt; clipX) {</span>
<span class="nc" id="L2076">                    continue;</span>
                }
<span class="nc bnc" id="L2078" title="All 2 branches missed.">                if (actualY &gt; clipY + clipH) {</span>
<span class="nc" id="L2079">                    continue;</span>
                }
<span class="nc bnc" id="L2081" title="All 2 branches missed.">                if (actualY + iH &lt; clipY) {</span>
<span class="nc" id="L2082">                    continue;</span>
                }
<span class="nc" id="L2084">                drawImage(graphics, img, actualX, actualY);</span>
            }
        }
<span class="nc" id="L2087">        setClip(graphics, clipX, clipY, clipW, clipH);</span>
<span class="nc" id="L2088">    }</span>

    /**
     * Indicates if the native video player includes its own play/pause etc. controls so the movie player
     * component doesn't need to include them
     *
     * @return true if the movie player component doesn't need to include such controls
     */
    public boolean isNativeVideoPlayerControlsIncluded() {
<span class="nc" id="L2097">        return false;</span>
    }

    /**
     * Indicates if image scaling on the fly is supported by the platform, if not Codename One will just scale the images on its own before drawing
     */
    public boolean isScaledImageDrawingSupported() {
<span class="nc" id="L2104">        return false;</span>
    }

    /**
     * Draws a portion of the image
     *
     * @param nativeGraphics the graphics context
     * @param img            the specified native image to be drawn
     * @param x              the x coordinate.
     * @param y              the y coordinate.
     * @param imageX         location within the image to draw
     * @param imageY         location within the image to draw
     * @param imageWidth     size of the location within the image to draw
     * @param imageHeight    size of the location within the image to draw
     */
    public void drawImageArea(Object nativeGraphics, Object img, int x, int y, int imageX, int imageY, int imageWidth, int imageHeight) {
<span class="nc" id="L2120">        int clipX = getClipX(nativeGraphics);</span>
<span class="nc" id="L2121">        int clipY = getClipY(nativeGraphics);</span>
<span class="nc" id="L2122">        int clipWidth = getClipWidth(nativeGraphics);</span>
<span class="nc" id="L2123">        int clipHeight = getClipHeight(nativeGraphics);</span>
        //pushClip(nativeGraphics);
<span class="nc" id="L2125">        clipRect(nativeGraphics, x, y, imageWidth, imageHeight);</span>
<span class="nc bnc" id="L2126" title="All 4 branches missed.">        if (getClipWidth(nativeGraphics) &gt; 0 &amp;&amp; getClipHeight(nativeGraphics) &gt; 0) {</span>
<span class="nc" id="L2127">            drawImage(nativeGraphics, img, x - imageX, y - imageY);</span>
        }
        //popClip(nativeGraphics);
<span class="nc" id="L2130">        setClip(nativeGraphics, clipX, clipY, clipWidth, clipHeight);</span>
<span class="nc" id="L2131">    }</span>

    /**
     * Draws the image so its top left coordinate corresponds to x/y with a fast
     * native rotation in a square angle which must be one of 0, 90, 180 or 270
     *
     * @param graphics the graphics context
     * @param img      the specified native image to be drawn
     * @param x        the x coordinate.
     * @param y        the y coordinate.
     * @param degrees  either 0, 90, 180 or 270 degree rotation for the image drawing
     */
    public void drawImageRotated(Object graphics, Object img, int x, int y, int degrees) {
<span class="nc" id="L2144">    }</span>

    /**
     * Indicates whether drawImageRotated is supported by the platform for FAST drawing,
     * if not then its not worth calling the method which will be unimplemented!
     *
     * @return true if drawImageRotated will draw an image
     */
    public boolean isRotationDrawingSupported() {
<span class="fc" id="L2153">        return false;</span>
    }

    /**
     * Draws a filled triangle with the given coordinates
     *
     * @param graphics the graphics context
     * @param x1       the x coordinate of the first vertex of the triangle
     * @param y1       the y coordinate of the first vertex of the triangle
     * @param x2       the x coordinate of the second vertex of the triangle
     * @param y2       the y coordinate of the second vertex of the triangle
     * @param x3       the x coordinate of the third vertex of the triangle
     * @param y3       the y coordinate of the third vertex of the triangle
     */
    public void fillTriangle(Object graphics, int x1, int y1, int x2, int y2, int x3, int y3) {
<span class="nc" id="L2168">        fillPolygon(graphics, new int[]{x1, x2, x3}, new int[]{y1, y2, y3}, 3);</span>
<span class="nc" id="L2169">    }</span>

    /**
     * Draws the RGB values based on the MIDP API of a similar name. Renders a
     * series of device-independent RGB+transparency values in a specified
     * region. The values are stored in rgbData in a format with 24 bits of
     * RGB and an eight-bit alpha value (0xAARRGGBB), with the first value
     * stored at the specified offset. The scanlength  specifies the relative
     * offset within the array between the corresponding pixels of consecutive
     * rows. Any value for scanlength is acceptable (even negative values)
     * provided that all resulting references are within the bounds of the
     * rgbData array. The ARGB data is rasterized horizontally from left to
     * right within each row. The ARGB values are rendered in the region
     * specified by x, y, width and height, and the operation is subject
     * to the current clip region and translation for this Graphics object.
     *
     * @param graphics     the graphics context
     * @param rgbData      an array of ARGB values in the format 0xAARRGGBB
     * @param offset       the array index of the first ARGB value
     * @param x            the horizontal location of the region to be rendered
     * @param y            the vertical location of the region to be rendered
     * @param w            the width of the region to be rendered
     * @param h            the height of the region to be rendered
     * @param processAlpha true if rgbData has an alpha channel, false if
     *                     all pixels are fully opaque
     */
    public abstract void drawRGB(Object graphics, int[] rgbData, int offset, int x, int y, int w, int h, boolean processAlpha);

    /**
     * Returns the native graphics object on which all rendering operations occur
     *
     * @return a native graphics context
     */
    public abstract Object getNativeGraphics();

    /**
     * Returns the native graphics object on the given native image occur
     *
     * @param image the native image on which the graphics will draw
     * @return a native graphics context
     */
    public abstract Object getNativeGraphics(Object image);

    /**
     * Return the width of the given characters in the given native font instance
     *
     * @param nativeFont the font for which the string width should be calculated
     * @param ch         array of characters
     * @param offset     characters offsets
     * @param length     characters length
     * @return the width of the given characters in this font instance
     */
    public abstract int charsWidth(Object nativeFont, char[] ch, int offset, int length);

    /**
     * Returns the ascent of the specified native font instance.  Should always
     * return a non-negative value.
     *
     * @param nativeFont
     * @return The ascent of the native font instance
     */
    public int getFontAscent(Object nativeFont) {
<span class="fc" id="L2231">        return (int) (((float) getHeight(nativeFont)) * 0.7);</span>
    }

    /**
     * Returns the descent below the baseline that a font can span.  Should always
     * be non-negative.
     *
     * @param nativeFont
     * @return
     */
    public int getFontDescent(Object nativeFont) {
<span class="nc" id="L2242">        return getHeight(nativeFont) - getFontAscent(nativeFont);</span>
    }

    /**
     * Checks whether the implementation supports drawing text on the baseline.
     *
     * @return
     */
    public boolean isBaselineTextSupported() {
<span class="nc" id="L2251">        return false;</span>
    }

    /**
     * Return the width of the given string in this font instance
     *
     * @param nativeFont the font for which the string width should be calculated
     * @param str        the given string     *
     * @return the width of the given string in this font instance
     */
    public abstract int stringWidth(Object nativeFont, String str);

    /**
     * Return the width of the specific character when rendered alone
     *
     * @param nativeFont the font for which the string width should be calculated
     * @param ch         the specific character
     * @return the width of the specific character when rendered alone
     */
    public abstract int charWidth(Object nativeFont, char ch);

    /**
     * Return the total height of the font
     *
     * @param nativeFont the font for which the string width should be calculated
     * @return the total height of the font
     */
    public abstract int getHeight(Object nativeFont);

    /**
     * Return the global default font instance, if font is passed as null
     * this font should be used
     *
     * @return the global default font instance
     */
    public abstract Object getDefaultFont();

    /**
     * Optional operation returning the font face for the font
     *
     * @param nativeFont the font for which the string width should be calculated
     * @return Optional operation returning the font face for system fonts
     */
    public int getFace(Object nativeFont) {
<span class="nc" id="L2295">        return 0;</span>
    }

    /**
     * Optional operation returning the font size for system fonts
     *
     * @param nativeFont the font for which the string width should be calculated
     * @return Optional operation returning the font size for system fonts
     */
    public int getSize(Object nativeFont) {
<span class="nc" id="L2305">        return 0;</span>
    }

    /**
     * Optional operation returning the font style for system fonts
     *
     * @param nativeFont the font for which the string width should be calculated
     * @return Optional operation returning the font style for system fonts
     */
    public int getStyle(Object nativeFont) {
<span class="nc" id="L2315">        return 0;</span>
    }

    /**
     * Creates a new instance of a native font
     *
     * @param face  the face of the font, can be one of FACE_SYSTEM,
     *              FACE_PROPORTIONAL, FACE_MONOSPACE.
     * @param style the style of the font.
     *              The value is an OR'ed  combination of STYLE_BOLD, STYLE_ITALIC, and
     *              STYLE_UNDERLINED; or the value is zero (STYLE_PLAIN).
     * @param size  the size of the font, can be one of SIZE_SMALL,
     *              SIZE_MEDIUM, SIZE_LARGE
     * @return a native font object
     */
    public abstract Object createFont(int face, int style, int size);

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     *
     * @param keyCode the key for the event
     */
    protected void keyPressed(final int keyCode) {
<span class="nc" id="L2339">        Display.getInstance().keyPressed(keyCode);</span>
<span class="nc" id="L2340">    }</span>

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     *
     * @param keyCode the key for the event
     */
    protected void keyReleased(final int keyCode) {
<span class="nc" id="L2349">        Display.getInstance().keyReleased(keyCode);</span>
<span class="nc" id="L2350">    }</span>

    /**
     * Checks if last mouse press was a right click.
     *
     * @return True if last mouse press was a right click.
     * @since 7.0
     */
    public boolean isRightMouseButtonDown() {
<span class="nc" id="L2359">        return false;</span>
    }

    /**
     * Checks whether the alt key is currently down.  Only relevant on desktop ports.
     *
     * @return
     */
    public boolean isAltKeyDown() {
<span class="nc" id="L2368">        return false;</span>
    }

    /**
     * Checks whether the shift key is currently down.  Only relevant on desktop ports.
     *
     * @return
     */
    public boolean isShiftKeyDown() {
<span class="nc" id="L2377">        return false;</span>
    }

    /**
     * Checks whether the altgraph key is currently down.  Only relevant on desktop ports.
     *
     * @return
     */
    public boolean isAltGraphKeyDown() {
<span class="nc" id="L2386">        return false;</span>
    }

    /**
     * Checks whether the control key is currently down.  Only relevant on desktop ports.
     *
     * @return
     */
    public boolean isControlKeyDown() {
<span class="nc" id="L2395">        return false;</span>
    }

    /**
     * Checks whether the meta key is currently down.  Only relevant on desktop ports.
     *
     * @return
     */
    public boolean isMetaKeyDown() {
<span class="nc" id="L2404">        return false;</span>
    }

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     *
     * @param x the position of the event
     * @param y the position of the event
     */
    protected void pointerDragged(final int x, final int y) {
<span class="nc" id="L2415">        xPointerEvent[0] = x;</span>
<span class="nc" id="L2416">        yPointerEvent[0] = y;</span>
<span class="nc" id="L2417">        pointerDragged(xPointerEvent, yPointerEvent);</span>
<span class="nc" id="L2418">    }</span>

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     *
     * @param x the position of the event
     * @param y the position of the event
     */
    protected void pointerPressed(final int x, final int y) {
<span class="nc" id="L2428">        xPointerEvent[0] = x;</span>
<span class="nc" id="L2429">        yPointerEvent[0] = y;</span>
<span class="nc" id="L2430">        pointerPressed(xPointerEvent, yPointerEvent);</span>
<span class="nc" id="L2431">    }</span>

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     *
     * @param x the position of the event
     * @param y the position of the event
     */
    protected void pointerReleased(final int x, final int y) {
<span class="nc" id="L2441">        xPointerEvent[0] = x;</span>
<span class="nc" id="L2442">        yPointerEvent[0] = y;</span>
<span class="nc" id="L2443">        pointerReleased(xPointerEvent, yPointerEvent);</span>
<span class="nc" id="L2444">    }</span>

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     *
     * @param x the position of the event
     * @param y the position of the event
     */
    protected void pointerHover(final int[] x, final int[] y) {
<span class="nc" id="L2454">        Display.getInstance().pointerHover(x, y);</span>
<span class="nc" id="L2455">    }</span>

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     *
     * @param x the position of the event
     * @param y the position of the event
     */
    protected void pointerHoverReleased(final int[] x, final int[] y) {
<span class="nc" id="L2465">        Display.getInstance().pointerHoverReleased(x, y);</span>
<span class="nc" id="L2466">    }</span>

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     *
     * @param x the position of the event
     * @param y the position of the event
     */
    protected void pointerHoverReleased(final int x, final int y) {
<span class="nc" id="L2476">        xPointerEvent[0] = x;</span>
<span class="nc" id="L2477">        yPointerEvent[0] = y;</span>
<span class="nc" id="L2478">        pointerHoverReleased(xPointerEvent, yPointerEvent);</span>
<span class="nc" id="L2479">    }</span>

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     *
     * @param x the position of the event
     * @param y the position of the event
     */
    protected void pointerHoverPressed(final int[] x, final int[] y) {
<span class="nc" id="L2489">        Display.getInstance().pointerHoverPressed(x, y);</span>
<span class="nc" id="L2490">    }</span>

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     *
     * @param x the position of the event
     * @param y the position of the event
     */
    protected void pointerHoverPressed(final int x, final int y) {
<span class="nc" id="L2500">        xPointerEvent[0] = x;</span>
<span class="nc" id="L2501">        yPointerEvent[0] = y;</span>
<span class="nc" id="L2502">        pointerHoverPressed(xPointerEvent, yPointerEvent);</span>
<span class="nc" id="L2503">    }</span>

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     *
     * @param x the position of the event
     * @param y the position of the event
     */
    protected void pointerHover(final int x, final int y) {
<span class="nc" id="L2513">        xPointerEvent[0] = x;</span>
<span class="nc" id="L2514">        yPointerEvent[0] = y;</span>
<span class="nc" id="L2515">        pointerHover(xPointerEvent, yPointerEvent);</span>
<span class="nc" id="L2516">    }</span>

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     *
     * @param x the position of the event
     * @param y the position of the event
     */
    protected void pointerDragged(final int[] x, final int[] y) {
<span class="nc" id="L2526">        boolean hasDragStartedXY = false;</span>
<span class="nc bnc" id="L2527" title="All 2 branches missed.">        if (!dragStarted) {</span>
            try {
<span class="nc" id="L2529">                hasDragStartedXY = hasDragStarted(x, y);</span>
<span class="nc" id="L2530">            } catch (Throwable t) {</span>
                // PMD Fix (EmptyCatchBlock): Log the exception to retain diagnostic information while tolerating inconsistent states.
<span class="nc" id="L2532">                Log.e(t);</span>
<span class="nc" id="L2533">            }</span>
        }
<span class="nc bnc" id="L2535" title="All 4 branches missed.">        if (dragStarted || hasDragStartedXY) {</span>
<span class="nc" id="L2536">            dragStarted = true;</span>
<span class="nc" id="L2537">            Display.getInstance().pointerDragged(x, y);</span>
        }
<span class="nc" id="L2539">    }</span>

    /**
     * This method can be overriden by subclasses to indicate whether a drag
     * event has started or whether the device is just sending out &quot;noise&quot;.
     * This method is invoked by pointer dragged to determine whether to propogate
     * the actual pointer drag event to Codename One.
     *
     * @param x the position of the current drag event
     * @param y the position of the current drag event
     * @return true if the drag should propagate into Codename One
     */
    protected boolean hasDragStarted(final int[] x, final int[] y) {
<span class="nc" id="L2552">        return hasDragStarted(x[0], y[0]);</span>
    }

    /**
     * This method can be overriden by subclasses to indicate whether a drag
     * event has started or whether the device is just sending out &quot;noise&quot;.
     * This method is invoked by pointer dragged to determine whether to propagate
     * the actual pointer drag event to Codename One.
     *
     * @param x the position of the current drag event
     * @param y the position of the current drag event
     * @return true if the drag should propagate into Codename One
     */
    protected boolean hasDragStarted(final int x, final int y) {
        // can happen if a user dragged before init, this happens on iOS during splash screen
<span class="nc bnc" id="L2567" title="All 2 branches missed.">        if (getCurrentForm() == null) {</span>
<span class="nc" id="L2568">            return false;</span>
        }
<span class="nc bnc" id="L2570" title="All 2 branches missed.">        if (dragActivationCounter == 0) {</span>
<span class="nc" id="L2571">            dragActivationX = x;</span>
<span class="nc" id="L2572">            dragActivationY = y;</span>
<span class="nc" id="L2573">            dragActivationCounter++;</span>
<span class="nc" id="L2574">            return false;</span>
        }
<span class="nc" id="L2576">        int dragRegion = getCurrentForm().getDragRegionStatus(x, y);</span>

        //send the drag events to the form only after latency of 7 drag events,
        //most touch devices are too sensitive and send too many drag events.
        //7 is just a latency const number that is pretty good for most devices
        //this may be tuned for specific devices.
<span class="nc" id="L2582">        dragActivationCounter++;</span>
<span class="nc" id="L2583">        float startX = getDragStartPercentage();</span>
<span class="nc" id="L2584">        float startY = startX;</span>
<span class="nc bnc" id="L2585" title="All 11 branches missed.">        switch (dragRegion) {</span>
            case Component.DRAG_REGION_NOT_DRAGGABLE:
<span class="nc bnc" id="L2587" title="All 2 branches missed.">                if (dragActivationCounter &gt; getDragAutoActivationThreshold()) {</span>
<span class="nc" id="L2588">                    return true;</span>
                }
<span class="nc" id="L2590">                startX = Math.max(5, startX);</span>
<span class="nc" id="L2591">                startY = startX;</span>
<span class="nc" id="L2592">                break;</span>
            case Component.DRAG_REGION_LIKELY_DRAG_X:
<span class="nc" id="L2594">                startY = Math.max(5, startY);</span>
<span class="nc" id="L2595">                startX = 0.9f;</span>
<span class="nc" id="L2596">                break;</span>
            case Component.DRAG_REGION_LIKELY_DRAG_Y:
<span class="nc" id="L2598">                startX = Math.max(5, startX);</span>
<span class="nc" id="L2599">                startY = 0.9f;</span>
<span class="nc" id="L2600">                break;</span>
            case Component.DRAG_REGION_LIKELY_DRAG_XY:
<span class="nc" id="L2602">                startX = 0.9f;</span>
<span class="nc" id="L2603">                startY = 0.9f;</span>
<span class="nc" id="L2604">                break;</span>
            case Component.DRAG_REGION_IMMEDIATELY_DRAG_X:
<span class="nc" id="L2606">                startX = 0f;</span>
<span class="nc" id="L2607">                startY = Math.max(5, startY);</span>
<span class="nc" id="L2608">                break;</span>

            case Component.DRAG_REGION_IMMEDIATELY_DRAG_Y:
<span class="nc" id="L2611">                startY = 0f;</span>
<span class="nc" id="L2612">                startX = Math.max(5, startX);</span>
<span class="nc" id="L2613">                break;</span>

            case Component.DRAG_REGION_IMMEDIATELY_DRAG_XY:
<span class="nc" id="L2616">                startX = 0f;</span>
<span class="nc" id="L2617">                startY = 0f;</span>
<span class="nc" id="L2618">                break;</span>
            case Component.DRAG_REGION_POSSIBLE_DRAG_X:
<span class="nc" id="L2620">                startY = Math.max(5, startY);</span>
<span class="nc" id="L2621">                startX = Math.min(startY, 2f);</span>
<span class="nc" id="L2622">                break;</span>
            case Component.DRAG_REGION_POSSIBLE_DRAG_Y:
<span class="nc" id="L2624">                startX = Math.max(5, startX);</span>
<span class="nc" id="L2625">                startY = Math.min(startY, 2f);</span>
<span class="nc" id="L2626">                break;</span>
            case Component.DRAG_REGION_POSSIBLE_DRAG_XY:
<span class="nc" id="L2628">                startX = Math.min(startX, 2f);</span>
<span class="nc" id="L2629">                startY = Math.min(startY, 2f);</span>
                break;
        }

        // have we passed the motion threshold on the X axis?
<span class="nc" id="L2634">        if (((float) getDisplayWidth()) / 100.0f * startX &lt;=</span>
<span class="nc bnc" id="L2635" title="All 2 branches missed.">                Math.abs(dragActivationX - x)) {</span>
<span class="nc" id="L2636">            dragActivationCounter = getDragAutoActivationThreshold() + 1;</span>
<span class="nc" id="L2637">            return true;</span>
        }

        // have we passed the motion threshold on the Y axis?
<span class="nc" id="L2641">        if (((float) getDisplayHeight()) / 100.0f * startY &lt;=</span>
<span class="nc bnc" id="L2642" title="All 2 branches missed.">                Math.abs(dragActivationY - y)) {</span>
<span class="nc" id="L2643">            dragActivationCounter = getDragAutoActivationThreshold() + 1;</span>
<span class="nc" id="L2644">            return true;</span>
        }

<span class="nc" id="L2647">        return false;</span>
    }

    /**
     * This method allows us to manipulate the drag started detection logic.
     * If the pointer was dragged for more than this percentage of the display size it
     * is safe to assume that a drag is in progress.
     *
     * @return motion percentage
     */
    public int getDragStartPercentage() {
<span class="nc" id="L2658">        return dragStartPercentage;</span>
    }

    /**
     * This method allows us to manipulate the drag started detection logic.
     * If the pointer was dragged for more than this percentage of the display size it
     * is safe to assume that a drag is in progress.
     *
     * @param dragStartPercentage percentage of the screen required to initiate drag
     */
    public void setDragStartPercentage(int dragStartPercentage) {
<span class="nc" id="L2669">        this.dragStartPercentage = dragStartPercentage;</span>
<span class="nc" id="L2670">    }</span>

    /**
     * This method allows subclasses to manipulate the drag started detection logic.
     * If more than this number of drag events were delivered it is safe to assume a drag has started
     * This number must be bigger than 0!
     *
     * @return number representing a minimum number of motion events to start a drag operation
     */
    protected int getDragAutoActivationThreshold() {
<span class="nc" id="L2680">        return 7;</span>
    }

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     *
     * @param x the position of the event
     * @param y the position of the event
     */
    protected void pointerPressed(final int[] x, final int[] y) {
<span class="nc" id="L2691">        pointerPressedX = x[0];</span>
<span class="nc" id="L2692">        pointerPressedY = y[0];</span>
<span class="nc" id="L2693">        Display.getInstance().pointerPressed(x, y);</span>
<span class="nc" id="L2694">    }</span>

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     *
     * @param x the position of the event
     * @param y the position of the event
     */
    protected void pointerReleased(final int[] x, final int[] y) {
        // this is a special case designed to detect a &quot;flick&quot; event on some Samsung devices
        // that send a pointerPressed/Released with widely differing X/Y values but don't send
        // the pointerDrag events in between
<span class="nc bnc" id="L2707" title="All 6 branches missed.">        if (dragActivationCounter == 0 &amp;&amp; x[0] != pointerPressedX &amp;&amp; y[0] != pointerPressedY) {</span>
<span class="nc" id="L2708">            hasDragStarted(pointerPressedX, pointerPressedY);</span>
<span class="nc bnc" id="L2709" title="All 2 branches missed.">            if (hasDragStarted(x, y)) {</span>
<span class="nc" id="L2710">                pointerDragged(pointerPressedX, pointerPressedY);</span>
<span class="nc" id="L2711">                pointerDragged(x, y);</span>
            }
        }
<span class="nc" id="L2714">        dragStarted = false;</span>
<span class="nc" id="L2715">        dragActivationCounter = 0;</span>
<span class="nc" id="L2716">        Display.getInstance().pointerReleased(x, y);</span>
<span class="nc" id="L2717">    }</span>

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     *
     * @param w the size of the screen
     * @param h the size of the screen
     */
    protected void sizeChanged(int w, int h) {
<span class="nc" id="L2727">        Display.getInstance().sizeChanged(w, h);</span>
<span class="nc" id="L2728">    }</span>

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     */
    protected void hideNotify() {
<span class="nc" id="L2735">        Display.getInstance().hideNotify();</span>
<span class="nc" id="L2736">    }</span>

    /**
     * Subclasses should invoke this method, it delegates the event to the display and into
     * Codename One.
     */
    protected void showNotify() {
<span class="nc" id="L2743">        Display.getInstance().showNotify();</span>
<span class="nc" id="L2744">    }</span>

    private Object findCachedGradient(Hashtable cache, int startColor, int endColor, int x, int y, int width, int height, boolean horizontal, int centerX, int centerY, int size) {
<span class="nc bnc" id="L2747" title="All 2 branches missed.">        if (cache != null) {</span>
<span class="nc" id="L2748">            Enumeration e = cache.keys();</span>
<span class="nc bnc" id="L2749" title="All 2 branches missed.">            while (e.hasMoreElements()) {</span>
<span class="nc" id="L2750">                int[] current = (int[]) e.nextElement();</span>
<span class="nc" id="L2751">                Object currentRef = cache.get(current);</span>
<span class="nc bnc" id="L2752" title="All 2 branches missed.">                if (currentRef == null) {</span>
<span class="nc" id="L2753">                    cache.remove(current);</span>
<span class="nc" id="L2754">                    e = cache.keys();</span>
<span class="nc" id="L2755">                    continue;</span>
                }
<span class="nc" id="L2757">                Object currentImage = extractHardRef(currentRef);</span>
<span class="nc bnc" id="L2758" title="All 2 branches missed.">                if (currentImage == null) {</span>
<span class="nc" id="L2759">                    cache.remove(current);</span>
<span class="nc" id="L2760">                    e = cache.keys();</span>
<span class="nc" id="L2761">                    continue;</span>
                }
<span class="nc bnc" id="L2763" title="All 14 branches missed.">                if (current[0] == startColor &amp;&amp;</span>
                        current[1] == endColor &amp;&amp;
                        current[2] == x &amp;&amp;
                        current[3] == y &amp;&amp;
                        current[5] == centerX &amp;&amp;
                        current[6] == centerY &amp;&amp;
                        current[7] == size &amp;&amp;
<span class="nc bnc" id="L2770" title="All 2 branches missed.">                        getImageWidth(currentImage) == width &amp;&amp;</span>
<span class="nc bnc" id="L2771" title="All 10 branches missed.">                        getImageHeight(currentImage) == height &amp;&amp;</span>
                        ((horizontal &amp;&amp; current[4] == 1) || (!horizontal &amp;&amp; current[4] == 0))) {
                    // PMD Fix (CollapsibleIfStatements): Collapse nested equality checks for cache reuse.
<span class="nc" id="L2774">                    return currentImage;</span>
                }
<span class="nc" id="L2776">            }</span>
        }
<span class="nc" id="L2778">        return null;</span>
    }

    private void storeCachedGradient(Object img, Hashtable cache, int startColor, int endColor, int x, int y, boolean horizontal, int centerX, int centerY, int size) {
        int[] key;
<span class="nc bnc" id="L2783" title="All 2 branches missed.">        if (horizontal) {</span>
<span class="nc" id="L2784">            key = new int[]{startColor, endColor, x, y, 1, centerX, centerY, size};</span>
        } else {
<span class="nc" id="L2786">            key = new int[]{startColor, endColor, x, y, 0, centerX, centerY, size};</span>
        }
<span class="nc" id="L2788">        cache.put(key, createSoftWeakRef(img));</span>
<span class="nc" id="L2789">    }</span>

    /**
     * Draws a radial gradient in the given coordinates with the given colors,
     * doesn't take alpha into consideration when drawing the gradient.
     * Notice that a radial gradient will result in a circular shape, to create
     * a square use fillRect or draw a larger shape and clip to the appropriate size.
     *
     * @param graphics     the graphics context
     * @param startColor   the starting RGB color
     * @param endColor     the ending RGB color
     * @param x            the x coordinate
     * @param y            the y coordinate
     * @param width        the width of the region to be filled
     * @param height       the height of the region to be filled
     * @param relativeX    indicates the relative position of the gradient within the drawing region
     * @param relativeY    indicates the relative position of the gradient within the drawing region
     * @param relativeSize indicates the relative size of the gradient within the drawing region
     */
    public void fillRectRadialGradient(Object graphics, int startColor, int endColor, int x, int y, int width, int height, float relativeX, float relativeY, float relativeSize) {
<span class="nc" id="L2809">        int centerX = (int) (width * (1 - relativeX));</span>
<span class="nc" id="L2810">        int centerY = (int) (height * (1 - relativeY));</span>
<span class="nc" id="L2811">        int size = (int) (Math.min(width, height) * relativeSize);</span>
<span class="nc" id="L2812">        int x2 = (int) (width / 2 - (size * relativeX));</span>
<span class="nc" id="L2813">        int y2 = (int) (height / 2 - (size * relativeY));</span>
<span class="nc" id="L2814">        boolean aa = isAntiAliased(graphics);</span>
<span class="nc" id="L2815">        setAntiAliased(graphics, false);</span>

<span class="nc bnc" id="L2817" title="All 2 branches missed.">        if (cacheRadialGradients()) {</span>
<span class="nc" id="L2818">            Object r = findCachedGradient(radialGradientCache, startColor, endColor, x, y, width, height, true, centerX, centerY, size);</span>
<span class="nc bnc" id="L2819" title="All 2 branches missed.">            if (r != null) {</span>
<span class="nc" id="L2820">                drawImage(graphics, r, x, y);</span>
            } else {
<span class="nc" id="L2822">                r = createMutableImage(width, height, 0xffffffff);</span>
<span class="nc" id="L2823">                Object imageGraphics = getNativeGraphics(r);</span>
<span class="nc" id="L2824">                setColor(imageGraphics, endColor);</span>
<span class="nc" id="L2825">                fillRect(imageGraphics, 0, 0, width, height);</span>
<span class="nc" id="L2826">                fillRadialGradientImpl(imageGraphics, startColor, endColor, x2, y2, size, size, 0, 360);</span>
<span class="nc" id="L2827">                drawImage(graphics, r, x, y);</span>
<span class="nc bnc" id="L2828" title="All 2 branches missed.">                if (radialGradientCache == null) {</span>
<span class="nc" id="L2829">                    radialGradientCache = new Hashtable();</span>
                }
<span class="nc" id="L2831">                storeCachedGradient(r, radialGradientCache, startColor, endColor, x, y, true, centerX, centerY, size);</span>
            }
<span class="nc" id="L2833">        } else {</span>
<span class="nc" id="L2834">            setColor(graphics, endColor);</span>
<span class="nc" id="L2835">            fillRect(graphics, x, y, width, height);</span>

<span class="nc" id="L2837">            fillRadialGradientImpl(graphics, startColor, endColor, x + x2, y + y2, size, size, 0, 360);</span>
        }
<span class="nc bnc" id="L2839" title="All 2 branches missed.">        if (aa) {</span>
<span class="nc" id="L2840">            setAntiAliased(graphics, true);</span>
        }
<span class="nc" id="L2842">    }</span>

    /**
     * Draws a radial gradient in the given coordinates with the given colors,
     * doesn't take alpha into consideration when drawing the gradient.
     * Notice that a radial gradient will result in a circular shape, to create
     * a square use fillRect or draw a larger shape and clip to the appropriate size.
     *
     * @param graphics   the graphics context
     * @param startColor the starting RGB color
     * @param endColor   the ending RGB color
     * @param x          the x coordinate
     * @param y          the y coordinate
     * @param width      the width of the region to be filled
     * @param height     the height of the region to be filled
     */
    public void fillRadialGradient(Object graphics, int startColor, int endColor, int x, int y, int width, int height) {
<span class="nc" id="L2859">        fillRadialGradientImpl(graphics, startColor, endColor, x, y, width, height, 0, 360);</span>
<span class="nc" id="L2860">    }</span>

    /**
     * Draws a radial gradient in the given coordinates with the given colors,
     * doesn't take alpha into consideration when drawing the gradient.
     * Notice that a radial gradient will result in a circular shape, to create
     * a square use fillRect or draw a larger shape and clip to the appropriate size.
     *
     * @param graphics   the graphics context
     * @param startColor the starting RGB color
     * @param endColor   the ending RGB color
     * @param x          the x coordinate
     * @param y          the y coordinate
     * @param width      the width of the region to be filled
     * @param height     the height of the region to be filled
     * @param startAngle the beginning angle.  Zero is at 3 o'clock.  Positive angles are counter-clockwise.
     * @param arcAngle   the angular extent of the arc, relative to the start angle. Positive angles are counter-clockwise.
     */
    public void fillRadialGradient(Object graphics, int startColor, int endColor, int x, int y, int width, int height, int startAngle, int arcAngle) {
<span class="nc" id="L2879">        fillRadialGradientImpl(graphics, startColor, endColor, x, y, width, height, startAngle, arcAngle);</span>
<span class="nc" id="L2880">    }</span>

    private void fillRadialGradientImpl(Object graphics, int startColor, int endColor, int x, int y, int width, int height, int startAngle, int arcAngle) {
<span class="nc" id="L2883">        boolean aa = isAntiAliased(graphics);</span>
<span class="nc" id="L2884">        setAntiAliased(graphics, false);</span>
<span class="nc" id="L2885">        int sourceR = startColor &gt;&gt; 16 &amp; 0xff;</span>
<span class="nc" id="L2886">        int sourceG = startColor &gt;&gt; 8 &amp; 0xff;</span>
<span class="nc" id="L2887">        int sourceB = startColor &amp; 0xff;</span>
<span class="nc" id="L2888">        int destR = endColor &gt;&gt; 16 &amp; 0xff;</span>
<span class="nc" id="L2889">        int destG = endColor &gt;&gt; 8 &amp; 0xff;</span>
<span class="nc" id="L2890">        int destB = endColor &amp; 0xff;</span>
<span class="nc" id="L2891">        int oldColor = getColor(graphics);</span>
<span class="nc" id="L2892">        int originalHeight = height;</span>
<span class="nc" id="L2893">        boolean outermost = true;</span>
<span class="nc bnc" id="L2894" title="All 4 branches missed.">        while (width &gt; 0 &amp;&amp; height &gt; 0) {</span>
<span class="nc bnc" id="L2895" title="All 2 branches missed.">            if (outermost) {</span>
<span class="nc" id="L2896">                setAntiAliased(graphics, true);</span>
            }
<span class="nc" id="L2898">            updateGradientColor(graphics, sourceR, sourceG, sourceB, destR,</span>
                    destG, destB, originalHeight, height);
<span class="nc" id="L2900">            fillArc(graphics, x, y, width, height, startAngle, arcAngle);</span>
<span class="nc" id="L2901">            x++;</span>
<span class="nc" id="L2902">            y++;</span>
<span class="nc" id="L2903">            width -= 2;</span>
<span class="nc" id="L2904">            height -= 2;</span>
<span class="nc bnc" id="L2905" title="All 2 branches missed.">            if (outermost) {</span>
<span class="nc" id="L2906">                outermost = false;</span>
<span class="nc" id="L2907">                setAntiAliased(graphics, false);</span>
            }
        }
<span class="nc" id="L2910">        setColor(graphics, oldColor);</span>
<span class="nc bnc" id="L2911" title="All 2 branches missed.">        if (aa) {</span>
<span class="nc" id="L2912">            setAntiAliased(graphics, true);</span>
        }
<span class="nc" id="L2914">    }</span>

    private void updateGradientColor(Object nativeGraphics, int sourceR, int sourceG, int sourceB, int destR,
                                     int destG, int destB, int distance, int offset) {
        //int a = calculateGraidentChannel(sourceA, destA, distance, offset);
<span class="nc" id="L2919">        int r = calculateGraidentChannel(sourceR, destR, distance, offset);</span>
<span class="nc" id="L2920">        int g = calculateGraidentChannel(sourceG, destG, distance, offset);</span>
<span class="nc" id="L2921">        int b = calculateGraidentChannel(sourceB, destB, distance, offset);</span>
<span class="nc" id="L2922">        int color = /*((a &lt;&lt; 24) &amp; 0xff000000) |*/ ((r &lt;&lt; 16) &amp; 0xff0000) |</span>
                ((g &lt;&lt; 8) &amp; 0xff00) | (b &amp; 0xff);
<span class="nc" id="L2924">        setColor(nativeGraphics, color);</span>
<span class="nc" id="L2925">    }</span>

    /**
     * Converts the color channel value according to the offest within the distance
     */
    private int calculateGraidentChannel(int sourceChannel, int destChannel, int distance, int offset) {
<span class="nc bnc" id="L2931" title="All 2 branches missed.">        if (sourceChannel == destChannel) {</span>
<span class="nc" id="L2932">            return sourceChannel;</span>
        }
<span class="nc" id="L2934">        float ratio = ((float) offset) / ((float) distance);</span>
<span class="nc" id="L2935">        int pos = (int) (Math.abs(sourceChannel - destChannel) * ratio);</span>
<span class="nc bnc" id="L2936" title="All 2 branches missed.">        if (sourceChannel &gt; destChannel) {</span>
<span class="nc" id="L2937">            return sourceChannel - pos;</span>
        } else {
<span class="nc" id="L2939">            return sourceChannel + pos;</span>
        }
    }

    /**
     * Draws a linear gradient in the given coordinates with the given colors,
     * doesn't take alpha into consideration when drawing the gradient
     *
     * @param graphics   the graphics context
     * @param startColor the starting RGB color
     * @param endColor   the ending RGB color
     * @param x          the x coordinate
     * @param y          the y coordinate
     * @param width      the width of the region to be filled
     * @param height     the height of the region to be filled
     * @param horizontal indicating wheter it is a horizontal fill or vertical
     */
    public void fillLinearGradient(Object graphics, int startColor, int endColor, int x, int y, int width, int height, boolean horizontal) {
        // this can happen in the resource editor
<span class="nc bnc" id="L2958" title="All 4 branches missed.">        if (width &lt;= 0 || height &lt;= 0) {</span>
<span class="nc" id="L2959">            return;</span>
        }
<span class="nc" id="L2961">        boolean aa = isAntiAliased(graphics);</span>
<span class="nc" id="L2962">        setAntiAliased(graphics, false);</span>
<span class="nc bnc" id="L2963" title="All 2 branches missed.">        if (cacheLinearGradients()) {</span>
<span class="nc" id="L2964">            Object r = findCachedGradient(linearGradientCache, startColor, endColor, x, y, width, height, horizontal, 0, 0, 0);</span>
<span class="nc bnc" id="L2965" title="All 2 branches missed.">            if (r != null) {</span>
<span class="nc" id="L2966">                drawImage(graphics, r, x, y);</span>
            } else {
<span class="nc" id="L2968">                r = createMutableImage(width, height, 0xffffffff);</span>
<span class="nc" id="L2969">                fillLinearGradientImpl(getNativeGraphics(r), startColor, endColor, 0, 0, width, height, horizontal);</span>
<span class="nc" id="L2970">                drawImage(graphics, r, x, y);</span>
<span class="nc bnc" id="L2971" title="All 2 branches missed.">                if (linearGradientCache == null) {</span>
<span class="nc" id="L2972">                    linearGradientCache = new Hashtable();</span>
                }
<span class="nc" id="L2974">                storeCachedGradient(r, linearGradientCache, startColor, endColor, x, y, horizontal, 0, 0, 0);</span>
            }
<span class="nc" id="L2976">        } else {</span>
<span class="nc" id="L2977">            fillLinearGradientImpl(graphics, startColor, endColor, x, y, width, height, horizontal);</span>
        }
<span class="nc bnc" id="L2979" title="All 2 branches missed.">        if (aa) {</span>
<span class="nc" id="L2980">            setAntiAliased(graphics, true);</span>
        }
<span class="nc" id="L2982">    }</span>

    private void fillLinearGradientImpl(Object graphics, int startColor, int endColor, int x, int y, int width, int height, boolean horizontal) {
<span class="nc" id="L2985">        int sourceR = startColor &gt;&gt; 16 &amp; 0xff;</span>
<span class="nc" id="L2986">        int sourceG = startColor &gt;&gt; 8 &amp; 0xff;</span>
<span class="nc" id="L2987">        int sourceB = startColor &amp; 0xff;</span>
<span class="nc" id="L2988">        int destR = endColor &gt;&gt; 16 &amp; 0xff;</span>
<span class="nc" id="L2989">        int destG = endColor &gt;&gt; 8 &amp; 0xff;</span>
<span class="nc" id="L2990">        int destB = endColor &amp; 0xff;</span>
<span class="nc" id="L2991">        int oldColor = getColor(graphics);</span>
<span class="nc bnc" id="L2992" title="All 2 branches missed.">        if (horizontal) {</span>
<span class="nc bnc" id="L2993" title="All 2 branches missed.">            for (int iter = 0; iter &lt; width; iter++) {</span>
<span class="nc" id="L2994">                updateGradientColor(graphics, sourceR, sourceG, sourceB, destR,</span>
                        destG, destB, width, iter);
<span class="nc" id="L2996">                drawLine(graphics, x + iter, y, x + iter, y + height);</span>
            }
        } else {
<span class="nc bnc" id="L2999" title="All 2 branches missed.">            for (int iter = 0; iter &lt; height; iter++) {</span>
<span class="nc" id="L3000">                updateGradientColor(graphics, sourceR, sourceG, sourceB, destR,</span>
                        destG, destB, height, iter);
<span class="nc" id="L3002">                drawLine(graphics, x, y + iter, x + width, y + iter);</span>
            }
        }
<span class="nc" id="L3005">        setColor(graphics, oldColor);</span>
<span class="nc" id="L3006">    }</span>

    private boolean checkIntersection(Object g, int y0, int x1, int x2, int y1, int y2, int[] intersections, int intersectionsCount) {
<span class="nc bnc" id="L3009" title="All 8 branches missed.">        if (y0 &gt; y1 &amp;&amp; y0 &lt; y2 || y0 &gt; y2 &amp;&amp; y0 &lt; y1) {</span>
<span class="nc bnc" id="L3010" title="All 2 branches missed.">            if (y1 == y2) {</span>
<span class="nc" id="L3011">                drawLine(g, x1, y0, x2, y0);</span>
<span class="nc" id="L3012">                return false;</span>
            }
<span class="nc" id="L3014">            intersections[intersectionsCount] = x1 + ((y0 - y1) * (x2 - x1)) / (y2 - y1);</span>
<span class="nc" id="L3015">            return true;</span>
        }
<span class="nc" id="L3017">        return false;</span>
    }

    private int markIntersectionEdge(Object g, int idx, int[] yPoints, int[] xPoints, int nPoints, int[] intersections, int intersectionsCount) {
<span class="nc" id="L3021">        intersections[intersectionsCount] = xPoints[idx];</span>

<span class="nc bnc" id="L3023" title="All 2 branches missed.">        if ((yPoints[idx] - yPoints[(idx + 1) % nPoints]) * (yPoints[idx] - yPoints[(idx + nPoints - 1) % nPoints]) &gt; 0) {</span>
<span class="nc" id="L3024">            intersections[intersectionsCount + 1] = xPoints[idx];</span>
<span class="nc" id="L3025">            return 2;</span>

        }

        //Check for special case horizontal line
<span class="nc bnc" id="L3030" title="All 2 branches missed.">        if (yPoints[idx] == yPoints[(idx + 1) % nPoints]) {</span>

<span class="nc" id="L3032">            drawLine(g, xPoints[idx], yPoints[idx], xPoints[(idx + 1) % nPoints], yPoints[(idx + 1) % nPoints]);</span>

<span class="nc bnc" id="L3034" title="All 2 branches missed.">            if ((yPoints[(idx + 1) % nPoints] - yPoints[(idx + 2) % nPoints]) * (yPoints[idx] - yPoints[(idx + nPoints - 1) % nPoints]) &gt; 0) {</span>
<span class="nc" id="L3035">                return 1;</span>
            } else {
<span class="nc" id="L3037">                intersections[intersectionsCount + 1] = xPoints[idx];</span>
<span class="nc" id="L3038">                return 2;</span>
            }

        }
<span class="nc" id="L3042">        return 1;</span>
    }

    /**
     * Fills a closed polygon defined by arrays of x and y coordinates.
     * Each pair of (x, y) coordinates defines a point.
     *
     * @param graphics the graphics context
     * @param xPoints  - a an array of x coordinates.
     * @param yPoints  - a an array of y coordinates.
     * @param nPoints  - a the total number of points.
     */
    public void fillPolygon(Object graphics, int[] xPoints, int[] yPoints, int nPoints) {

<span class="nc" id="L3056">        int[] intersections = new int[nPoints];</span>
<span class="nc" id="L3057">        int intersectionsCount = 0;</span>


<span class="nc" id="L3060">        int yMax = yPoints[0];</span>
<span class="nc" id="L3061">        int yMin = yPoints[0];</span>


<span class="nc bnc" id="L3064" title="All 2 branches missed.">        for (int i = 0; i &lt; nPoints; i++) {</span>
<span class="nc" id="L3065">            yMax = Math.max(yMax, yPoints[i]);</span>
<span class="nc" id="L3066">            yMin = Math.min(yMin, yPoints[i]);</span>
        }
        //  Loop through the rows of the image.
<span class="nc bnc" id="L3069" title="All 2 branches missed.">        for (int row = yMin; row &lt;= yMax; row++) {</span>

<span class="nc" id="L3071">            intersectionsCount = 0;</span>

<span class="nc bnc" id="L3073" title="All 2 branches missed.">            for (int i = 1; i &lt; nPoints; i++) {</span>
<span class="nc bnc" id="L3074" title="All 2 branches missed.">                if (checkIntersection(graphics, row, xPoints[i - 1], xPoints[i], yPoints[i - 1], yPoints[i], intersections, intersectionsCount)) {</span>
<span class="nc" id="L3075">                    intersectionsCount++;</span>
                }
            }
<span class="nc bnc" id="L3078" title="All 2 branches missed.">            if (checkIntersection(graphics, row, xPoints[nPoints - 1], xPoints[0], yPoints[nPoints - 1], yPoints[0], intersections, intersectionsCount)) {</span>
<span class="nc" id="L3079">                intersectionsCount++;</span>
            }

<span class="nc bnc" id="L3082" title="All 2 branches missed.">            for (int j = 0; j &lt; nPoints; j++) {</span>
<span class="nc bnc" id="L3083" title="All 2 branches missed.">                if (row == yPoints[j]) {</span>
<span class="nc" id="L3084">                    intersectionsCount += markIntersectionEdge(graphics, j, yPoints, xPoints, nPoints, intersections, intersectionsCount);</span>
                }
            }

<span class="nc" id="L3088">            int swap = 0;</span>
<span class="nc bnc" id="L3089" title="All 2 branches missed.">            for (int i = 0; i &lt; intersectionsCount; i++) {</span>
<span class="nc bnc" id="L3090" title="All 2 branches missed.">                for (int j = i; j &lt; intersectionsCount; j++) {</span>
<span class="nc bnc" id="L3091" title="All 2 branches missed.">                    if (intersections[j] &lt; intersections[i]) {</span>
<span class="nc" id="L3092">                        swap = intersections[i];</span>
<span class="nc" id="L3093">                        intersections[i] = intersections[j];</span>
<span class="nc" id="L3094">                        intersections[j] = swap;</span>
                    }
                }
            }


<span class="nc bnc" id="L3100" title="All 2 branches missed.">            for (int i = 1; i &lt; intersectionsCount; i = i + 2) {</span>
<span class="nc" id="L3101">                drawLine(graphics, intersections[i - 1], row, intersections[i], row);</span>
            }
        }
<span class="nc" id="L3104">    }</span>

    /**
     * Draws a closed polygon defined by arrays of x and y coordinates.
     * Each pair of (x, y) coordinates defines a point.
     *
     * @param graphics the graphics context
     * @param xPoints  - a an array of x coordinates.
     * @param yPoints  - a an array of y coordinates.
     * @param nPoints  - a the total number of points.
     */
    public void drawPolygon(Object graphics, int[] xPoints, int[] yPoints, int nPoints) {
<span class="nc bnc" id="L3116" title="All 2 branches missed.">        for (int i = 1; i &lt; nPoints; i++) {</span>
<span class="nc" id="L3117">            drawLine(graphics, xPoints[i - 1], yPoints[i - 1], xPoints[i], yPoints[i]);</span>
        }
<span class="nc" id="L3119">        drawLine(graphics, xPoints[nPoints - 1], yPoints[nPoints - 1], xPoints[0], yPoints[0]);</span>
<span class="nc" id="L3120">    }</span>

    /**
     * Returns the type of the input device one of:
     * KEYBOARD_TYPE_UNKNOWN, KEYBOARD_TYPE_NUMERIC, KEYBOARD_TYPE_QWERTY,
     * KEYBOARD_TYPE_VIRTUAL, KEYBOARD_TYPE_HALF_QWERTY
     *
     * @return KEYBOARD_TYPE_UNKNOWN
     */
    public int getKeyboardType() {
<span class="nc" id="L3130">        return Display.KEYBOARD_TYPE_UNKNOWN;</span>
    }

    /**
     * Indicates whether the device supports native in place editing in which case
     * lightweight input logic shouldn't be used for input.
     *
     * @return false by default
     */
    public boolean isNativeInputSupported() {
<span class="fc" id="L3140">        return false;</span>
    }

    /**
     * Indicates whether the device should switch to native input immediately on first touch
     *
     * @return false by default
     */
    public boolean isNativeInputImmediate() {
<span class="nc" id="L3149">        return false;</span>
    }

    /**
     * Indicates whether the device supports multi-touch events, this is only
     * relevant when touch events are supported
     *
     * @return false by default
     */
    public boolean isMultiTouch() {
<span class="nc" id="L3159">        return false;</span>
    }

    /**
     * Indicates whether the device has a double layer screen thus allowing two
     * stages to touch events: click and hover. This is true for devices such
     * as the storm but can also be true for a PC with a mouse pointer floating
     * on top.
     * &lt;p&gt;A click touch screen will also send pointer hover events to the underlying
     * software and will only send the standard pointer events on click.
     *
     * @return false by default
     */
    public boolean isClickTouchScreen() {
<span class="nc" id="L3173">        return false;</span>
    }

    /**
     * Returns true if indexed images should be used natively
     *
     * @return true if a native image should be used for indexed images
     */
    public boolean isNativeIndexed() {
<span class="fc" id="L3182">        return false;</span>
    }

    /**
     * Creates a native image representing the indexed image
     *
     * @param image the indexed image
     * @return a native version of the indexed image
     */
    public Object createNativeIndexed(Image image) {
<span class="nc" id="L3192">        return null;</span>
    }

    /**
     * Returns true if the image was opaque
     *
     * @param codenameOneImage the Codename One image
     * @param nativeImage      the image object to test
     * @return true if the image is opaque
     */
    public boolean isOpaque(Image codenameOneImage, Object nativeImage) {
<span class="fc" id="L3203">        int[] rgb = codenameOneImage.getRGBCached();</span>
<span class="fc" id="L3204">        int rlen = rgb.length;</span>
<span class="fc bfc" id="L3205" title="All 2 branches covered.">        for (int iter = 0; iter &lt; rlen; iter++) {</span>
<span class="pc bpc" id="L3206" title="1 of 2 branches missed.">            if ((rgb[iter] &amp; 0xff000000) != 0xff000000) {</span>
<span class="nc" id="L3207">                return false;</span>
            }
        }
<span class="fc" id="L3210">        return true;</span>
    }

    /**
     * Indicates whether the underlying implementation can draw using an affine
     * transform hence methods such as rotate, scale and shear would work
     *
     * @return true if an affine transformation matrix is present
     */
    public boolean isAffineSupported() {
<span class="nc" id="L3220">        return false;</span>
    }

    /**
     * Resets the affine transform to the default value
     *
     * @param nativeGraphics the native graphics object
     */
    public void resetAffine(Object nativeGraphics) {
<span class="nc" id="L3229">        System.out.println(&quot;Affine unsupported&quot;);</span>
<span class="nc" id="L3230">    }</span>

    /**
     * Scales the coordinate system using the affine transform
     *
     * @param nativeGraphics the native graphics object
     * @param x              factor for x
     * @param y              factor for y
     */
    public void scale(Object nativeGraphics, float x, float y) {
<span class="nc" id="L3240">        System.out.println(&quot;Affine unsupported&quot;);</span>
<span class="nc" id="L3241">    }</span>

    /**
     * Rotates the coordinate system around a radian angle using the affine transform
     *
     * @param angle          the rotation angle in radians
     * @param nativeGraphics the native graphics object
     */
    public void rotate(Object nativeGraphics, float angle) {
<span class="nc" id="L3250">        rotate(nativeGraphics, angle, 0, 0);</span>
<span class="nc" id="L3251">    }</span>

    /**
     * Rotates the coordinate system around a radian angle using the affine transform
     *
     * @param angle          the rotation angle in radians
     * @param pivotX         the pivot location
     * @param pivotY         the pivot location
     * @param nativeGraphics the native graphics object
     */
    public void rotate(Object nativeGraphics, float angle, int pivotX, int pivotY) {
<span class="nc" id="L3262">        System.out.println(&quot;Affine unsupported&quot;);</span>
<span class="nc" id="L3263">    }</span>

    /**
     * Shear the graphics coordinate system using the affine transform
     *
     * @param x              factor for x
     * @param y              factor for y
     * @param nativeGraphics the native graphics object
     */
    public void shear(Object nativeGraphics, float x, float y) {
<span class="nc" id="L3273">        System.out.println(&quot;Affine unsupported&quot;);</span>
<span class="nc" id="L3274">    }</span>

    /**
     * Indicates whether the underlying platform supports creating an SVG Image
     *
     * @return true if the method create SVG image would return a valid image object
     * from an SVG Input stream
     */
    public boolean isSVGSupported() {
<span class="nc" id="L3283">        return false;</span>
    }

    /**
     * Creates an SVG Image from the given byte array data and the base URL
     *
     * @param baseURL URL which is used to resolve relative references within the SVG file
     * @param data    the content of the SVG file
     * @return a native image that can be used within the image object
     * @throws IOException if resource lookup fail SVG is unsupported
     */
    public Object createSVGImage(String baseURL, byte[] data) throws IOException {
<span class="nc" id="L3295">        throw new IOException(&quot;SVG is not supported by this implementation&quot;);</span>
    }

    /**
     * Returns a platform specific DOM object that can be manipulated by the user
     * to change the SVG Image
     *
     * @param svgImage the underlying image object
     * @return Platform dependent object, when JSR 226 is supported an SVGSVGElement might
     * be returned.
     */
    public Object getSVGDocument(Object svgImage) {
<span class="nc" id="L3307">        throw new RuntimeException(&quot;SVG is not supported by this implementation&quot;);</span>
    }

    /**
     * Callback to allow images animated by the underlying system to change their state
     * e.g. for SVG or animated gif support. This method returns true if an animation
     * state has changed requiring a repaint.
     *
     * @param nativeImage a native image used within the image object
     * @param lastFrame   the time the last frame of animation was shown
     * @return true if a repaint is required since the image state changed, false otherwise
     */
    public boolean animateImage(Object nativeImage, long lastFrame) {
<span class="nc" id="L3320">        return false;</span>
    }

    /**
     * Returns a list of the platform names ordered by priority, platform names are
     * used to choose a font based on platform. Since a platform might support several
     * layers for choice in narrowing platform font selection
     *
     * @return the platform names ordered according to priority.
     */
    public String[] getFontPlatformNames() {
<span class="nc" id="L3331">        return new String[]{&quot;MIDP&quot;, &quot;MIDP2&quot;};</span>
    }

    /**
     * Creates a true type font with the given name/filename (font name might be different from the file name
     * and is required by some devices e.g. iOS). The font file must reside in the src root of the project in
     * order to be detectable. The file name should contain no slashes or any such value.
     *
     * @param fontName the name of the font
     * @param fileName the file name of the font as it appears in the src directory of the project
     * @return the native font created from the stream
     */
    public Object loadTrueTypeFont(String fontName, String fileName) {
<span class="nc" id="L3344">        return null;</span>
    }

    /**
     * Indicates whether the implementation supports loading a font &quot;natively&quot; to handle one of the common
     * native prefixes
     *
     * @return true if the &quot;native:&quot; prefix is supported by loadTrueTypeFont
     */
    public boolean isNativeFontSchemeSupported() {
<span class="nc" id="L3354">        return false;</span>
    }

    /**
     * Creates a font based on this truetype font with the given pixel, &lt;b&gt;WARNING&lt;/b&gt;! This method
     * will only work in the case of truetype fonts!
     *
     * @param font   the native font instance
     * @param size   the size of the font in pixels
     * @param weight PLAIN, BOLD or ITALIC weight based on the constants in this class
     * @return scaled font instance
     */
    public Object deriveTrueTypeFont(Object font, float size, int weight) {
<span class="nc" id="L3367">        throw new RuntimeException(&quot;Unsupported operation&quot;);</span>
    }

    /**
     * Returns true if the system supports dynamically loading truetype fonts from
     * a file.
     *
     * @return true if the system supports dynamically loading truetype fonts from
     * a file.
     */
    public boolean isTrueTypeSupported() {
<span class="nc" id="L3378">        return false;</span>
    }

    /**
     * Loads a native font based on a lookup for a font name and attributes. Font lookup
     * values can be separated by commas and thus allow fallback if the primary font
     * isn't supported by the platform.
     *
     * @param lookup string describing the font
     * @return the native font object
     */
    public Object loadNativeFont(String lookup) {
<span class="nc" id="L3390">        return null;</span>
    }

    /**
     * Indicates whether loading a font by a string is supported by the platform
     *
     * @return true if the platform supports font lookup
     */
    public boolean isLookupFontSupported() {
<span class="nc" id="L3399">        return false;</span>
    }

    /**
     * Minimizes the current application if minimization is supported by the platform (may fail).
     * Returns false if minimization failed.
     *
     * @return false if minimization failed true if it succeeded or seems to be successful
     */
    public boolean minimizeApplication() {
<span class="nc" id="L3409">        return false;</span>
    }

    /**
     * Restore the minimized application if minimization is supported by the platform
     */
    public void restoreMinimizedApplication() {
<span class="nc" id="L3416">    }</span>

    /**
     * Indicates whether an application is minimized
     *
     * @return true if the application is minimized
     */
    public boolean isMinimized() {
<span class="fc" id="L3424">        return false;</span>
    }

    /**
     * Indicates whether the implementation is interested in caching radial gradients for
     * drawing.
     *
     * @return true to activate radial gradient caching
     */
    protected boolean cacheRadialGradients() {
<span class="nc" id="L3434">        return true;</span>
    }

    /**
     * Indicates whether the implementation is interested in caching linear gradients for
     * drawing.
     *
     * @return true to activate linear gradient caching
     */
    protected boolean cacheLinearGradients() {
<span class="nc" id="L3444">        return true;</span>
    }

    /**
     * Indicates the default status to apply to the 3rd softbutton variable
     *
     * @return true if the 3rd softbutton should be set as true
     * @see com.codename1.ui.Display#isThirdSoftButton()
     * @see com.codename1.ui.Display#setThirdSoftButton()
     */
    public boolean isThirdSoftButton() {
<span class="nc" id="L3455">        return false;</span>
    }

    /**
     * Indicates how many drag points are used to calculate dragging speed
     *
     * @return the size of points to calculate the speed
     */
    public int getDragPathLength() {
<span class="fc" id="L3464">        return 10;</span>
    }

    /**
     * Indicates what drag points are valid for the drag speed calculation.
     * Points that are older then the current time - the path time are ignored
     *
     * @return the relevance time per point
     */
    public int getDragPathTime() {
<span class="nc" id="L3474">        return 200;</span>
    }

    /**
     * This method returns the dragging speed based on the latest dragged
     * events
     *
     * @param points         array of locations
     * @param dragPathTime   the time difference between each point
     * @param dragPathOffset the offset in the arrays
     * @param dragPathLength
     */
    public float getDragSpeed(float[] points, long[] dragPathTime,
                              int dragPathOffset, int dragPathLength) {
<span class="nc" id="L3488">        long now = System.currentTimeMillis();</span>
<span class="nc" id="L3489">        final long tooold = now - getDragPathTime();</span>
<span class="nc" id="L3490">        int offset = dragPathOffset - dragPathLength;</span>
<span class="nc bnc" id="L3491" title="All 2 branches missed.">        if (offset &lt; 0) {</span>
<span class="nc" id="L3492">            offset = getDragPathLength() + offset;</span>
        }
<span class="nc" id="L3494">        long old = 0;</span>
<span class="nc" id="L3495">        float oldPoint = 0;</span>
<span class="nc" id="L3496">        float speed = 0;</span>
        long timediff;
        float diff;
        float velocity;
<span class="nc" id="L3500">        float f = dragPathLength;</span>
<span class="nc bnc" id="L3501" title="All 2 branches missed.">        while (dragPathLength &gt; 0) {</span>
<span class="nc bnc" id="L3502" title="All 2 branches missed.">            if (dragPathTime[offset] &gt; tooold) {</span>
<span class="nc bnc" id="L3503" title="All 2 branches missed.">                if (old == 0) {</span>
<span class="nc" id="L3504">                    old = dragPathTime[offset];</span>
<span class="nc" id="L3505">                    oldPoint = points[offset];</span>
                }
<span class="nc" id="L3507">                timediff = now - old;</span>
<span class="nc" id="L3508">                diff = points[offset] - oldPoint;</span>
<span class="nc bnc" id="L3509" title="All 2 branches missed.">                if (timediff &gt; 0) {</span>
<span class="nc" id="L3510">                    velocity = (diff / timediff) * 1.5f;</span>
<span class="nc" id="L3511">                    speed += velocity;</span>
                }
            }
<span class="nc" id="L3514">            dragPathLength--;</span>
<span class="nc" id="L3515">            offset++;</span>
<span class="nc bnc" id="L3516" title="All 2 branches missed.">            if (offset &gt;= getDragPathLength()) {</span>
<span class="nc" id="L3517">                offset = 0;</span>
            }
        }
<span class="nc" id="L3520">        f = Math.max(1, f);</span>
<span class="nc" id="L3521">        return -speed / f;</span>
    }

    /**
     * Indicates whether Codename One should consider the bidi RTL algorithm
     * when drawing text or navigating with the text field cursor.
     *
     * @return true if the bidi algorithm should be considered
     */
    public boolean isBidiAlgorithm() {
<span class="nc" id="L3531">        return bidi;</span>
    }

    /**
     * Indicates whether Codename One should consider the bidi RTL algorithm
     * when drawing text or navigating with the text field cursor.
     *
     * @param activate set to true to activate the bidi algorithm, false to
     *                 disable it
     */
    public void setBidiAlgorithm(boolean activate) {
<span class="nc" id="L3542">        bidi = activate;</span>
<span class="nc" id="L3543">    }</span>

    /**
     * Converts the given string from logical bidi layout to visual bidi layout so
     * it can be rendered properly on the screen. This method is only necessary
     * for devices/platforms that don't have &quot;built in&quot; bidi support such as
     * Sony Ericsson devices.
     * See &lt;a href=&quot;http://www.w3.org/International/articles/inline-bidi-markup/#visual&quot;&gt;this&lt;/a&gt;
     * for more on visual vs. logical ordering.
     *
     * @param s a &quot;logical&quot; string with RTL characters
     * @return a &quot;visual&quot; renderable string
     */
    public String convertBidiLogicalToVisual(String s) {
<span class="nc bnc" id="L3557" title="All 4 branches missed.">        if (bidi &amp;&amp; s.length() &gt;= 2) {</span>
            // PMD Fix (CollapsibleIfStatements): Merge bidi activation and length checks prior to processing.
<span class="nc" id="L3559">            char[] c = s.toCharArray();</span>
<span class="nc" id="L3560">            swapBidiChars(c, 0, s.length(), -1);</span>
<span class="nc" id="L3561">            return new String(c);</span>
        }
<span class="nc" id="L3563">        return s;</span>
    }

    /**
     * Returns the index of the given char within the source string, the actual
     * index isn't necessarily the same when bidi is involved
     * See &lt;a href=&quot;http://www.w3.org/International/articles/inline-bidi-markup/#visual&quot;&gt;this&lt;/a&gt;
     * for more on visual vs. logical ordering.
     *
     * @param source the string in which we are looking for the position
     * @param index  the &quot;logical&quot; location of the cursor
     * @return the &quot;visual&quot; location of the cursor
     */
    public int getCharLocation(String source, int index) {
<span class="nc bnc" id="L3577" title="All 2 branches missed.">        if (bidi) {</span>
<span class="nc" id="L3578">            return swapBidiChars(source.toCharArray(), 0, source.length(), index);</span>
        }
<span class="nc" id="L3580">        return index;</span>
    }

    private boolean isWhitespace(char c) {
<span class="nc bnc" id="L3584" title="All 10 branches missed.">        return c == ' ' || (c == '\n') || (c == '\t') || (c == 10) || (c == 13);</span>
    }

    /**
     * Returns true if the given character is an RTL character or a space
     * character
     *
     * @param c character to test
     * @return true if bidi is active and this is a
     */
    public boolean isRTLOrWhitespace(char c) {
<span class="nc bnc" id="L3595" title="All 2 branches missed.">        if (bidi) {</span>
<span class="nc bnc" id="L3596" title="All 4 branches missed.">            return isRTL(c) || isWhitespace(c);</span>
        }
<span class="nc" id="L3598">        return false;</span>
    }

    /**
     * Returns true if the given character is an RTL character
     *
     * @param c character to test
     * @return true if the charcter is an RTL character
     */
    public boolean isRTL(char c) {
<span class="nc bnc" id="L3608" title="All 4 branches missed.">        return (c &gt;= RTL_RANGE_BEGIN &amp;&amp; c &lt;= RTL_RANGE_END);</span>
    }

    // PMD Fix (UnnecessaryModifier): Private methods cannot be overridden, so final is redundant.
    private int swapBidiChars(char[] chars, int ixStart, int len, int index) {
<span class="nc" id="L3613">        int destIndex = -1;</span>

<span class="nc" id="L3615">        int ixEnd = ixStart + len;</span>
        int ix0, ix1;

<span class="nc" id="L3618">        ix0 = ix1 = ixStart;</span>

<span class="nc" id="L3620">        boolean doSwap = false;</span>
<span class="nc bnc" id="L3621" title="All 2 branches missed.">        for (int i1 = ixStart; i1 &lt; ixEnd; i1++) {</span>
<span class="nc bnc" id="L3622" title="All 2 branches missed.">            if (isRTL(chars[i1])) {</span>
<span class="nc" id="L3623">                doSwap = true;</span>
<span class="nc" id="L3624">                break;</span>
            }
        }

<span class="nc bnc" id="L3628" title="All 2 branches missed.">        if (doSwap) {</span>
<span class="nc bnc" id="L3629" title="All 2 branches missed.">            while (ix0 &lt; ixEnd) {</span>
<span class="nc bnc" id="L3630" title="All 2 branches missed.">                if ((ix1 = scanSecond(chars, ix0, ixEnd)) &lt; 0) {</span>
<span class="nc" id="L3631">                    break;</span>
                } else {
<span class="nc" id="L3633">                    ix0 = ix1;</span>
<span class="nc" id="L3634">                    ix1 = scanBackFirst(chars, ix0, ixEnd);</span>
                    // swap
<span class="nc bnc" id="L3636" title="All 2 branches missed.">                    for (int iy0 = ix0, iy1 = ix1 - 1; iy0 &lt; iy1; iy0++, iy1--) {</span>
<span class="nc" id="L3637">                        char tmp = chars[iy0];</span>
<span class="nc" id="L3638">                        chars[iy0] = chars[iy1];</span>
<span class="nc" id="L3639">                        chars[iy1] = tmp;</span>

<span class="nc bnc" id="L3641" title="All 2 branches missed.">                        if (index == iy1) {</span>
                            //System.out.println(&quot;IY: Found char: new index=&quot;+iy0);
<span class="nc" id="L3643">                            destIndex = iy0;</span>
<span class="nc" id="L3644">                            index = iy0;</span>
                        }
                    }

<span class="nc" id="L3648">                    ix0 = ix1;</span>
                }
            }
        }

<span class="nc bnc" id="L3653" title="All 2 branches missed.">        if (doSwap) {</span>
            // swap the line
<span class="nc bnc" id="L3655" title="All 2 branches missed.">            for (ix0 = ixStart, ix1 = ixEnd - 1; ix0 &lt;= ix1; ix0++, ix1--) {</span>
<span class="nc" id="L3656">                char ch0 = chars[ix0];</span>
<span class="nc" id="L3657">                char ch1 = chars[ix1];</span>

<span class="nc" id="L3659">                chars[ix0] = ch1;</span>
<span class="nc" id="L3660">                chars[ix1] = ch0;</span>

<span class="nc bnc" id="L3662" title="All 2 branches missed.">                if (index == ix0) {</span>
<span class="nc" id="L3663">                    destIndex = ix1;</span>
<span class="nc bnc" id="L3664" title="All 2 branches missed.">                } else if (index == ix1) {</span>
<span class="nc" id="L3665">                    destIndex = ix0;</span>
                }
            }
        }

<span class="nc" id="L3670">        return destIndex;</span>

    }

    private boolean isRTLBreak(char ch1) {
<span class="nc bnc" id="L3675" title="All 12 branches missed.">        return ch1 == ')' || ch1 == ']' || ch1 == '}' || ch1 == '(' || ch1 == '[' || ch1 == '{';</span>
    }

    private boolean isLTR(char c) {
<span class="nc bnc" id="L3679" title="All 4 branches missed.">        return !isRTL(c) &amp;&amp; !isRTLBreak(c);</span>
    }

    // PMD Fix (UnnecessaryModifier): Private helper does not require the final modifier.
    private int scanSecond(char[] chars, int ixStart, int ixEnd) {
<span class="nc" id="L3684">        int ixFound = -1;</span>
<span class="nc bnc" id="L3685" title="All 4 branches missed.">        for (int ix = ixStart; ixFound &lt; 0 &amp;&amp; ix &lt; ixEnd; ix++) {</span>
<span class="nc bnc" id="L3686" title="All 2 branches missed.">            if (!isRTLOrWhitespace(chars[ix])) {</span>
<span class="nc" id="L3687">                ixFound = ix;</span>
            }
        }
<span class="nc" id="L3690">        return ixFound;</span>
    }

    // PMD Fix (UnnecessaryModifier): Remove redundant final modifier on private helper.
    private int scanBackFirst(char[] chars, int ixStart, int ixEnd) {
<span class="nc" id="L3695">        int ix, ixFound = ixEnd;</span>
<span class="nc bnc" id="L3696" title="All 2 branches missed.">        for (ix = ixStart + 1; ix &lt; ixEnd; ix++) {</span>
<span class="nc bnc" id="L3697" title="All 4 branches missed.">            if (isRTL(chars[ix]) || isRTLBreak(chars[ix])) {</span>
<span class="nc" id="L3698">                ixFound = ix;</span>
<span class="nc" id="L3699">                break;</span>
            }
        }

<span class="nc bnc" id="L3703" title="All 2 branches missed.">        for (ix = ixFound - 1; ix &gt;= ixStart; ix--) {</span>
<span class="nc bnc" id="L3704" title="All 4 branches missed.">            if (isLTR(chars[ix]) &amp;&amp; !isWhitespace(chars[ix])) {</span>
<span class="nc" id="L3705">                ixFound = ix + 1;</span>
<span class="nc" id="L3706">                break;</span>
            }
        }

<span class="nc" id="L3710">        return ixFound;</span>
    }

    /**
     * This method is essentially equivalent to cls.getResourceAsStream(String)
     * however some platforms might define unique ways in which to load resources
     * within the implementation.
     *
     * @param cls      class to load the resource from
     * @param resource relative/absolute URL based on the Java convention
     * @return input stream for the resource or null if not found
     */
    public InputStream getResourceAsStream(Class cls, String resource) {
<span class="nc bnc" id="L3723" title="All 2 branches missed.">        if (cls != null) {</span>
<span class="nc" id="L3724">            return cls.getResourceAsStream(resource);</span>
        }
<span class="nc" id="L3726">        return getClass().getResourceAsStream(resource);</span>
    }

    /**
     * Animations should return true to allow the native image animation to update
     *
     * @param nativeImage underlying native imae
     * @return true if this is an animation
     */
    public boolean isAnimation(Object nativeImage) {
<span class="nc" id="L3736">        return false;</span>
    }

    /**
     * Creates a peer component for the given lightweight component
     *
     * @param nativeComponent a platform specific &quot;native component&quot;
     * @return a Codename One peer component that can be manipulated just like any other
     * Codename One component but would internally encapsulate the given native peer
     */
    public PeerComponent createNativePeer(Object nativeComponent) {
<span class="nc" id="L3747">        throw new IllegalArgumentException(nativeComponent.getClass().getName());</span>
    }

    /**
     * Shows a native Form/Canvas or some other heavyweight native screen
     *
     * @param nativeFullScreenPeer the native screen peer
     */
    public void showNativeScreen(Object nativeFullScreenPeer) {
<span class="nc" id="L3756">    }</span>

    /**
     * Places the following commands on the native menu system
     *
     * @param commands the Codename One commands to use
     */
    public void setNativeCommands(Vector commands) {
<span class="nc" id="L3764">    }</span>

    /**
     * Exits the application...
     */
    public void exitApplication() {
<span class="nc" id="L3770">    }</span>

    /**
     * Exits the application...
     */
    public void exit() {
<span class="nc bnc" id="L3776" title="All 2 branches missed.">        if (onExit != null) {</span>
<span class="nc" id="L3777">            onExit.run();</span>
        }
<span class="nc" id="L3779">        exitApplication();</span>
<span class="nc" id="L3780">    }</span>

    /**
     * Returns the property from the underlying platform deployment or the default
     * value if no deployment values are supported. This is equivalent to the
     * getAppProperty from the jad file.
     * &lt;p&gt;The implementation should be responsible for the following keys to return
     * reasonable valid values for the application:
     * &lt;ol&gt;
     * &lt;li&gt;AppName
     * &lt;li&gt;User-Agent - ideally although not required
     * &lt;li&gt;AppVersion
     * &lt;li&gt;Platform - Similar to microedition.platform
     * &lt;/ol&gt;
     *
     * @param key          the key of the property
     * @param defaultValue a default return value
     * @return the value of the property
     */
    public String getProperty(String key, String defaultValue) {
<span class="nc" id="L3800">        return defaultValue;</span>
    }

    /**
     * Returns true if executing this URL should work, returns false if it will not
     * and null if this is unknown.
     *
     * @param url the url that would be executed
     * @return true if executing this URL should work, returns false if it will not
     * and null if this is unknown
     */
    public Boolean canExecute(String url) {
<span class="nc bnc" id="L3812" title="All 4 branches missed.">        if (url.startsWith(&quot;http:&quot;) || url.startsWith(&quot;https:&quot;)) {</span>
<span class="nc" id="L3813">            return Boolean.TRUE;</span>
        }
<span class="nc" id="L3815">        return null;</span>
    }

    /**
     * Executes the given URL on the native platform
     *
     * @param url the url to execute
     */
    public void execute(String url) {
<span class="nc" id="L3824">    }</span>

    /**
     * Executes the given URL on the native platform, this method is useful if
     * the platform has the ability to send an event to the app when the execution
     * has ended, currently this works only for Android platform to invoke other
     * intents.
     *
     * @param url      the url to execute
     * @param response a callback from the platform when this execution returned
     *                 to the application
     */
    public void execute(String url, ActionListener response) {
<span class="nc" id="L3837">        execute(url);</span>
<span class="nc" id="L3838">    }</span>

    /**
     * Returns one of the density variables appropriate for this device, notice that
     * density doesn't always correspond to resolution and an implementation might
     * decide to change the density based on DPI constraints.
     *
     * @return one of the DENSITY constants of Display
     */
    public int getDeviceDensity() {
<span class="nc" id="L3848">        int d = getActualDisplayHeight() * getDisplayWidth();</span>
<span class="nc bnc" id="L3849" title="All 2 branches missed.">        if (isTablet()) {</span>
            // tablets have lower density and allow fitting more details in the screen despite a high resolution
<span class="nc bnc" id="L3851" title="All 2 branches missed.">            if (d &gt;= 1440 * 720) {</span>
<span class="nc" id="L3852">                return Display.DENSITY_HIGH;</span>
            }
<span class="nc" id="L3854">            return Display.DENSITY_MEDIUM;</span>
        }
<span class="nc bnc" id="L3856" title="All 2 branches missed.">        if (d &lt;= 176 * 220) {</span>
<span class="nc" id="L3857">            return Display.DENSITY_VERY_LOW;</span>
        }
<span class="nc bnc" id="L3859" title="All 2 branches missed.">        if (d &lt;= 240 * 320) {</span>
<span class="nc" id="L3860">            return Display.DENSITY_LOW;</span>
        }
<span class="nc bnc" id="L3862" title="All 2 branches missed.">        if (d &lt;= 360 * 480) {</span>
<span class="nc" id="L3863">            return Display.DENSITY_MEDIUM;</span>
        }
<span class="nc bnc" id="L3865" title="All 2 branches missed.">        if (d &lt;= 480 * 854) {</span>
<span class="nc" id="L3866">            return Display.DENSITY_HIGH;</span>
        }
<span class="nc bnc" id="L3868" title="All 2 branches missed.">        if (d &lt;= 1440 * 720) {</span>
<span class="nc" id="L3869">            return Display.DENSITY_VERY_HIGH;</span>
        }
<span class="nc" id="L3871">        return Display.DENSITY_HD;</span>
    }

    /**
     * This method returns a rectangle defining the &quot;safe&quot; area of the display, which excludes
     * areas on the screen that are covered by notches, task bars, rounded corners, etc.
     *
     * &lt;p&gt;This feature was primarily added to deal with the task bar on the iPhone X, which
     * is displayed on the screen near the bottom edge, and can interfere with components
     * that are laid out at the bottom of the screen.&lt;/p&gt;
     *
     * &lt;p&gt;Most platforms will simply return a Rectangle with bounds (0, 0, displayWidth, displayHeight).  iPhone X
     * will return a rectangle that excludes the notch, and task bar regions.&lt;/p&gt;
     *
     * @param rect Out parameter where safe bounds are set.
     * @return The same rectangle that was passed as a parameter.
     * @see Form#getSafeArea()
     * @since 7.0
     */
    public Rectangle getDisplaySafeArea(Rectangle rect) {
<span class="nc bnc" id="L3891" title="All 2 branches missed.">        if (rect == null) {</span>
<span class="nc" id="L3892">            rect = new Rectangle();</span>
        }
<span class="nc" id="L3894">        rect.setBounds(0, 0, getDisplayWidth(), getDisplayHeight());</span>
<span class="nc" id="L3895">        return rect;</span>
    }

    /**
     * Plays a builtin device sound matching the given identifier, implementations
     * and themes can offer additional identifiers to the ones that are already built
     * in.
     *
     * @param soundIdentifier the sound identifier which can match one of the
     *                        common constants in this class or be a user/implementation defined sound
     */
    public void playBuiltinSound(String soundIdentifier) {
<span class="fc" id="L3907">        playUserSound(soundIdentifier);</span>
<span class="fc" id="L3908">    }</span>

    /**
     * Plays a sound defined by the user
     *
     * @param soundIdentifier the sound identifier which can match one of the
     *                        common constants in this class or be a user/implementation defined sound
     * @return true if a user sound exists and was sent to playback
     */
    protected boolean playUserSound(String soundIdentifier) {
<span class="fc" id="L3918">        Object sound = builtinSounds.get(soundIdentifier);</span>
<span class="pc bpc" id="L3919" title="1 of 2 branches missed.">        return sound != null;</span>
        //playAudio(sound);
    }

    /**
     * This method allows implementations to store sound objects natively e.g.
     * in files, byte arrays whatever
     *
     * @param data native data object
     */
    protected void playNativeBuiltinSound(Object data) {
<span class="nc" id="L3930">    }</span>

    /**
     * Converts a sound object to a form which will be easy for the implementation
     * to play later on. E.g. a byte array or a file/file name and return an object
     * that will allow playNativeBuiltinSound() to use
     *
     * @param i stream containing a sound file
     * @return native playback object
     * @throws java.io.IOException thrown by the stream
     */
    protected Object convertBuiltinSound(InputStream i) throws IOException {
<span class="nc" id="L3942">        ByteArrayOutputStream b = new ByteArrayOutputStream();</span>
<span class="nc" id="L3943">        byte[] buffer = new byte[4096];</span>
<span class="nc" id="L3944">        int size = i.read(buffer);</span>
<span class="nc bnc" id="L3945" title="All 2 branches missed.">        while (size &gt; -1) {</span>
<span class="nc" id="L3946">            b.write(buffer, 0, size);</span>
<span class="nc" id="L3947">            size = i.read(buffer);</span>
        }
<span class="nc" id="L3949">        b.close();</span>
<span class="nc" id="L3950">        i.close();</span>
<span class="nc" id="L3951">        return b.toByteArray();</span>
    }

    /**
     * Installs a replacement sound as the builtin sound responsible for the given
     * sound identifier (this will override the system sound if such a sound exists).
     *
     * @param soundIdentifier the sound string passed to playBuiltinSound
     * @param data            an input stream containing platform specific audio file, its usually safe
     *                        to assume that wav/mp3 would be supported.
     * @throws IOException if the stream throws an exception
     */
    public void installBuiltinSound(String soundIdentifier, InputStream data) throws IOException {
<span class="nc" id="L3964">        builtinSounds.put(soundIdentifier, convertBuiltinSound(data));</span>
<span class="nc" id="L3965">    }</span>

    /**
     * Indicates whether a user installed or system sound is available
     *
     * @param soundIdentifier the sound string passed to playBuiltinSound
     * @return true if a sound of this given type is avilable
     */
    public boolean isBuiltinSoundAvailable(String soundIdentifier) {
<span class="nc" id="L3974">        return builtinSounds.containsKey(soundIdentifier);</span>
    }

    /**
     * Allows muting/unmuting the builtin sounds easily
     *
     * @return true if the sound is *not* muted
     */
    public boolean isBuiltinSoundsEnabled() {
<span class="fc" id="L3983">        return builtinSoundEnabled;</span>
    }

    /**
     * Allows muting/unmuting the builtin sounds easily
     *
     * @param enabled indicates whether the sound is muted
     */
    public void setBuiltinSoundsEnabled(boolean enabled) {
<span class="fc" id="L3992">        builtinSoundEnabled = enabled;</span>
<span class="fc" id="L3993">    }</span>

    /**
     * Plays the sound in the given URI which is partially platform specific.
     *
     * @param uri          the platform specific location for the sound
     * @param onCompletion invoked when the audio file finishes playing, may be null
     * @return a handle that can be used to control the playback of the audio
     * @throws java.io.IOException if the URI access fails
     */
    public Media createMedia(String uri, boolean isVideo, Runnable onCompletion) throws IOException {
<span class="nc" id="L4004">        return null;</span>
    }

    /**
     * Creates media asynchronously.
     *
     * @param uri          the platform specific location for the sound
     * @param onCompletion invoked when the audio file finishes playing, may be null
     * @return a handle that can be used to control the playback of the audio
     * @see #createMedia(java.lang.String, boolean, java.lang.Runnable)
     */
    public AsyncResource&lt;Media&gt; createMediaAsync(final String uri, final boolean video, final Runnable onCompletion) {
<span class="nc" id="L4016">        final AsyncResource&lt;Media&gt; out = new AsyncResource&lt;Media&gt;();</span>
<span class="nc" id="L4017">        CN.scheduleBackgroundTask(new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="nc" id="L4021">                    out.complete(createMedia(uri, video, onCompletion));</span>
<span class="nc" id="L4022">                } catch (IOException ex) {</span>
<span class="nc" id="L4023">                    out.error(ex);</span>
<span class="nc" id="L4024">                }</span>
<span class="nc" id="L4025">            }</span>
        });
<span class="nc" id="L4027">        return out;</span>
    }

    /**
     * Adds a callback to a Media element that will be called when the media finishes playing.
     *
     * @param media        The media to add the callback to.
     * @param onCompletion The callback that will run on the EDT when the playback completes.
     * @see #removeCompletionHandler(com.codename1.media.Media, java.lang.Runnable)
     * @see Display#addCompletionHandler(com.codename1.media.Media, java.lang.Runnable)
     */
    public void addCompletionHandler(Media media, Runnable onCompletion) {
<span class="fc" id="L4039">    }</span>

    /**
     * Removes onComplete callback from Media element.
     *
     * @param media        The media element.
     * @param onCompletion The callback.
     * @see #addCompletionHandler(com.codename1.media.Media, java.lang.Runnable)
     * @see Display#removeCompletionHandler(com.codename1.media.Media, java.lang.Runnable)
     */
    public void removeCompletionHandler(Media media, Runnable onCompletion) {

<span class="fc" id="L4051">    }</span>

    /**
     * Plays the sound in the given stream
     *
     * @param stream       the stream containing the media data
     * @param mimeType     the type of the data in the stream
     * @param onCompletion invoked when the audio file finishes playing, may be null
     * @return a handle that can be used to control the playback of the audio
     * @throws java.io.IOException if the URI access fails
     * @see #createMediaAsync(java.io.InputStream, java.lang.String, java.lang.Runnable)
     */
    public Media createMedia(InputStream stream, String mimeType, Runnable onCompletion) throws IOException {
<span class="nc" id="L4064">        return null;</span>
    }

    /**
     * Creates media asynchronously.
     *
     * @param stream       the stream containing the media data
     * @param mimeType     the type of the data in the stream
     * @param onCompletion invoked when the audio file finishes playing, may be null
     * @return a handle that can be used to control the playback of the audio
     * @see #createMedia(java.io.InputStream, java.lang.String, java.lang.Runnable)
     * @since 7.0
     */
    public AsyncResource&lt;Media&gt; createMediaAsync(final InputStream stream, final String mimeType, final Runnable onCompletion) {
<span class="nc" id="L4078">        final AsyncResource&lt;Media&gt; out = new AsyncResource&lt;Media&gt;();</span>
<span class="nc" id="L4079">        CN.scheduleBackgroundTask(new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="nc" id="L4083">                    out.complete(createMedia(stream, mimeType, onCompletion));</span>
<span class="nc" id="L4084">                } catch (Throwable t) {</span>
<span class="nc" id="L4085">                    out.error(t);</span>
<span class="nc" id="L4086">                }</span>
<span class="nc" id="L4087">            }</span>

        });
<span class="nc" id="L4090">        return out;</span>
    }

    /**
     * Creates an audio media that can be played in the background.
     *
     * @param uri the uri of the media can start with jar://, file://, http://
     *            (can also use rtsp:// if supported on the platform)
     * @return Media a Media Object that can be used to control the playback
     * of the media
     * @throws IOException if creation of media from the given URI has failed
     */
    public Media createBackgroundMedia(String uri) throws IOException {
<span class="nc bnc" id="L4103" title="All 2 branches missed.">        if (uri.startsWith(&quot;jar://&quot;)) {</span>
<span class="nc" id="L4104">            uri = uri.substring(6);</span>
<span class="nc bnc" id="L4105" title="All 2 branches missed.">            if (!uri.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L4106">                uri = &quot;/&quot; + uri;</span>
            }
<span class="nc" id="L4108">            InputStream is = getResourceAsStream(this.getClass(), uri);</span>
<span class="nc" id="L4109">            String mime = &quot;&quot;;</span>
<span class="nc bnc" id="L4110" title="All 2 branches missed.">            if (uri.endsWith(&quot;.mp3&quot;)) {</span>
<span class="nc" id="L4111">                mime = &quot;audio/mp3&quot;;</span>
<span class="nc bnc" id="L4112" title="All 2 branches missed.">            } else if (uri.endsWith(&quot;.wav&quot;)) {</span>
<span class="nc" id="L4113">                mime = &quot;audio/x-wav&quot;;</span>
<span class="nc bnc" id="L4114" title="All 2 branches missed.">            } else if (uri.endsWith(&quot;.amr&quot;)) {</span>
<span class="nc" id="L4115">                mime = &quot;audio/amr&quot;;</span>
<span class="nc bnc" id="L4116" title="All 2 branches missed.">            } else if (uri.endsWith(&quot;.3gp&quot;)) {</span>
<span class="nc" id="L4117">                mime = &quot;audio/3gpp&quot;;</span>
            }

<span class="nc" id="L4120">            return createMedia(is, mime, null);</span>
        }
<span class="nc" id="L4122">        return createMedia(uri, false, null);</span>
    }

    /**
     * Creates an audio media that can be played in the background.
     * &lt;p&gt;
     * This is run asynchronously so that this call does not block.
     *
     * @param uri the uri of the media can start with jar://, file://, http://
     *            (can also use rtsp:// if supported on the platform)
     * @return Media a Media Object that can be used to control the playback
     * of the media
     * @throws IOException if creation of media from the given URI has failed
     */
    public AsyncResource&lt;Media&gt; createBackgroundMediaAsync(final String uri) {

<span class="nc bnc" id="L4138" title="All 2 branches missed.">        if (uri.startsWith(&quot;jar://&quot;)) {</span>
<span class="nc" id="L4139">            final AsyncResource&lt;Media&gt; out = new AsyncResource&lt;Media&gt;();</span>

<span class="nc" id="L4141">            CN.scheduleBackgroundTask(new Runnable() {</span>
                @Override
                public void run() {
                    try {
<span class="nc" id="L4145">                        out.complete(createBackgroundMedia(uri));</span>
<span class="nc" id="L4146">                    } catch (IOException ex) {</span>
<span class="nc" id="L4147">                        out.error(ex);</span>
<span class="nc" id="L4148">                    }</span>
<span class="nc" id="L4149">                }</span>

            });
<span class="nc" id="L4152">            return out;</span>
        } else {
<span class="nc" id="L4154">            return createMediaAsync(uri, false, null);</span>
        }
    }

    /**
     * Creates a soft/weak reference to an object that allows it to be collected
     * yet caches it. This method is in the porting layer since CLDC only includes
     * weak references while some platforms include nothing at all and some include
     * the superior soft references.
     *
     * @param o object to cache
     * @return a caching object or null  if caching isn't supported
     */
    public Object createSoftWeakRef(Object o) {
<span class="fc" id="L4168">        return new WeakReference(o);</span>
    }

    /**
     * Extracts the hard reference from the soft/weak reference given
     *
     * @param o the reference returned by createSoftWeakRef
     * @return the original object submitted or null
     */
    public Object extractHardRef(Object o) {
<span class="fc" id="L4178">        WeakReference w = (WeakReference) o;</span>
<span class="fc bfc" id="L4179" title="All 2 branches covered.">        if (w != null) {</span>
<span class="fc" id="L4180">            return w.get();</span>
        }
<span class="fc" id="L4182">        return null;</span>
    }

    /**
     * This method notifies the implementation about the chosen commands
     * behavior
     *
     * @param commandBehavior see Display.COMMAND_BEHAVIOR...
     */
    public void notifyCommandBehavior(int commandBehavior) {
<span class="fc" id="L4192">    }</span>

    /**
     * Indicates if the implemenetation has a native underlying theme
     *
     * @return true if the implementation has a native theme available
     */
    public boolean hasNativeTheme() {
<span class="nc" id="L4200">        return false;</span>
    }

    /**
     * Installs the native theme, this is only applicable if hasNativeTheme() returned true. Notice that this method
     * might replace the DefaultLookAndFeel instance and the default transitions.
     */
    public void installNativeTheme() {
<span class="nc" id="L4208">        throw new RuntimeException();</span>
    }

    /**
     * Performs a clipboard copy operation, if the native clipboard is supported by the implementation it would be used
     *
     * @param obj object to copy, while this can be any arbitrary object it is recommended that only Strings or Codename One
     *            image objects be used to copy
     */
    public void copyToClipboard(Object obj) {
<span class="nc" id="L4218">        lightweightClipboard = obj;</span>
<span class="nc" id="L4219">    }</span>

    /**
     * Returns the current content of the clipboard
     *
     * @return can be any object or null see copyToClipboard
     */
    public Object getPasteDataFromClipboard() {
<span class="nc" id="L4227">        return lightweightClipboard;</span>
    }

    /**
     * Returns true if the device is currently in portrait mode
     *
     * @return true if the device is in portrait mode
     */
    public boolean isPortrait() {
<span class="nc bnc" id="L4236" title="All 2 branches missed.">        return getDisplayWidth() &lt; getActualDisplayHeight();</span>
    }

    /**
     * Returns true if the device allows forcing the orientation via code, feature phones do not allow this
     * although some include a jad property allowing for this feature
     *
     * @return true if lockOrientation  would work
     */
    public boolean canForceOrientation() {
<span class="nc" id="L4246">        return false;</span>
    }

    /**
     * On devices that return true for canForceOrientation() this method can lock the device orientation
     * either to portrait or landscape mode
     *
     * @param portrait true to lock to portrait mode, false to lock to landscape mode
     */
    public void lockOrientation(boolean portrait) {
<span class="nc" id="L4256">    }</span>

    /**
     * This is the reverse method for lock orientation allowing orientation lock to be disabled
     */
    public void unlockOrientation() {
<span class="nc" id="L4262">    }</span>

    /**
     * An implementation can return true if it supports embedding a native browser widget
     *
     * @return true if the implementation supports embedding a native browser widget
     */
    public boolean isNativeBrowserComponentSupported() {
<span class="nc" id="L4270">        return false;</span>
    }

    /**
     * Some platforms require that you enable pinch to zoom explicitly. This method has no
     * effect if pinch to zoom isn't supported by the platform
     *
     * @param browserPeer browser instance
     * @param e           true to enable pinch to zoom, false to disable it
     */
    public void setPinchToZoomEnabled(PeerComponent browserPeer, boolean e) {
<span class="nc" id="L4281">    }</span>

    /**
     * Allows disabling the browsers native scrolling on devices that support it
     *
     * @param browserPeer browser instance
     * @param e           true to enables scrolling and false disables it
     */
    public void setNativeBrowserScrollingEnabled(PeerComponent browserPeer, boolean e) {
<span class="nc" id="L4290">    }</span>

    /**
     * If the implementation supports the creation of a browser component it should be returned in this
     * method
     *
     * @param browserComponent instance of the browser component thru which events should be fired
     * @return an instance of the native browser peer or null
     */
    public PeerComponent createBrowserComponent(Object browserComponent) {
<span class="nc" id="L4300">        return null;</span>
    }

    /**
     * Posts a message to the window in a BrowserComponent.  This is intended to be an abstraction of the Javascript postMessage() API.
     *
     * &lt;p&gt;This is only overridden by the Javascript port to provide proper CORS handling.  Other ports use the implementation
     * in BrowserComponent.&lt;/p&gt;
     *
     * &lt;p&gt;Web pages wishing to receive messages via this mechanism should register a &quot;message&quot; event listener.  See
     * &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage&quot;&gt;Javascript postMessage() docs&lt;/a&gt;
     * for more details about this.&lt;/p&gt;
     *
     * @param browserComponent The browser component peer.
     * @param message          The message to send
     * @param targetOrigin     The target origin for the message.
     * @return True if the implementation handled the message.  False to let BrowserComponent handle it in its default way.
     * @see BrowserComponent#postMessage(java.lang.String, java.lang.String)
     * @see #installMessageListener(java.lang.Object)
     * @see #uninstallMessageListener(java.lang.Object)
     * @since 7.0
     */
    public boolean postMessage(Object browserComponent, String message, String targetOrigin) {
<span class="fc" id="L4323">        return false;</span>
    }

    /**
     * Installs a message listener to allow webpages inside a browser component to send
     * messages to CN1 cross-domain.
     * &lt;p&gt;This will be overridden by the Javascript port only to handle CORS.  Other ports
     * use the default implementation in {@link BrowserComponent}.
     *
     * @param browserComponent The browser component peer.
     * @return True if a message listener was installed.  False otherwise.
     * @see #postMessage(java.lang.Object, java.lang.String, java.lang.String)
     * @see BrowserComponent#onMessage
     * @see BrowserComponent#postMessage(java.lang.String, java.lang.String)
     */
    public boolean installMessageListener(Object browserComponent) {
<span class="fc" id="L4339">        return false;</span>
    }

    /**
     * Uninstalls a message listener to allow webpages inside a browser component to send
     * messages to CN1 cross-domain.
     * &lt;p&gt;This will be overridden by the Javascript port only to handle CORS.  Other ports
     * use the default implementation in {@link BrowserComponent}.
     *
     * @param browserComponent The browser component peer.
     * @return True if a message listener was installed.  False otherwise.
     * @see #postMessage(java.lang.Object, java.lang.String, java.lang.String)
     * @see BrowserComponent#onMessage
     * @see BrowserComponent#postMessage(java.lang.String, java.lang.String)
     */
    public boolean uninstallMessageListener(Object browserComponent) {
<span class="nc" id="L4355">        return false;</span>
    }

    /**
     * &lt;p&gt;Creates a native overlay for the given component. A native overlay is a native component
     * that is always present over the given component.  It can be used to help processing user
     * events in a more native way.  In the Javascript port, native overlays are used on TextFields, for example,
     * so that users can tap on the text field and activate the keyboard.  This was necessary because
     * iOS doesn't allow us to programmatically activate the keyboard.  Without a native overlay,
     * the user would first have to tap the lightweight keyboard - upon which we create a native text
     * field, and then the user would have to tap again to activate the keyboard.  Using native
     * overlays in that case yields better UX.&lt;/p&gt;
     *
     * &lt;p&gt;When using native overlays, you will need to implement {@link #createNativeOverlay(com.codename1.ui.Component) },
     * {@link #hideNativeOverlay(com.codename1.ui.Component, java.lang.Object) }, and {@link #updateNativeOverlay(com.codename1.ui.Component, java.lang.Object) }.
     * {@link #createNativeOverlay(com.codename1.ui.Component) } is called in {@link Component#initComponent() } (i.e. when the component is added to the form).
     * This is where you would create the native view and add it to the native view hierarchy above the CN1 canvas.
     * {@link #updateNativeOverlay(com.codename1.ui.Component, java.lang.Object) } is called in {@link Component#laidOut() } (i.e. when the component is resized/positioned).
     * This is where you can reposition the native view or change its properties to be appropriate for the &quot;occasion&quot;. {@link #hideNativeOverlay(com.codename1.ui.Component, java.lang.Object) }
     * is called in {@link Component#deinitialize() } (i.e. when the component is removed from the form).  You should destroy the native view and remove it from the native view hierarchy here.
     *
     * @param cmp The component to create the overlay for.
     * @return A native object.  The object type/format is decided by the implementation.
     * @see #hideNativeOverlay(com.codename1.ui.Component, java.lang.Object)
     * @see #updateNativeOverlay(com.codename1.ui.Component, java.lang.Object)
     * @see Component#showNativeOverlay()
     */
    public Object createNativeOverlay(Component cmp) {
<span class="fc" id="L4383">        return null;</span>
    }

    /**
     * Hides the native overlay for a component.
     *
     * @param cmp           The component
     * @param nativeOverlay The native overlay.
     * @see #createNativeOverlay(com.codename1.ui.Component)
     * @see #updateNativeOverlay(com.codename1.ui.Component, java.lang.Object)
     * @see Component#hideNativeOverlay()
     */
    public void hideNativeOverlay(Component cmp, Object nativeOverlay) {

<span class="nc" id="L4397">    }</span>

    /**
     * Updates the native overlay after the component has been repositioned.
     *
     * @param cmp           The component
     * @param nativeOverlay The native overlay
     * @see #createNativeOverlay(com.codename1.ui.Component)
     * @see #hideNativeOverlay(com.codename1.ui.Component, java.lang.Object)
     * @see Component#updateNativeOverlay()
     */
    public void updateNativeOverlay(Component cmp, Object nativeOverlay) {

<span class="nc" id="L4410">    }</span>

    /**
     * This method allows customizing the properties of a web view in various ways including platform specific settings.
     * When a property isn't supported by a specific platform it is just ignored.
     *
     * @param browserPeer browser instance
     * @param key         see the documentation with the Codename One Implementation for further details
     * @param value       see the documentation with the Codename One Implementation for further details
     */
    public void setBrowserProperty(PeerComponent browserPeer, String key, Object value) {
<span class="nc" id="L4421">    }</span>

    /**
     * The page title
     *
     * @param browserPeer browser instance
     * @return the title
     */
    public String getBrowserTitle(PeerComponent browserPeer) {
<span class="nc" id="L4430">        return null;</span>
    }

    /**
     * The page URL
     *
     * @param browserPeer browser instance
     * @return the URL
     */
    public String getBrowserURL(PeerComponent browserPeer) {
<span class="nc" id="L4440">        return null;</span>
    }

    /**
     * Captures a screenshot from a browser component asynchronously.
     *
     * @param browserPeer The browser instance
     * @return AsyncResource resolving to an image of the snapshot.  If this returns null,
     * then {@link BrowserComponent#captureScreenshot() } will just use {@link Component#toImage() }
     * for screenshots.
     * @since 7.0
     */
    public AsyncResource&lt;Image&gt; captureBrowserScreenshot(PeerComponent browserPeer) {
<span class="nc" id="L4453">        return null;</span>
    }

    /**
     * Sets a relative URL from the html hierarchy
     *
     * @param browserPeer the peer component
     * @param url         the url relative to the HTML directory
     */
    public void setBrowserPageInHierarchy(PeerComponent browserPeer, String url) throws IOException {
<span class="nc" id="L4463">        installTar();</span>

<span class="nc" id="L4465">        FileSystemStorage fs = FileSystemStorage.getInstance();</span>
<span class="nc" id="L4466">        String tardir = fs.getAppHomePath() + &quot;cn1html&quot;;</span>
<span class="nc bnc" id="L4467" title="All 2 branches missed.">        if (tardir.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L4468">            tardir = &quot;file://&quot; + tardir;</span>
        }
<span class="nc bnc" id="L4470" title="All 2 branches missed.">        if (url.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L4471">            setBrowserURL(browserPeer, tardir + url);</span>
        } else {
<span class="nc" id="L4473">            setBrowserURL(browserPeer, tardir + &quot;/&quot; + url);</span>
        }
<span class="nc" id="L4475">    }</span>

    /**
     * Sets the page URL, jar: URL's must be supported by the implementation
     *
     * @param browserPeer browser instance
     * @param url         the URL
     * @param headers     custom headers for the request URL
     */
    public void setBrowserURL(PeerComponent browserPeer, String url, Map&lt;String, String&gt; headers) {
<span class="nc" id="L4485">        throw new RuntimeException();</span>
    }

    /**
     * Returns true if setBrowserURL with custom headers is supported
     *
     * @return returns false by default
     */
    public boolean isURLWithCustomHeadersSupported() {
<span class="nc" id="L4494">        return false;</span>
    }

    /**
     * Sets the page URL, jar: URL's must be supported by the implementation
     *
     * @param browserPeer browser instance
     * @param url         the URL
     */
    public void setBrowserURL(PeerComponent browserPeer, String url) {
        // load from jar:// URL's
        try {
<span class="nc" id="L4506">            InputStream i = Display.getInstance().getResourceAsStream(getClass(), url.substring(6));</span>
<span class="nc bnc" id="L4507" title="All 2 branches missed.">            if (i == null) {</span>
<span class="nc" id="L4508">                System.out.println(&quot;Local resource not found: &quot; + url);</span>
<span class="nc" id="L4509">                return;</span>
            }
<span class="nc" id="L4511">            byte[] buffer = new byte[4096];</span>
<span class="nc" id="L4512">            ByteArrayOutputStream bo = new ByteArrayOutputStream();</span>
<span class="nc" id="L4513">            int size = i.read(buffer);</span>
<span class="nc bnc" id="L4514" title="All 2 branches missed.">            while (size &gt; -1) {</span>
<span class="nc" id="L4515">                bo.write(buffer, 0, size);</span>
<span class="nc" id="L4516">                size = i.read(buffer);</span>
            }
<span class="nc" id="L4518">            i.close();</span>
<span class="nc" id="L4519">            bo.close();</span>
<span class="nc" id="L4520">            String htmlText = new String(bo.toByteArray(), &quot;UTF-8&quot;);</span>
<span class="nc" id="L4521">            String baseUrl = url.substring(0, url.lastIndexOf('/'));</span>
<span class="nc" id="L4522">            setBrowserPage(browserPeer, htmlText, baseUrl);</span>
<span class="nc" id="L4523">        } catch (IOException ex) {</span>
<span class="nc" id="L4524">            Log.e(ex);</span>
<span class="nc" id="L4525">        }</span>
<span class="nc" id="L4526">    }</span>

    /**
     * Reload the current page
     *
     * @param browserPeer browser instance
     */
    public void browserReload(PeerComponent browserPeer) {
<span class="nc" id="L4534">    }</span>

    /**
     * Indicates whether back is currently available
     *
     * @param browserPeer browser instance
     * @return true if back should work
     */
    public boolean browserHasBack(PeerComponent browserPeer) {
<span class="nc" id="L4543">        return false;</span>
    }

    /**
     * Indicates whether forward is currently available
     *
     * @param browserPeer browser instance
     * @return true if forward should work
     */
    public boolean browserHasForward(PeerComponent browserPeer) {
<span class="nc" id="L4553">        return false;</span>
    }

    /**
     * Navigates back in the history
     *
     * @param browserPeer browser instance
     */
    public void browserBack(PeerComponent browserPeer) {
<span class="nc" id="L4562">    }</span>

    /**
     * Stops loading the current page
     *
     * @param browserPeer browser instance
     */
    public void browserStop(PeerComponent browserPeer) {
<span class="nc" id="L4570">    }</span>

    /**
     * Release browser native resources
     *
     * @param internal browser instance
     */
    public void browserDestroy(PeerComponent internal) {
<span class="nc" id="L4578">    }</span>

    /**
     * Navigates forward in the history
     *
     * @param browserPeer browser instance
     */
    public void browserForward(PeerComponent browserPeer) {
<span class="nc" id="L4586">    }</span>

    /**
     * Clears navigation history
     *
     * @param browserPeer browser instance
     */
    public void browserClearHistory(PeerComponent browserPeer) {
<span class="nc" id="L4594">    }</span>

    /**
     * Shows the given HTML in the native viewer
     *
     * @param browserPeer browser instance
     * @param html        HTML web page
     * @param baseUrl     base URL to associate with the HTML
     */
    public void setBrowserPage(PeerComponent browserPeer, String html, String baseUrl) {
<span class="nc" id="L4604">    }</span>

    /**
     * Executes the given JavaScript string within the current context
     *
     * @param browserPeer browser instance
     * @param javaScript  the JavaScript string
     */
    public void browserExecute(PeerComponent browserPeer, String javaScript) {
<span class="nc" id="L4613">        setBrowserURL(browserPeer, &quot;javascript:(function(){&quot; + javaScript + &quot;})()&quot;);</span>
<span class="nc" id="L4614">    }</span>

    /**
     * Executes javascript and returns string. The default implementation
     * just wraps the browserExecute() method that doesn't return anything. It will
     * return null always. You need to override this in the native implementation
     * to return meaningful values.
     *
     * @param internal   The peer browser component.
     * @param javaScript The javascript to execute.
     * @return String result of the javascript expression.
     */
    public String browserExecuteAndReturnString(PeerComponent internal, String javaScript) {
<span class="nc" id="L4627">        browserExecute(internal, javaScript);</span>
<span class="nc" id="L4628">        return null;</span>
    }

    public boolean supportsBrowserExecuteAndReturnString(PeerComponent internal) {
<span class="nc" id="L4632">        return false;</span>
    }

    /**
     * Allows exposing the given object to JavaScript code so the JavaScript code can invoke methods
     * and access fields on the given object. Notice that on RIM devices which don't support reflection
     * this object must implement the propriatery Scriptable interface
     * http://www.blackberry.com/developers/docs/5.0.0api/net/rim/device/api/script/Scriptable.html
     *
     * @param browserPeer browser instance
     * @param o           the object to invoke, notice all public fields and methods would be exposed to JavaScript
     * @param name        the name to expose within JavaScript
     * @deprecated This method was never well-supported across platforms other than Android - and it will no longer work
     * even in Android for SDK &amp;gt;= 17, unless {@literal o}'s class has the {@literal @JavascriptInterface} annotation which
     * would only be available if implemented inside a Native Interface.  Don't use this.
     */
    public void browserExposeInJavaScript(PeerComponent browserPeer, Object o, String name) {
<span class="nc" id="L4649">    }</span>

    /**
     * Converts the dips count to pixels, dips are roughly 1mm in length. This is a very rough estimate and not
     * to be relied upon
     *
     * @param dipCount   the dips that we will convert to pixels
     * @param horizontal indicates pixels in the horizontal plane
     * @return value in pixels
     */
    public int convertToPixels(int dipCount, boolean horizontal) {
<span class="nc bnc" id="L4660" title="All 7 branches missed.">        switch (getDeviceDensity()) {</span>
            case Display.DENSITY_VERY_LOW:
<span class="nc" id="L4662">                return dipCount;</span>
            case Display.DENSITY_LOW:
<span class="nc" id="L4664">                return dipCount * 2;</span>
            case Display.DENSITY_MEDIUM:
<span class="nc" id="L4666">                return dipCount * 5;</span>
            case Display.DENSITY_HIGH:
<span class="nc" id="L4668">                return dipCount * 10;</span>
            case Display.DENSITY_VERY_HIGH:
<span class="nc" id="L4670">                return dipCount * 14;</span>
            case Display.DENSITY_HD:
<span class="nc" id="L4672">                return dipCount * 20;</span>
        }
<span class="nc" id="L4674">        return dipCount;</span>
    }

    /**
     * Indicates whether the device is a tablet, notice that this is often a guess
     *
     * @return true if the device is assumed to be a tablet
     */
    public boolean isTablet() {
<span class="nc" id="L4683">        return false;</span>
    }

    /**
     * Returns true if this is a desktop application
     *
     * @return true if this is a desktop application
     */
    public boolean isDesktop() {
<span class="fc" id="L4692">        return false;</span>
    }

    /**
     * Returns true if the device has dialing capabilities
     *
     * @return false if it cannot dial
     */
    public boolean canDial() {
<span class="nc bnc" id="L4701" title="All 4 branches missed.">        return !isTablet() &amp;&amp; !isDesktop();</span>
    }

    /**
     * Allows an implementation to modify setting thread priority, some implementations
     * don't handle thread priorities well
     *
     * @param t the thread
     * @param p the priority
     */
    public void setThreadPriority(Thread t, int p) {
<span class="fc" id="L4712">        t.setPriority(p);</span>
<span class="fc" id="L4713">    }</span>

    /**
     * Callback allowing the implementation to perform an operation on the init thread
     * after initialization was completed
     */
    public void postInit() {
<span class="fc" id="L4720">        initDefaultUserAgent();</span>
<span class="fc" id="L4721">    }</span>

    /**
     * Some old platforms might need this but for modern platforms the user agent should &quot;just work&quot;.
     */
    protected void initDefaultUserAgent() {
        //sets the default device user agent if available by the platform, by default
        //we set Nokia, beacause if the user agent is empty it is most likely a J2ME device
<span class="fc" id="L4729">        ConnectionRequest.setDefaultUserAgent(Display.getInstance().getProperty(&quot;User-Agent&quot;,</span>
                &quot;Mozilla/5.0 (SymbianOS/9.4; Series60/5.0 NokiaN97-1/20.0.019; Profile/MIDP-2.1 Configuration/CLDC-1.1) AppleWebKit/525 (KHTML, like Gecko) BrowserNG/7.1.18124&quot;));
<span class="fc" id="L4731">    }</span>

    /**
     * Allows for easier debugging of native implementations by setting the image name to
     * the native image object
     *
     * @param nativeImage the native image
     * @param name        the name/file name identifying the image
     */
    public void setImageName(Object nativeImage, String name) {
<span class="fc" id="L4741">    }</span>

    /**
     * On most platforms it is quite fast to draw on a mutable image and then render that
     * image, however some platforms have much slower mutable images in comparison to just
     * drawing on the screen. These platforms should return false here and Codename One will try
     * to use less mutable image related optimizations in transitions and other operations.
     *
     * @return true if mutable images are fast on this platform
     */
    public boolean areMutableImagesFast() {
<span class="nc" id="L4752">        return true;</span>
    }

    private void purgeOldCookies(Map&lt;String, Cookie&gt; cookies) {
<span class="nc" id="L4756">        long now = System.currentTimeMillis();</span>
<span class="nc" id="L4757">        ArrayList&lt;String&gt; toRemove = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L4758" title="All 2 branches missed.">        for (Map.Entry&lt;String, Cookie&gt; e : cookies.entrySet()) {</span>
<span class="nc bnc" id="L4759" title="All 4 branches missed.">            if (e.getValue().getExpires() != 0 &amp;&amp; e.getValue().getExpires() &lt; now) {</span>
<span class="nc" id="L4760">                toRemove.add(e.getKey());</span>
            }
<span class="nc" id="L4762">        }</span>
<span class="nc bnc" id="L4763" title="All 2 branches missed.">        for (String key : toRemove) {</span>
<span class="nc" id="L4764">            cookies.remove(key);</span>
<span class="nc" id="L4765">        }</span>
<span class="nc" id="L4766">    }</span>

    protected final void removeCookiesForDomain(String domain) {
<span class="nc bnc" id="L4769" title="All 4 branches missed.">        if (cookies == null || domain == null) {</span>
<span class="nc" id="L4770">            return;</span>
        }
<span class="nc" id="L4772">        Hashtable h = (Hashtable) cookies.get(domain);</span>
<span class="nc bnc" id="L4773" title="All 2 branches missed.">        if (h == null) {</span>
<span class="nc" id="L4774">            return;</span>
        }
<span class="nc" id="L4776">        h.clear();</span>
<span class="nc bnc" id="L4777" title="All 2 branches missed.">        if (Cookie.isAutoStored()) {</span>
<span class="nc bnc" id="L4778" title="All 2 branches missed.">            if (Storage.getInstance().exists(Cookie.STORAGE_NAME)) {</span>
<span class="nc" id="L4779">                Storage.getInstance().deleteStorageFile(Cookie.STORAGE_NAME);</span>
            }
<span class="nc" id="L4781">            Storage.getInstance().writeObject(Cookie.STORAGE_NAME, cookies);</span>
        }

<span class="nc" id="L4784">    }</span>

    public void addCookie(Cookie[] cookiesArray) {
<span class="nc bnc" id="L4787" title="All 2 branches missed.">        if (cookies == null) {</span>
<span class="nc" id="L4788">            cookies = new Hashtable();</span>
        }
<span class="nc" id="L4790">        int calen = cookiesArray.length;</span>
<span class="nc bnc" id="L4791" title="All 2 branches missed.">        for (int i = 0; i &lt; calen; i++) {</span>
<span class="nc" id="L4792">            Cookie cookie = cookiesArray[i];</span>
<span class="nc" id="L4793">            Hashtable h = (Hashtable) cookies.get(cookie.getDomain());</span>
<span class="nc bnc" id="L4794" title="All 2 branches missed.">            if (h == null) {</span>
<span class="nc" id="L4795">                h = new Hashtable();</span>
<span class="nc" id="L4796">                cookies.put(cookie.getDomain(), h);</span>
            }
<span class="nc" id="L4798">            purgeOldCookies(h);</span>
<span class="nc bnc" id="L4799" title="All 4 branches missed.">            if (cookie.getExpires() != 0 &amp;&amp; cookie.getExpires() &lt; System.currentTimeMillis()) {</span>
<span class="nc" id="L4800">                h.remove(cookie.getName());</span>
            } else {
<span class="nc" id="L4802">                h.put(cookie.getName(), cookie);</span>
            }
        }

<span class="nc bnc" id="L4806" title="All 2 branches missed.">        if (Cookie.isAutoStored()) {</span>
<span class="nc bnc" id="L4807" title="All 2 branches missed.">            if (Storage.getInstance().exists(Cookie.STORAGE_NAME)) {</span>
<span class="nc" id="L4808">                Storage.getInstance().deleteStorageFile(Cookie.STORAGE_NAME);</span>
            }
<span class="nc" id="L4810">            Storage.getInstance().writeObject(Cookie.STORAGE_NAME, cookies);</span>
        }
<span class="nc" id="L4812">    }</span>

    /**
     * Checks if this platform supports sharing cookies between Native components (e.g. BrowserComponent)
     * and ConnectionRequests.  Currently only Android and iOS ports support this.
     *
     * @return True if platform supports native cookie sharing.
     * @since 8.0
     */
    public boolean isNativeCookieSharingSupported() {
<span class="nc" id="L4822">        return false;</span>
    }

    /**
     * Adds/replaces a cookie to be sent to the given domain
     *
     * @param c cookie to add
     */
    public void addCookie(Cookie c) {
<span class="nc bnc" id="L4831" title="All 2 branches missed.">        if (cookies == null) {</span>
<span class="nc" id="L4832">            cookies = new Hashtable();</span>
        }
<span class="nc" id="L4834">        Hashtable h = (Hashtable) cookies.get(c.getDomain());</span>
<span class="nc bnc" id="L4835" title="All 2 branches missed.">        if (h == null) {</span>
<span class="nc" id="L4836">            h = new Hashtable();</span>
<span class="nc" id="L4837">            cookies.put(c.getDomain(), h);</span>
        }
<span class="nc" id="L4839">        h.put(c.getName(), c);</span>
<span class="nc bnc" id="L4840" title="All 2 branches missed.">        if (Cookie.isAutoStored()) {</span>
<span class="nc bnc" id="L4841" title="All 2 branches missed.">            if (Storage.getInstance().exists(Cookie.STORAGE_NAME)) {</span>
<span class="nc" id="L4842">                Storage.getInstance().deleteStorageFile(Cookie.STORAGE_NAME);</span>
            }
<span class="nc" id="L4844">            Storage.getInstance().writeObject(Cookie.STORAGE_NAME, cookies);</span>
        }
<span class="nc" id="L4846">    }</span>

    /**
     * Returns the domain for the given URL
     *
     * @param url a url
     * @return the domain
     */
    public String getURLDomain(String url) {
<span class="nc" id="L4855">        String domain = url.substring(url.indexOf(&quot;//&quot;) + 2);</span>
<span class="nc" id="L4856">        int i = domain.indexOf('/');</span>
<span class="nc bnc" id="L4857" title="All 2 branches missed.">        if (i &gt; -1) {</span>
<span class="nc" id="L4858">            domain = domain.substring(0, i);</span>
        }
<span class="nc" id="L4860">        return domain;</span>
    }

    public String getURLPath(String url) {
<span class="fc" id="L4864">        String path = url.substring(url.indexOf(&quot;//&quot;) + 2);</span>
<span class="fc" id="L4865">        int i = path.indexOf('/');</span>
<span class="pc bpc" id="L4866" title="1 of 2 branches missed.">        if (i &gt; -1) {</span>
<span class="fc" id="L4867">            path = path.substring(i);</span>
        }
<span class="fc" id="L4869">        i = path.indexOf('?');</span>
<span class="fc bfc" id="L4870" title="All 2 branches covered.">        if (i &gt; -1) {</span>
<span class="fc" id="L4871">            path = path.substring(0, i);</span>
        }

<span class="fc" id="L4874">        i = path.indexOf('#');</span>
<span class="pc bpc" id="L4875" title="1 of 2 branches missed.">        if (i &gt; -1) {</span>
<span class="nc" id="L4876">            path = path.substring(0, i);</span>
        }

<span class="fc" id="L4879">        return path;</span>
    }

    /**
     * Returns the cookies for this URL
     *
     * @param url the url on which we are checking for cookies
     * @return the cookies to submit to the given URL
     */
    public Vector getCookiesForURL(String url) {
<span class="fc" id="L4889">        Vector response = null;</span>
<span class="pc bpc" id="L4890" title="1 of 2 branches missed.">        if (Cookie.isAutoStored()) {</span>
<span class="fc" id="L4891">            cookies = (Hashtable) Storage.getInstance().readObject(Cookie.STORAGE_NAME);</span>
        }

<span class="fc" id="L4894">        String protocol = &quot;&quot;;</span>
<span class="fc" id="L4895">        int pos = -1;</span>
<span class="pc bpc" id="L4896" title="1 of 2 branches missed.">        if ((pos = url.indexOf(&quot;:&quot;)) &gt;= 0) {</span>
<span class="fc" id="L4897">            protocol = url.substring(0, pos);</span>
        }
<span class="pc bpc" id="L4899" title="2 of 4 branches missed.">        boolean isHttp = (&quot;http&quot;.equals(protocol) || &quot;https&quot;.equals(protocol));</span>
<span class="fc" id="L4900">        boolean isSecure = &quot;https&quot;.equals(protocol);</span>
<span class="fc" id="L4901">        String path = getURLPath(url);</span>


<span class="pc bpc" id="L4904" title="3 of 4 branches missed.">        if (cookies != null &amp;&amp; cookies.size() &gt; 0) {</span>
<span class="nc" id="L4905">            String domain = getURLDomain(url);</span>
<span class="nc" id="L4906">            Enumeration e = cookies.keys();</span>
<span class="nc bnc" id="L4907" title="All 2 branches missed.">            while (e.hasMoreElements()) {</span>
<span class="nc" id="L4908">                String domainKey = (String) e.nextElement();</span>
<span class="nc bnc" id="L4909" title="All 2 branches missed.">                if (domain.indexOf(domainKey) &gt; -1) {</span>
<span class="nc" id="L4910">                    Hashtable h = (Hashtable) cookies.get(domainKey);</span>
<span class="nc bnc" id="L4911" title="All 2 branches missed.">                    if (h != null) {</span>
<span class="nc" id="L4912">                        Enumeration enumCookies = h.elements();</span>
<span class="nc bnc" id="L4913" title="All 2 branches missed.">                        if (response == null) {</span>
<span class="nc" id="L4914">                            response = new Vector();</span>
                        }
<span class="nc bnc" id="L4916" title="All 2 branches missed.">                        while (enumCookies.hasMoreElements()) {</span>
<span class="nc" id="L4917">                            Cookie nex = (Cookie) enumCookies.nextElement();</span>
<span class="nc bnc" id="L4918" title="All 4 branches missed.">                            if (nex.isHttpOnly() &amp;&amp; !isHttp) {</span>
<span class="nc" id="L4919">                                continue;</span>
                            }
<span class="nc bnc" id="L4921" title="All 4 branches missed.">                            if (nex.isSecure() &amp;&amp; !isSecure) {</span>
<span class="nc" id="L4922">                                continue;</span>
                            }
<span class="nc bnc" id="L4924" title="All 2 branches missed.">                            if (path.indexOf(nex.getPath()) != 0) {</span>
<span class="nc" id="L4925">                                continue;</span>
                            }
<span class="nc" id="L4927">                            response.addElement(nex);</span>
<span class="nc" id="L4928">                        }</span>
                    }
                }
<span class="nc" id="L4931">            }</span>
        }
<span class="fc" id="L4933">        return response;</span>
    }

    public void clearNativeCookies() {

<span class="nc" id="L4938">    }</span>

    /**
     * Connects to a given URL, returns a connection object to be used with the implementation
     * later
     *
     * @param url   the URL to connect to
     * @param read  indicates whether the connection will be read from
     * @param write indicates whether writing will occur into the connection
     * @return a URL instance
     */
    public abstract Object connect(String url, boolean read, boolean write) throws IOException;

    /**
     * Gets the SSL certificates for a connection
     *
     * @param connection The connection.
     * @param url        The url of the connection.
     * @return String array where each certificate is in form {@literal &lt;ALGORITHM&gt;:&lt;FINGERPRINT&gt;}
     * @throws IOException
     */
    public String[] getSSLCertificates(Object connection, String url) throws IOException {
<span class="nc" id="L4960">        return new String[0];</span>
    }

    /**
     * Checks if the platform supports getting SSL certificates.
     *
     * @return True if the platform supports SSL certificates.
     */
    public boolean canGetSSLCertificates() {
<span class="nc" id="L4969">        return false;</span>
    }

    /**
     * SSL certificate checks must be performed via a callback from the native side,
     * rather than explicitly checking as part of NetworkManager's connection
     * flow.   This is mainly for iOS POST requests.  If we try to get the SSL certs
     * explicitly, it forces the connection to be sent without a POST body.  Hence
     * we need to let iOS do the check on the native side, and callback into Java
     * to run the checkSSLCertificates method of the request.
     *
     * @return True if the platform requires a native callback fo check SSL certificates
     */
    public boolean checkSSLCertificatesRequiresCallbackFromNative() {
<span class="nc" id="L4983">        return false;</span>
    }

    public void setConnectionId(Object connection, int id) {

<span class="fc" id="L4988">    }</span>

    /**
     * This method is called by the NetworkManager when a request is added to the queue.  This allows
     * the implementation to track the time that the request was queued for diagnostics purposes.
     * The Simulator's Network monitor uses this information to display stats about each network connection.
     *
     * @param req The ConnectionRequest that is queued.
     */
    public void addConnectionToQueue(ConnectionRequest req) {

<span class="fc" id="L4999">    }</span>

    /**
     * Connects to a given URL, returns a connection object to be used with the implementation
     * later
     *
     * @param url     the URL to connect to
     * @param read    indicates whether the connection will be read from
     * @param write   indicates whether writing will occur into the connection
     * @param timeout the timeout version of this method
     * @return a URL instance
     */
    public Object connect(String url, boolean read, boolean write, int timeout) throws IOException {
<span class="nc" id="L5012">        return connect(url, read, write);</span>
    }

    /**
     * Requests special http method such as put or delete
     *
     * @param connection the connection object
     * @param method     the method string
     */
    public void setHttpMethod(Object connection, String method) throws IOException {
<span class="nc" id="L5022">    }</span>

    /**
     * Indicates the HTTP header value for an HTTP connection
     *
     * @param connection the connection object
     * @param key        the key for the header
     * @param val        the value for the header
     */
    public abstract void setHeader(Object connection, String key, String val);

    /**
     * This method is used to enable streaming of a HTTP request body without
     * internal buffering, when the content length is not known in advance.
     * In this mode, chunked transfer encoding is used to send the request body.
     * Note, not all HTTP servers support this mode.
     * This mode is supported on Android and the Desktop ports.
     *
     * @param connection the connection object
     * @param bufferLen  The number of bytes to write in each chunk. If chunklen
     *                   is less than or equal to zero, a default value will be used.
     */
    public void setChunkedStreamingMode(Object connection, int bufferLen) {
<span class="nc" id="L5045">    }</span>

    /**
     * Closes the object (connection, stream etc.) without throwing any exception, even if the
     * object is null
     *
     * @param o Connection, Stream or other closeable object
     */
    public void cleanup(Object o) {
        try {
<span class="nc bnc" id="L5055" title="All 2 branches missed.">            if (o != null) {</span>
<span class="nc bnc" id="L5056" title="All 2 branches missed.">                if (o instanceof InputStream) {</span>
<span class="nc" id="L5057">                    ((InputStream) o).close();</span>
<span class="nc" id="L5058">                    return;</span>
                }
<span class="nc bnc" id="L5060" title="All 2 branches missed.">                if (o instanceof OutputStream) {</span>
<span class="nc" id="L5061">                    ((OutputStream) o).close();</span>
<span class="nc" id="L5062">                    return;</span>
                }
<span class="nc bnc" id="L5064" title="All 2 branches missed.">                if (o instanceof Reader) {</span>
<span class="nc" id="L5065">                    ((Reader) o).close();</span>
<span class="nc" id="L5066">                    return;</span>
                }
<span class="nc bnc" id="L5068" title="All 2 branches missed.">                if (o instanceof Writer) {</span>
<span class="nc" id="L5069">                    ((Writer) o).close();</span>
                }
<span class="nc bnc" id="L5071" title="All 2 branches missed.">                if (o instanceof Database) {</span>
<span class="nc" id="L5072">                    ((Database) o).close();</span>
                }
<span class="nc bnc" id="L5074" title="All 2 branches missed.">                if (o instanceof Cursor) {</span>
<span class="nc" id="L5075">                    ((Cursor) o).close();</span>
                }
            }
<span class="nc" id="L5078">        } catch (Throwable ex) {</span>
<span class="nc" id="L5079">            Log.e(ex);</span>
<span class="nc" id="L5080">        }</span>
<span class="nc" id="L5081">    }</span>

    /**
     * Checks if this platform supports custom cursors.
     *
     * @return True if the platform supports custom cursors.
     * @see Form#setEnableCursors(boolean)
     * @see Component#setCursor(int)
     * @see ComponentSelector#setCursor(int)
     */
    public boolean isSetCursorSupported() {
<span class="nc" id="L5092">        return false;</span>
    }

    /**
     * Returns the content length for this connection
     *
     * @param connection the connection
     * @return the content length
     */
    public abstract int getContentLength(Object connection);

    /**
     * Returns an output stream for the given connection
     *
     * @param connection the connection to open an output stream on
     * @return the created output stream
     * @throws IOException thrown by underlying implemnetation
     */
    public abstract OutputStream openOutputStream(Object connection) throws IOException;

    /**
     * Returns an output stream for the given connection
     *
     * @param connection the connection to open an output stream on
     * @param offset     position in the file
     * @return the created output stream
     * @throws IOException thrown by underlying implemnetation
     */
    public abstract OutputStream openOutputStream(Object connection, int offset) throws IOException;

    /**
     * Returns an input stream for the given connection
     *
     * @param connection the connection to open an input stream on
     * @return the created input stream
     * @throws IOException thrown by underlying implemnetation
     */
    public abstract InputStream openInputStream(Object connection) throws IOException;

    /**
     * Returns an output stream for the given file
     *
     * @param file the file to which we should open a stream
     * @return the created output stream
     * @throws IOException thrown by underlying implemnetation
     */
    public OutputStream openFileOutputStream(String file) throws IOException {
<span class="nc" id="L5139">        return openOutputStream(file);</span>
    }

    /**
     * Returns an input stream for the given connection
     *
     * @param file the file to which we should open a stream
     * @return the created input stream
     * @throws IOException thrown by underlying implemnetation
     */
    public InputStream openFileInputStream(String file) throws IOException {
<span class="nc" id="L5150">        return openInputStream(file);</span>
    }

    /**
     * Indicates the whether the request method is GET or POST
     *
     * @param connection the connection object
     * @param p          true for post false for get
     */
    public abstract void setPostRequest(Object connection, boolean p);

    /**
     * Returns the server response code for the request
     *
     * @param connection the connection object
     * @return a numeric HTTP response code
     * @throws IOException if the request failed
     */
    public abstract int getResponseCode(Object connection) throws IOException;

    /**
     * Returns the server response message for the request
     *
     * @param connection the connection object
     * @return a text message to go along with the response code
     * @throws IOException if the request failed
     */
    public abstract String getResponseMessage(Object connection) throws IOException;

    /**
     * Returns the HTTP response header field
     *
     * @param name       field name for http header
     * @param connection the connection object
     * @return the value of the header field
     * @throws IOException if the request failed
     */
    public abstract String getHeaderField(String name, Object connection) throws IOException;

    /**
     * Returns the HTTP response header field
     *
     * @param connection the connection object
     * @return the value of the header field
     * @throws IOException if the request failed
     */
    public abstract String[] getHeaderFieldNames(Object connection) throws IOException;

    /**
     * Returns the HTTP response header fields, returns optionally more than one result or null if
     * no field is present.
     *
     * @param name       field name for http header
     * @param connection the connection object
     * @return the values of the header fields
     * @throws IOException if the request failed
     */
    public abstract String[] getHeaderFields(String name, Object connection) throws IOException;

    /**
     * Indicates whether the underlying implementation supports the notion of a network operation
     * timeout. If not timeout is &quot;faked&quot;
     *
     * @return true if HTTP timeout can be configured for this IO implementation
     */
    public boolean isTimeoutSupported() {
<span class="nc" id="L5216">        return false;</span>
    }

    /**
     * This will work only if http timeout is supported
     *
     * @param t time in milliseconds
     */
    public void setTimeout(int t) {
<span class="nc" id="L5225">    }</span>

    /**
     * Flush the storage cache allowing implementations that cache storage objects
     * to store
     */
    public void flushStorageCache() {
<span class="nc" id="L5232">    }</span>

    /**
     * The storage data is used by some storage implementations (e.g. CDC) to place the
     * storage object in a &quot;proper&quot; location matching the application name. This needs to
     * be set by the user, the name might be ignored in platforms (such as MIDP) where storage
     * is mapped to a native application specific storage.
     *
     * @return the name for the storage
     */
    public Object getStorageData() {
<span class="nc" id="L5243">        return storageData;</span>
    }

    /**
     * The storage data is used by some storage implementations (e.g. CDC) to place the
     * storage object in a &quot;proper&quot; location matching the application name. This needs to
     * be set by the user, the name might be ignored in platforms (such as MIDP) where storage
     * is mapped to a native application specific storage.
     *
     * @param storageData the name for the storage or its context
     */
    public void setStorageData(Object storageData) {
<span class="nc" id="L5255">        this.storageData = storageData;</span>
<span class="nc" id="L5256">    }</span>

    /**
     * Deletes the given file name from the storage
     *
     * @param name the name of the storage file
     */
    public abstract void deleteStorageFile(String name);

    /**
     * Deletes all the files in the application storage
     */
    public void clearStorage() {
<span class="nc" id="L5269">        String[] l = listStorageEntries();</span>
<span class="nc" id="L5270">        int llen = l.length;</span>
<span class="nc bnc" id="L5271" title="All 2 branches missed.">        for (int iter = 0; iter &lt; llen; iter++) {</span>
<span class="nc" id="L5272">            deleteStorageFile(l[iter]);</span>
        }
<span class="nc" id="L5274">    }</span>

    /**
     * Creates an output stream to the storage with the given name
     *
     * @param name the storage file name
     * @return an output stream of limited capcity
     */
    public abstract OutputStream createStorageOutputStream(String name) throws IOException;

    /**
     * Creates an input stream to the given storage source file
     *
     * @param name the name of the source file
     * @return the input stream
     */
    public abstract InputStream createStorageInputStream(String name) throws IOException;

    /**
     * Returns true if the given storage file exists
     *
     * @param name the storage file name
     * @return true if it exists
     */
    public abstract boolean storageFileExists(String name);

    /**
     * Lists the names of the storage files
     *
     * @return the names of all the storage files
     */
    public abstract String[] listStorageEntries();

    /**
     * Returns the size of the entry in bytes
     *
     * @param name the entry name
     * @return the size
     */
    public int getStorageEntrySize(String name) {
<span class="nc" id="L5314">        long size = -1;</span>
        try {
<span class="nc" id="L5316">            InputStream i = createStorageInputStream(name);</span>
<span class="nc" id="L5317">            long val = i.skip(1000000);</span>
<span class="nc bnc" id="L5318" title="All 2 branches missed.">            if (val &gt; -1) {</span>
<span class="nc" id="L5319">                size = 0;</span>
<span class="nc bnc" id="L5320" title="All 2 branches missed.">                while (val &gt; -1) {</span>
<span class="nc" id="L5321">                    size += val;</span>
<span class="nc" id="L5322">                    val = i.skip(1000000);</span>
                }
            }
<span class="nc" id="L5325">            Util.cleanup(i);</span>
<span class="nc" id="L5326">        } catch (IOException err) {</span>
<span class="nc" id="L5327">            Log.e(err);</span>
<span class="nc" id="L5328">        }</span>
<span class="nc" id="L5329">        return (int) size;</span>
    }

    /**
     * Returns the filesystem roots from which the structure of the file system
     * can be traversed
     *
     * @return the roots of the filesystem
     */
    public abstract String[] listFilesystemRoots();

    /**
     * Lists the files within the given directory, returns relative file names and not
     * full file names.
     *
     * @param directory the directory in which files should be listed
     * @return array of file names
     */
    public abstract String[] listFiles(String directory) throws IOException;

    /**
     * Returns the size of the given root directory
     *
     * @param root the root directory in the filesystem
     * @return the byte size of the directory
     */
    public abstract long getRootSizeBytes(String root);

    /**
     * Returns the available space in the given root directory
     *
     * @param root the root directory in the filesystem
     * @return the bytes available in the directory
     */
    public abstract long getRootAvailableSpace(String root);

    /**
     * Creates the given directory
     *
     * @param directory the directory name to create
     */
    public abstract void mkdir(String directory);

    /**
     * Deletes the specific file or empty directory.
     *
     * @param file file or empty directory to delete
     */
    public abstract void deleteFile(String file);

    /**
     * Indicates the hidden state of the file
     *
     * @param file file
     * @return true for a hidden file
     */
    public abstract boolean isHidden(String file);

    /**
     * Toggles the hidden state of the file
     *
     * @param file file
     * @param h    hidden state
     */
    public abstract void setHidden(String file, boolean h);

    /**
     * Returns the length of the file
     *
     * @param file file
     * @return length of said file
     */
    public abstract long getFileLength(String file);

    /**
     * Returns the time that the file denoted by this abstract pathname was
     * last modified.
     *
     * @return A long value representing the time the file was last modified,
     * measured in milliseconds
     */
    public long getFileLastModified(String file) {
<span class="nc" id="L5411">        return -1;</span>
    }

    /**
     * Indicates whether the given file is a directory
     *
     * @param file file
     * @return true if its a directory
     */
    public abstract boolean isDirectory(String file);

    /**
     * Indicates whether the given file exists
     *
     * @param file file
     * @return true if it exists
     */
    public abstract boolean exists(String file);

    /**
     * Renames a file to the given name, expects the new name to be relative to the
     * current directory
     *
     * @param file    absolute file name
     * @param newName relative new name
     */
    public abstract void rename(String file, String newName);

    /**
     * Returns the file system separator char normally '/'
     *
     * @return the separator char
     */
    public abstract char getFileSystemSeparator();

    public String getLineSeparator() {
<span class="nc" id="L5447">        return &quot;\n&quot;;</span>
    }

    /**
     * Indicates whether looking up an access point is supported by this device
     *
     * @return true if access point lookup is supported
     */
    public boolean isAPSupported() {
<span class="nc" id="L5456">        return false;</span>
    }

    /**
     * Returns the ids of the access points available if supported
     *
     * @return ids of access points
     */
    public String[] getAPIds() {
<span class="nc" id="L5465">        return null;</span>
    }

    /**
     * Returns the type of the access point
     *
     * @param id access point id
     * @return one of the supported access point types from network manager
     */
    public int getAPType(String id) {
<span class="nc" id="L5475">        return NetworkManager.ACCESS_POINT_TYPE_UNKNOWN;</span>
    }

    /**
     * Returns the user displayable name for the given access point
     *
     * @param id the id of the access point
     * @return the name of the access point
     */
    public String getAPName(String id) {
<span class="nc" id="L5485">        return null;</span>
    }

    /**
     * Returns the id of the current access point
     *
     * @return id of the current access point
     */
    public String getCurrentAccessPoint() {
<span class="nc" id="L5494">        return null;</span>
    }

    /**
     * Returns the id of the current access point
     *
     * @param id id of the current access point
     */
    public void setCurrentAccessPoint(String id) {
<span class="nc" id="L5503">    }</span>

    /**
     * For some reason the standard code for writing UTF8 output in a server request
     * doesn't work as expected on SE/CDC stacks.
     *
     * @return true if the getBytes() approach should be used
     */
    public boolean shouldWriteUTFAsGetBytes() {
<span class="nc" id="L5512">        return false;</span>
    }

    /**
     * Some devices need more elaborate thread creation logic e.g. to increase the
     * default stack size or might use a pooling strategy
     *
     * @param name the name of the thread
     * @param r    the runnable
     */
    public void startThread(String name, Runnable r) {
<span class="nc" id="L5523">        new CodenameOneThread(r, name).start();</span>
<span class="nc" id="L5524">    }</span>

    /**
     * Allows binding logic to occur before closing the output stream
     * such as syncing
     *
     * @param s the closing stream
     */
    public void closingOutput(OutputStream s) {
<span class="nc" id="L5533">    }</span>

    /**
     * Allows the logger to print the stack trace into the log when the native
     * platform supports that
     *
     * @param t the exception
     * @param o the writer
     */
    public void printStackTraceToStream(Throwable t, Writer o) {
<span class="nc" id="L5543">    }</span>

    /**
     * This method is useful strictly for debugging, the logger can use it to track
     * file opening/closing thus detecting potential file resource leaks that
     * can cause serious problems in some OS's.
     *
     * @param al action listener to receive the callback
     */
    public void setLogListener(ActionListener al) {
<span class="nc" id="L5553">        logger = al;</span>
<span class="nc" id="L5554">    }</span>

    /**
     * Indicates whether logging is turned on
     *
     * @return true or false
     */
    protected boolean isLogged() {
<span class="nc bnc" id="L5562" title="All 2 branches missed.">        return logger != null;</span>
    }

    /**
     * Dispatch the message to the logger
     *
     * @param content content of the message
     */
    protected void log(String content) {
<span class="nc" id="L5571">        logger.actionPerformed(new ActionEvent(content, ActionEvent.Type.Log));</span>
<span class="nc" id="L5572">    }</span>

    /**
     * System print
     *
     * @param content
     */
    public void systemOut(String content) {
<span class="fc" id="L5580">        System.out.println(content);</span>
<span class="fc" id="L5581">    }</span>

    /**
     * Logs the creation of a stream
     *
     * @param name    the name of the stream
     * @param isInput whether the stream is an input or output stream
     * @param count   the number of streams of this type
     */
    public void logStreamCreate(String name, boolean isInput, int count) {
<span class="nc bnc" id="L5591" title="All 2 branches missed.">        if (isLogged()) {</span>
<span class="nc bnc" id="L5592" title="All 2 branches missed.">            if (isInput) {</span>
<span class="nc" id="L5593">                log(&quot;Creating input stream &quot; + name + &quot; total streams: &quot; + count);</span>
            } else {
<span class="nc" id="L5595">                log(&quot;Creating output stream &quot; + name + &quot; total streams: &quot; + count);</span>
            }
        }
<span class="nc" id="L5598">    }</span>

    /**
     * Logs the closing of a stream
     *
     * @param name    the name of the stream
     * @param isInput whether the stream is an input or output stream
     * @param count   the number of streams of this type
     */
    public void logStreamClose(String name, boolean isInput, int count) {
<span class="nc bnc" id="L5608" title="All 2 branches missed.">        if (isLogged()) {</span>
<span class="nc bnc" id="L5609" title="All 2 branches missed.">            if (isInput) {</span>
<span class="nc" id="L5610">                log(&quot;Closing input stream &quot; + name + &quot; remaining streams: &quot; + count);</span>
            } else {
<span class="nc" id="L5612">                log(&quot;Closing output stream &quot; + name + &quot; remaining streams: &quot; + count);</span>
            }
        }
<span class="nc" id="L5615">    }</span>

    /**
     * Logs the closing of a stream
     *
     * @param name    the name of the stream
     * @param isInput whether the stream is an input or output stream
     */
    public void logStreamDoubleClose(String name, boolean isInput) {
<span class="nc bnc" id="L5624" title="All 2 branches missed.">        if (isLogged()) {</span>
<span class="nc bnc" id="L5625" title="All 2 branches missed.">            if (isInput) {</span>
<span class="nc" id="L5626">                log(&quot;Double closing input stream &quot; + name);</span>
            } else {
<span class="nc" id="L5628">                log(&quot;Double closing output stream &quot; + name);</span>
            }
        }
<span class="nc" id="L5631">    }</span>

    /**
     * Returns the type of the root often by guessing
     *
     * @param root the root whose type we are checking
     * @return one of the type constants above
     */
    public int getRootType(String root) {
<span class="nc" id="L5640">        root = root.toLowerCase();</span>
<span class="nc" id="L5641">        String sdCard = Display.getInstance().getProperty(&quot;sdcard&quot;, null);</span>
<span class="nc bnc" id="L5642" title="All 2 branches missed.">        if (sdCard != null) {</span>
<span class="nc bnc" id="L5643" title="All 2 branches missed.">            if (root.indexOf(sdCard) &gt; -1) {</span>
<span class="nc" id="L5644">                return FileSystemStorage.ROOT_TYPE_SDCARD;</span>
            }
        } else {
<span class="nc bnc" id="L5647" title="All 6 branches missed.">            if (root.indexOf(&quot;file:///f:&quot;) &gt; -1 || root.indexOf(&quot;file:///e:&quot;) &gt; -1 || root.indexOf(&quot;memorycard&quot;) &gt; -1 ||</span>
<span class="nc bnc" id="L5648" title="All 4 branches missed.">                    root.indexOf(&quot;mmc&quot;) &gt; -1 || root.indexOf(&quot;sdcard&quot;) &gt; -1 ||</span>
<span class="nc bnc" id="L5649" title="All 2 branches missed.">                    root.indexOf(&quot;store&quot;) &gt; -1) {</span>
<span class="nc" id="L5650">                return FileSystemStorage.ROOT_TYPE_SDCARD;</span>
            }
        }
<span class="nc bnc" id="L5653" title="All 6 branches missed.">        if (root.indexOf(&quot;c:&quot;) &gt; -1 || root.indexOf(&quot;phone memory&quot;) &gt; -1 || root.indexOf(&quot;store&quot;) &gt; -1) {</span>
<span class="nc" id="L5654">            return FileSystemStorage.ROOT_TYPE_MAINSTORAGE;</span>
        }
<span class="nc" id="L5656">        return FileSystemStorage.ROOT_TYPE_UNKNOWN;</span>
    }

    /**
     * This method returns the platform Location Control
     *
     * @return LocationManager Object
     */
    public LocationManager getLocationManager() {
<span class="nc" id="L5665">        return null;</span>
    }

    /**
     * Allows buggy implementations (Android) to release image objects
     *
     * @param image native image object
     */
    public void releaseImage(Object image) {
<span class="fc" id="L5674">    }</span>

    /**
     * Captures a photo and notifies with the image data when available
     *
     * @param response callback for the resulting image
     */
    public void capturePhoto(ActionListener response) {
<span class="nc" id="L5682">    }</span>

    /**
     * Captures a screenshot of the screen.
     *
     * @return An image of the screen, or null if it failed.
     * @since 7.0
     */
    public Image captureScreen() {
<span class="nc" id="L5691">        Form form = getCurrentForm();</span>
<span class="nc bnc" id="L5692" title="All 2 branches missed.">        if (form != null) {</span>
<span class="nc" id="L5693">            return form.toImage();</span>
        }
<span class="nc" id="L5695">        return null;</span>
    }

    public void captureAudio(final com.codename1.ui.events.ActionListener response) {
<span class="nc" id="L5699">        captureAudio(new MediaRecorderBuilder()</span>
<span class="nc" id="L5700">                .path(new com.codename1.io.File(&quot;tmpaudio.wav&quot;).getAbsolutePath())</span>
<span class="nc" id="L5701">                .mimeType(&quot;audio/wav&quot;), response);</span>

<span class="nc" id="L5703">    }</span>

    /**
     * Gets a reference to an application-wide shared Javascript context that can be used for running
     * Javascript commands.  When running in the Javascript port, this Javascript context will be the
     * same context in which the application itself is running, so it gives you the ability to interact
     * with the browser and DOM directly using the familiar {@link BrowserComponent} API.
     *
     * &lt;p&gt;When running on other platforms, this shared context will be an off-screen browser component.
     *
     * @return A shared BrowserComponent
     * @since 7.0
     */
    public final BrowserComponent getSharedJavscriptContext() {
<span class="nc bnc" id="L5717" title="All 2 branches missed.">        if (sharedJavascriptContext == null) {</span>
<span class="nc" id="L5718">            sharedJavascriptContext = createSharedJavascriptContext();</span>
        }
<span class="nc" id="L5720">        return sharedJavascriptContext;</span>
    }

    /**
     * Creates a shared javascript context.  This can be overridden by ports to
     * return a special browser component. On the Javascript port it returns a special component
     * that encapsulates the browser environment that the application is running in.
     *
     * @return A shared BrowserComponent
     * @since 7.0
     */
    protected BrowserComponent createSharedJavascriptContext() {
<span class="nc" id="L5732">        BrowserComponent out = new BrowserComponent();</span>
<span class="nc" id="L5733">        out.setPage(&quot;&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;, null);</span>

<span class="nc" id="L5735">        return out;</span>
    }

    /**
     * Captures a audio and notifies with the raw data when available
     *
     * @param response callback for the resulting data
     */

    public void captureAudio(final MediaRecorderBuilder recordingOptions, final com.codename1.ui.events.ActionListener response) {
<span class="nc bnc" id="L5745" title="All 2 branches missed.">        final MediaRecorderBuilder builder = recordingOptions == null ? new MediaRecorderBuilder() : recordingOptions;</span>
<span class="nc bnc" id="L5746" title="All 4 branches missed.">        if (!builder.isRedirectToAudioBuffer() &amp;&amp; builder.getPath() == null) {</span>
<span class="nc" id="L5747">            builder.path(new com.codename1.io.File(&quot;tmpaudio.wav&quot;).getAbsolutePath());</span>
        }
<span class="nc bnc" id="L5749" title="All 4 branches missed.">        if (!builder.isRedirectToAudioBuffer() &amp;&amp; builder.getMimeType() == null) {</span>
<span class="nc" id="L5750">            builder.mimeType(&quot;audio/wav&quot;);</span>
        }
<span class="nc" id="L5752">        System.out.println(&quot;in captureAudio &quot; + recordingOptions.isRedirectToAudioBuffer());</span>
<span class="nc" id="L5753">        final AudioRecorderComponent cmp = new AudioRecorderComponent(builder);</span>
<span class="nc" id="L5754">        final Sheet sheet = new Sheet(null, &quot;Record Audio&quot;);</span>
<span class="nc" id="L5755">        sheet.getContentPane().setLayout(new com.codename1.ui.layouts.BorderLayout());</span>
<span class="nc" id="L5756">        sheet.getContentPane().add(com.codename1.ui.layouts.BorderLayout.CENTER, cmp);</span>
<span class="nc" id="L5757">        cmp.addActionListener(new com.codename1.ui.events.ActionListener() {</span>
            @Override
            public void actionPerformed(com.codename1.ui.events.ActionEvent e) {
<span class="nc bnc" id="L5760" title="All 3 branches missed.">                switch (cmp.getState()) {</span>
                    case Accepted:
<span class="nc" id="L5762">                        CN.getCurrentForm().getAnimationManager().flushAnimation(new Runnable() {</span>
                            public void run() {
<span class="nc" id="L5764">                                sheet.back();</span>
<span class="nc" id="L5765">                                sheet.addCloseListener(new ActionListener() {</span>
                                    @Override
                                    public void actionPerformed(ActionEvent evt) {
<span class="nc" id="L5768">                                        sheet.removeCloseListener(this);</span>
<span class="nc" id="L5769">                                        response.actionPerformed(new com.codename1.ui.events.ActionEvent(builder.getPath()));</span>
<span class="nc" id="L5770">                                    }</span>

                                });
<span class="nc" id="L5773">                            }</span>
                        });


<span class="nc" id="L5777">                        break;</span>
                    case Canceled:
<span class="nc" id="L5779">                        FileSystemStorage fs = FileSystemStorage.getInstance();</span>
<span class="nc bnc" id="L5780" title="All 2 branches missed.">                        if (fs.exists(builder.getPath())) {</span>
<span class="nc" id="L5781">                            FileSystemStorage.getInstance().delete(builder.getPath());</span>
                        }
<span class="nc" id="L5783">                        CN.getCurrentForm().getAnimationManager().flushAnimation(new Runnable() {</span>
                            public void run() {
<span class="nc" id="L5785">                                sheet.back();</span>
<span class="nc" id="L5786">                                sheet.addCloseListener(new ActionListener() {</span>
                                    @Override
                                    public void actionPerformed(ActionEvent evt) {
<span class="nc" id="L5789">                                        sheet.removeCloseListener(this);</span>
<span class="nc" id="L5790">                                        response.actionPerformed(new com.codename1.ui.events.ActionEvent(null));</span>
<span class="nc" id="L5791">                                    }</span>

                                });
<span class="nc" id="L5794">                            }</span>
                        });


                        break;
                }
<span class="nc" id="L5800">            }</span>

        });
<span class="nc" id="L5803">        sheet.addCloseListener(new com.codename1.ui.events.ActionListener() {</span>
            @Override
            public void actionPerformed(com.codename1.ui.events.ActionEvent e) {
<span class="nc bnc" id="L5806" title="All 4 branches missed.">                if (cmp.getState() != AudioRecorderComponent.RecorderState.Accepted &amp;&amp; cmp.getState() != AudioRecorderComponent.RecorderState.Canceled) {</span>
<span class="nc" id="L5807">                    FileSystemStorage fs = FileSystemStorage.getInstance();</span>
<span class="nc bnc" id="L5808" title="All 2 branches missed.">                    if (fs.exists(builder.getPath())) {</span>
<span class="nc" id="L5809">                        FileSystemStorage.getInstance().delete(builder.getPath());</span>
                    }
<span class="nc" id="L5811">                    CN.getCurrentForm().getAnimationManager().flushAnimation(new Runnable() {</span>
                        public void run() {
<span class="nc" id="L5813">                            response.actionPerformed(new com.codename1.ui.events.ActionEvent(null));</span>
<span class="nc" id="L5814">                        }</span>
                    });
                }
<span class="nc" id="L5817">            }</span>

        });
<span class="nc" id="L5820">        sheet.show();</span>
        //capture(response, new String[] {&quot;wav&quot;, &quot;mp3&quot;, &quot;aac&quot;}, &quot;*.wav;*.mp3;*.aac&quot;);
<span class="nc" id="L5822">    }</span>

    /**
     * Captures a video and notifies with the data when available
     *
     * @param response callback for the resulting video
     */
    public void captureVideo(ActionListener response) {
<span class="nc" id="L5830">    }</span>

    /**
     * Captures a video, and notifies with the data when available.  This version accepts
     * capture constraints which may be used if the platform supports them.
     *
     * @param constraints Constraints for the capture.
     * @param response    Callback for the resulting video.
     * @see com.codename1.capture.Capture#captureVideo(com.codename1.capture.VideoCaptureConstraints, com.codename1.ui.events.ActionListener)
     * @since 7.0
     */
    public void captureVideo(VideoCaptureConstraints constraints, ActionListener response) {
<span class="nc" id="L5842">        captureVideo(response);</span>
<span class="nc" id="L5843">    }</span>

    /**
     * Checks if the given gallery type is supported on this platform.
     *
     * @param type A gallery type constant.  E.g. {@link CN1Constants#GALLERY_IMAGE}, {@link CN1Constants#GALLERY_VIDEO}, {@link CN1Constants#GALLERY_ALL}, {@link CN1Constants#GALLERY_IMAGE_MULTI}, {@link CN1Constants#GALLERY_VIDEO_MULTI}, {@link CN1Constants#GALLERY_ALL_MULTI}
     * @return True if the gallery type is supported on this platform.
     */
    public boolean isGalleryTypeSupported(int type) {
<span class="nc bnc" id="L5852" title="All 2 branches missed.">        switch (type) {</span>
            case Display.GALLERY_IMAGE:
            case Display.GALLERY_VIDEO:
            case Display.GALLERY_ALL:
<span class="nc" id="L5856">                return true;</span>
        }
<span class="nc" id="L5858">        return false;</span>
    }

    /**
     * Opens the device gallery
     * The method returns immediately and the response will be sent asynchronously
     * to the given ActionListener Object
     * &lt;p&gt;
     * use this in the actionPerformed to retrieve the file path
     * String path = (String) evt.getSource();
     *
     * @param response a callback Object to retrieve the file path
     * @param type     one of the following GALLERY_IMAGE, GALLERY_VIDEO, GALLERY_ALL
     * @throws RuntimeException if this feature failed or unsupported on the platform
     */
    public void openGallery(final ActionListener response, int type) {
<span class="nc bnc" id="L5874" title="All 2 branches missed.">        if (!isGalleryTypeSupported(type)) {</span>
<span class="nc" id="L5875">            throw new IllegalArgumentException(&quot;Gallery type &quot; + type + &quot; not supported on this platform.&quot;);</span>
        }
<span class="nc" id="L5877">        final Dialog d = new Dialog(&quot;Select a picture&quot;);</span>
<span class="nc" id="L5878">        d.setLayout(new BorderLayout());</span>
<span class="nc" id="L5879">        FileTreeModel model = new FileTreeModel(true);</span>
<span class="nc bnc" id="L5880" title="All 2 branches missed.">        if (type == Display.GALLERY_IMAGE) {</span>
<span class="nc" id="L5881">            model.addExtensionFilter(&quot;jpg&quot;);</span>
<span class="nc" id="L5882">            model.addExtensionFilter(&quot;png&quot;);</span>
<span class="nc bnc" id="L5883" title="All 2 branches missed.">        } else if (type == Display.GALLERY_VIDEO) {</span>
<span class="nc" id="L5884">            model.addExtensionFilter(&quot;mp4&quot;);</span>
<span class="nc" id="L5885">            model.addExtensionFilter(&quot;3pg&quot;);</span>
<span class="nc" id="L5886">            model.addExtensionFilter(&quot;avi&quot;);</span>
<span class="nc" id="L5887">            model.addExtensionFilter(&quot;mov&quot;);</span>
<span class="nc bnc" id="L5888" title="All 2 branches missed.">        } else if (type == Display.GALLERY_ALL) {</span>
<span class="nc" id="L5889">            model.addExtensionFilter(&quot;jpg&quot;);</span>
<span class="nc" id="L5890">            model.addExtensionFilter(&quot;png&quot;);</span>
<span class="nc" id="L5891">            model.addExtensionFilter(&quot;mp4&quot;);</span>
<span class="nc" id="L5892">            model.addExtensionFilter(&quot;3pg&quot;);</span>
<span class="nc" id="L5893">            model.addExtensionFilter(&quot;avi&quot;);</span>
<span class="nc" id="L5894">            model.addExtensionFilter(&quot;mov&quot;);</span>
        }

<span class="nc" id="L5897">        FileTree t = new FileTree(model) {</span>

            protected Button createNodeComponent(final Object node, int depth) {
<span class="nc bnc" id="L5900" title="All 4 branches missed.">                if (node == null || !getModel().isLeaf(node)) {</span>
<span class="nc" id="L5901">                    return super.createNodeComponent(node, depth);</span>
                }
<span class="nc" id="L5903">                Hashtable t = (Hashtable) Storage.getInstance().readObject(&quot;thumbnails&quot;);</span>
<span class="nc bnc" id="L5904" title="All 2 branches missed.">                if (t == null) {</span>
<span class="nc" id="L5905">                    t = new Hashtable();</span>
                }
<span class="nc" id="L5907">                final Hashtable thumbs = t;</span>
<span class="nc" id="L5908">                final Button b = super.createNodeComponent(node, depth);</span>
<span class="nc" id="L5909">                b.addActionListener(new ActionListener() {</span>

                    public void actionPerformed(ActionEvent evt) {
<span class="nc" id="L5912">                        response.actionPerformed(new ActionEvent(node, ActionEvent.Type.Other));</span>
<span class="nc" id="L5913">                        d.dispose();</span>
<span class="nc" id="L5914">                    }</span>
                });
<span class="nc" id="L5916">                final ImageIO imageio = ImageIO.getImageIO();</span>
<span class="nc bnc" id="L5917" title="All 2 branches missed.">                if (imageio != null) {</span>

<span class="nc" id="L5919">                    Display.getInstance().scheduleBackgroundTask(new Runnable() {</span>

                        public void run() {
<span class="nc" id="L5922">                            byte[] data = (byte[]) thumbs.get(node);</span>
<span class="nc bnc" id="L5923" title="All 2 branches missed.">                            if (data == null) {</span>
<span class="nc" id="L5924">                                ByteArrayOutputStream out = new ByteArrayOutputStream();</span>
                                try {
<span class="nc" id="L5926">                                    imageio.save(FileSystemStorage.getInstance().openInputStream((String) node),</span>
                                            out,
                                            ImageIO.FORMAT_JPEG,
<span class="nc" id="L5929">                                            b.getIcon().getWidth(), b.getIcon().getHeight(), 1);</span>
<span class="nc" id="L5930">                                    data = out.toByteArray();</span>
<span class="nc" id="L5931">                                    thumbs.put(node, data);</span>
<span class="nc" id="L5932">                                    Storage.getInstance().writeObject(&quot;thumbnails&quot;, thumbs);</span>
<span class="nc" id="L5933">                                } catch (IOException ex) {</span>
<span class="nc" id="L5934">                                    Log.e(ex);</span>
<span class="nc" id="L5935">                                }</span>
                            }
<span class="nc" id="L5937">                            Image im = Image.createImage(data, 0, data.length);</span>
<span class="nc" id="L5938">                            b.setIcon(im);</span>
<span class="nc" id="L5939">                        }</span>
                    });

                }
<span class="nc" id="L5943">                return b;</span>
            }

        };

<span class="nc" id="L5948">        d.addComponent(BorderLayout.CENTER, t);</span>

<span class="nc" id="L5950">        d.placeButtonCommands(new Command[]{new Command(&quot;Cancel&quot;)});</span>
<span class="nc" id="L5951">        Command c = d.showAtPosition(2, 2, 2, 2, true);</span>
<span class="nc bnc" id="L5952" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L5953">            response.actionPerformed(null);</span>
        }

<span class="nc" id="L5956">    }</span>

    /**
     * Opens the device image gallery
     *
     * @param response callback for the resulting image
     */
    public void openImageGallery(final ActionListener response) {
<span class="nc" id="L5964">        openGallery(response, Display.GALLERY_IMAGE);</span>
<span class="nc" id="L5965">    }</span>

    /**
     * Returns a 2-3 letter code representing the platform name for the platform override
     *
     * @return the name of the platform e.g. ios, rim, win, and, me
     */
    public abstract String getPlatformName();

    /**
     * Returns the suffixes for ovr files that should be used when loading a layered resource file on this platform
     *
     * @return a string array with the proper order of resource override layers
     */
    public String[] getPlatformOverrides() {
<span class="nc" id="L5980">        return new String[0];</span>
    }

    /**
     * This callback allows highly broken devices like the blackberry to automatically detect the network
     * type
     */
    public boolean shouldAutoDetectAccessPoint() {
<span class="fc" id="L5988">        return false;</span>
    }

    /**
     * Gets all of the contacts that are linked to this contact.  Some platforms, like iOS, allow for multiple distinct contact records to be &quot;linked&quot; to indicate that they refer to the same person.
     *
     * Implementations should override the {@link #getLinkedContactIds(com.codename1.contacts.Contact) } method.
     * @param c The contact whose &quot;linked&quot; contacts are to be retrieved.
     * @return Array of Contacts.  Should never be null, but may be a zero-sized array.
     * @see com.codename1.contacts.ContactsManager#getLinkedContacts(com.codename1.contacts.Contact)
     *
     */
    //public final Contact[] getLinkedContacts(Contact c) {
    //    String[] ids = getLinkedContactIds(c);
    //    if (ids != null) {
    //        Contact[] out = new Contact[ids.length];
    //        int len = ids.length;
    //        for (int i=0; i&lt; len; i++) {
    //            out[i] = getContactById(ids[i]);
    //        }
    //        return out;
    //    }
    //    return new Contact[0];
    //}

    /**
     * Send an email using the platform mail client
     *
     * @param recipients array of e-mail addresses
     * @param subject    e-mail subject
     * @param msg        the Message to send
     */
    public void sendMessage(String[] recipients, String subject, Message msg) {
<span class="nc" id="L6021">    }</span>

    /**
     * Opens the device Dialer application with the given phone number
     *
     * @param phoneNumber
     */
    public void dial(String phoneNumber) {
<span class="nc" id="L6029">    }</span>

    /**
     * Sends a SMS message to the given phone number
     *
     * @param phoneNumber to send the sms
     * @param message     the content of the sms
     * @throws IOException if for some reason sending failed
     */
    public void sendSMS(String phoneNumber, String message, boolean interactive) throws IOException {
<span class="nc" id="L6039">    }</span>

    /**
     * Indicates the level of SMS support in the platform as one of: SMS_NOT_SUPPORTED (for desktop, tablet etc.),
     * SMS_SEAMLESS (no UI interaction), SMS_INTERACTIVE (with compose UI), SMS_BOTH.
     *
     * @return one of the SMS_* values
     */
    public int getSMSSupport() {
<span class="nc" id="L6048">        return Display.SMS_SEAMLESS;</span>
    }

    /**
     * Returns an image representing the application icon, or null if not supported. This is used on
     * Android to support the title bar icon
     */
    public Image getApplicationIconImage() {
<span class="nc" id="L6056">        InputStream i = getResourceAsStream(getClass(), &quot;/icon.png&quot;);</span>
<span class="nc bnc" id="L6057" title="All 2 branches missed.">        if (i != null) {</span>
            try {
<span class="nc" id="L6059">                return EncodedImage.create(i);</span>
<span class="nc" id="L6060">            } catch (IOException ex) {</span>
<span class="nc" id="L6061">                Log.e(ex);</span>
            }
        }
<span class="nc" id="L6064">        return null;</span>
    }

    /**
     * Gets all contacts from the address book of the device
     *
     * @param withNumbers if true returns only contacts that has a number
     * @return array of contacts unique ids
     */
    public String[] getAllContacts(boolean withNumbers) {
<span class="nc" id="L6074">        return null;</span>
    }

    /**
     * Gets the IDs of all contacts that are linked to the provided contact.
     *
     * @param c The contact
     * @return Array of IDs for contacts that are linked to {@code c}.
     */
    public String[] getLinkedContactIds(Contact c) {
<span class="nc bnc" id="L6084" title="All 4 branches missed.">        if (c == null || c.getId() == null) {</span>
<span class="nc" id="L6085">            return new String[0];</span>
        }
<span class="nc" id="L6087">        return new String[]{c.getId()};</span>
    }

    /**
     * Get a Contact according to it's contact id.
     *
     * @param id unique id of the Contact
     * @return a Contact Object
     */
    public Contact getContactById(String id) {
<span class="nc" id="L6097">        return null;</span>
    }

    /**
     * Notice: this method might be very slow and should be invoked on a separate thread!
     * It might have platform specific optimizations over getAllContacts followed by looping
     * over individual contacts but that isn't guaranteed. See isGetAllContactsFast for
     * information.
     *
     * @param withNumbers      if true returns only contacts that has a number
     * @param includesFullName if true try to fetch the full name of the Contact(not just display name)
     * @param includesPicture  if true try to fetch the Contact Picture if exists
     * @param includesNumbers  if true try to fetch all Contact numbers
     * @param includesEmail    if true try to fetch all Contact Emails
     * @param includeAddress   if true try to fetch all Contact Addresses
     * @return array of the contacts
     */
    public Contact[] getAllContacts(boolean withNumbers, boolean includesFullName, boolean includesPicture, boolean includesNumbers, boolean includesEmail, boolean includeAddress) {
<span class="nc" id="L6115">        String[] arr = getAllContacts(withNumbers);</span>
<span class="nc bnc" id="L6116" title="All 2 branches missed.">        if (arr == null) {</span>
<span class="nc" id="L6117">            return null;</span>
        }
<span class="nc" id="L6119">        Contact[] retVal = new Contact[arr.length];</span>
<span class="nc" id="L6120">        int alen = arr.length;</span>
<span class="nc bnc" id="L6121" title="All 2 branches missed.">        for (int iter = 0; iter &lt; alen; iter++) {</span>
<span class="nc" id="L6122">            retVal[iter] = getContactById(arr[iter], includesFullName, includesPicture, includesNumbers, includesEmail, includeAddress);</span>
        }
<span class="nc" id="L6124">        return retVal;</span>
    }

    /**
     * Indicates if the getAllContacts is platform optimized, notice that the method
     * might still take seconds or more to run so you should still use a separate thread!
     *
     * @return true if getAllContacts will perform faster that just getting each contact
     */
    public boolean isGetAllContactsFast() {
<span class="nc" id="L6134">        return false;</span>
    }

    /**
     * This method returns a Contact by the contact id and fills it's data
     * according to the given flags
     *
     * @param id               of the Contact
     * @param includesFullName if true try to fetch the full name of the Contact(not just display name)
     * @param includesPicture  if true try to fetch the Contact Picture if exists
     * @param includesNumbers  if true try to fetch all Contact numbers
     * @param includesEmail    if ture try to fetch all Contact Emails
     * @param includeAddress   if ture try to fetch all Contact Addresses
     * @return a Contact Object
     */
    public Contact getContactById(String id, boolean includesFullName, boolean includesPicture,
                                  boolean includesNumbers, boolean includesEmail, boolean includeAddress) {
<span class="nc" id="L6151">        return null;</span>
    }

    /**
     * Create a contact to the device contacts book
     *
     * @param firstName   the Contact firstName
     * @param surname     the Contact familyName
     * @param officePhone the Contact work phone or null
     * @param homePhone   the Contact home phone or null
     * @param cellPhone   the Contact mobile phone or null
     * @param email       the Contact email or null
     * @return the contact id if creation succeeded or null  if failed
     */
    public String createContact(String firstName, String surname, String officePhone, String homePhone, String cellPhone, String email) {
<span class="nc" id="L6166">        return null;</span>
    }

    /**
     * Some platforms allow the user to block contacts access on a per application basis (specifically iOS).
     *
     * @return true if contacts access is allowed or globally available, false otherwise
     */
    public boolean isContactsPermissionGranted() {
<span class="nc" id="L6175">        return true;</span>
    }

    /**
     * removed a contact from the device contacts book
     *
     * @param id the contact id to remove
     * @return true if deletion succeeded false otherwise
     */
    public boolean deleteContact(String id) {
<span class="nc" id="L6185">        return false;</span>
    }

    /**
     * Indicates if the underlying platform supports sharing capabilities
     *
     * @return true if the underlying platform handles share.
     */
    public boolean isNativeShareSupported() {
<span class="nc" id="L6194">        return false;</span>
    }

    /**
     * Share the required information using the platform sharing services.
     * a Sharing service can be: mail, sms, facebook, twitter,...
     * This method is implemented if isNativeShareSupported() returned true for
     * a specific platform.
     *
     * @param text     String to share.
     * @param image    file path to the image or null
     * @param mimeType type of the image or null if no image to share
     */
    public void share(String text, String image, String mimeType) {
<span class="nc" id="L6208">        share(text, image, mimeType, null);</span>
<span class="nc" id="L6209">    }</span>

    /**
     * Share the required information using the platform sharing services.
     * a Sharing service can be: mail, sms, facebook, twitter,...
     * This method is implemented if isNativeShareSupported() returned true for
     * a specific platform.
     *
     * @param text       String to share.
     * @param image      file path to the image or null
     * @param mimeType   type of the image or null if no image to share
     * @param sourceRect The bounds of the button that was clicked to initiate
     *                   the share.  This is used by some platforms (e.g. iPad2 on iOS 8 or
     *                   higher) to dictate where the popover dialog should be placed.
     */
    public void share(String text, String image, String mimeType, Rectangle sourceRect) {

<span class="nc" id="L6226">    }</span>

    // BEGIN TRANSFORMATION METHODS---------------------------------------------------------

    /**
     * Called before internal paint of component starts
     *
     * @param c the component about to be painted
     */
    public void beforeComponentPaint(Component c, Graphics g) {
<span class="fc" id="L6236">    }</span>

    /**
     * Called after internal paint of component finishes
     *
     * @param c the component that was painted
     */
    public void afterComponentPaint(Component c, Graphics g) {
<span class="fc" id="L6244">    }</span>

    /**
     * Indicates to the port that the component won't be painted due to clipping
     *
     * @param c the component that won't be painted
     */
    public void nothingWithinComponentPaint(Component c) {
<span class="fc" id="L6252">    }</span>

    /**
     * Indicates to the port that the component was removed from the view and its
     * UI should be removed in the next flush operation.
     *
     * @param c the removed component.
     */
    public void componentRemoved(Component c) {
<span class="fc" id="L6261">    }</span>

    /**
     * {@inheritDoc}
     */
    public abstract L10NManager getLocalizationManager();

    /**
     * Returns the package name for the application
     */
    protected String getPackageName() {
<span class="nc bnc" id="L6272" title="All 2 branches missed.">        if (packageName == null) {</span>
<span class="nc" id="L6273">            return Display.getInstance().getProperty(&quot;package_name&quot;, null);</span>
        }
<span class="nc" id="L6275">        return packageName;</span>
    }

    /**
     * Checks if the Transform class can be used on this platform.  This is similar to
     * {@link #isTransformSupported(java.lang.Object)} but it is more general as it only verifies
     * that transforms can be performed, but not necessarily that they will be respected
     * by any particular graphics context.
     *
     * @return True if this platform supports transforms.
     * @see #isTransformSupported(java.lang.Object)
     */
    public boolean isTransformSupported() {
<span class="nc" id="L6288">        return false;</span>
    }

    /**
     * Checks of the Transform class can be used on this platform to perform perspective transforms.
     * This is similar to
     * {@link #isPerspectiveTransformSupported(java.lang.Object)} but it is more general as it only verifies
     * that transforms can be performed, but not necessarily that they will be respected
     * by any particular graphics context.
     *
     * @return True if this platform supports perspective transforms.
     */
    public boolean isPerspectiveTransformSupported() {
<span class="nc" id="L6301">        return false;</span>
    }

    public boolean transformEqualsImpl(Transform t1, Transform t2) {
<span class="fc" id="L6305">        Object o1 = null;</span>
<span class="pc bpc" id="L6306" title="1 of 2 branches missed.">        if (t1 != null) {</span>
<span class="fc" id="L6307">            o1 = t1.getNativeTransform();</span>
        }
<span class="fc" id="L6309">        Object o2 = null;</span>
<span class="pc bpc" id="L6310" title="1 of 2 branches missed.">        if (t2 != null) {</span>
<span class="fc" id="L6311">            o2 = t2.getNativeTransform();</span>
        }
<span class="fc" id="L6313">        return transformNativeEqualsImpl(o1, o2);</span>
    }

    public boolean transformNativeEqualsImpl(Object t1, Object t2) {
<span class="nc" id="L6317">        throw new RuntimeException(&quot;Transforms not supported&quot;);</span>
    }

    /**
     * Makes a new native translation transform.  Each implementation can decide the format
     * to use internally for transforms.  This should return a transform in that internal format.
     * This is used by the {@link com.codename1.ui.Transform} class.
     * &lt;p&gt;This can only be used if {@link #isTransformSupported()} returns true.&lt;/p&gt;
     *
     * @param translateX The x-coordinate of the translation.
     * @param translateY The y-coordinate of the translation.
     * @param translateZ The z-coordinate of the translation.
     * @return A native transform object encapsulating the specified translation.
     * @see #isTransformSupported()
     */
    public Object makeTransformTranslation(float translateX, float translateY, float translateZ) {
<span class="nc" id="L6333">        throw new RuntimeException(&quot;Transforms not supported&quot;);</span>
    }

    public void setTransformTranslation(Object nativeTransform, float translateX, float translateY, float translateZ) {
<span class="nc" id="L6337">        setTransformIdentity(nativeTransform);</span>
<span class="nc" id="L6338">        transformTranslate(nativeTransform, translateX, translateY, translateZ);</span>
<span class="nc" id="L6339">    }</span>

    /**
     * Makes a new native scale transform.  Each implementation can decide the format
     * to use internally for transforms.  This should return a transform in that internal format.
     * This is used by the {@link com.codename1.ui.Transform} class.
     * &lt;p&gt;This can only be used if {@link #isTransformSupported()} returns true.&lt;/p&gt;
     *
     * @param scaleX The x-scale factor of the transform.
     * @param scaleY The y-scale factor of the transform.
     * @param scaleZ The z-scale factor of the transform.
     * @return A native transform object encapsulating the specified scale.
     * @see #isTransformSupported()
     */
    public Object makeTransformScale(float scaleX, float scaleY, float scaleZ) {
<span class="nc" id="L6354">        throw new RuntimeException(&quot;Transforms not supported&quot;);</span>
    }

    /**
     * Makes a transform given the specified AffineTransform values.
     *
     * @param m00 the X coordinate scaling element of the 3x3 matrix
     * @param m10 the Y coordinate shearing element of the 3x3 matrix
     * @param m01 the X coordinate shearing element of the 3x3 matrix
     * @param m11 the Y coordinate scaling element of the 3x3 matrix
     * @param m02 the X coordinate translation element of the 3x3 matrix
     * @param m12 the Y coordinate translation element of the 3x3 matrix
     * @return
     * @since 7.0
     */
    public Object makeTransformAffine(double m00,
                                      double m10,
                                      double m01,
                                      double m11,
                                      double m02,
                                      double m12) {
<span class="nc" id="L6375">        throw new RuntimeException(&quot;Transforms not supported&quot;);</span>
    }

    /**
     * Sets transform to the given specified AffineTransform values.
     *
     * @param nativeTransform Platform-specific native transform.
     * @param m00             the X coordinate scaling element of the 3x3 matrix
     * @param m10             the Y coordinate shearing element of the 3x3 matrix
     * @param m01             the X coordinate shearing element of the 3x3 matrix
     * @param m11             the Y coordinate scaling element of the 3x3 matrix
     * @param m02             the X coordinate translation element of the 3x3 matrix
     * @param m12             the Y coordinate translation element of the 3x3 matrix
     * @since 7.0
     */
    public void setTransformAffine(Object nativeTransform, double m00,
                                   double m10,
                                   double m01,
                                   double m11,
                                   double m02,
                                   double m12) {
<span class="nc" id="L6396">        throw new RuntimeException(&quot;Transforms not supported&quot;);</span>
    }

    public void setTransformScale(Object nativeTransform, float scaleX, float scaleY, float scaleZ) {
<span class="nc" id="L6400">        setTransformIdentity(nativeTransform);</span>
<span class="nc" id="L6401">        transformScale(nativeTransform, scaleX, scaleY, scaleZ);</span>
<span class="nc" id="L6402">    }</span>

    /**
     * Makes a new native rotation transform.  Each implementation can decide the format
     * to use internally for transforms.  This should return a transform in that internal format.
     * This is used by the {@link com.codename1.ui.Transform} class.
     * &lt;p&gt;This can only be used if {@link #isTransformSupported()} returns true.&lt;/p&gt;
     *
     * @param angle The angle to rotate.
     * @param x     The x-component of the vector around which to rotate.
     * @param y     The y-component of the vector around which to rotate.
     * @param z     The z-component of the vector around which to rotate.
     * @return A native transform object encapsulating the specified rotation.
     * @see #isTransformSupported()
     */
    public Object makeTransformRotation(float angle, float x, float y, float z) {
<span class="nc" id="L6418">        throw new RuntimeException(&quot;Transforms not supported&quot;);</span>
    }

    public void setTransformRotation(Object nativeTransform, float angle, float x, float y, float z) {
<span class="nc" id="L6422">        setTransformIdentity(nativeTransform);</span>
<span class="nc" id="L6423">        transformRotate(nativeTransform, angle, x, y, z);</span>
<span class="nc" id="L6424">    }</span>

    /**
     * Makes a new perspective transform. Each implementation can decide the format
     * to use internally for transforms.  This should return a transform in that internal format.
     * This is used by the {@link com.codename1.ui.Transform} class.
     * &lt;p&gt;This can only be used if {@link #isPerspectiveTransformSupported()} returns true.&lt;/p&gt;
     *
     * @param fovy   The y field of view angle.
     * @param aspect The aspect ratio.
     * @param zNear  The nearest visible z coordinate.
     * @param zFar   The farthest z coordinate.
     * @return A native transform object encapsulating the given perspective.
     * @see #isPerspectiveTransformSupported()
     */
    public Object makeTransformPerspective(float fovy, float aspect, float zNear, float zFar) {
<span class="nc" id="L6440">        throw new RuntimeException(&quot;Transforms not supported&quot;);</span>
    }

    public void setTransformPerspective(Object nativeTransform, float fovy, float aspect, float zNear, float zFar) {
<span class="nc" id="L6444">        Object persp = makeTransformPerspective(fovy, aspect, zNear, zFar);</span>
<span class="nc" id="L6445">        copyTransform(persp, nativeTransform);</span>
<span class="nc" id="L6446">    }</span>

    /**
     * Makes a new orthographic projection transform.  Each implementation can decide the format
     * to use internally for transforms.  This should return a transform in that internal format.
     * This is used by the {@link com.codename1.ui.Transform} class.
     * &lt;p&gt;This can only be used if {@link #isPerspectiveTransformSupported()} returns true.&lt;/p&gt;
     *
     * @param left   x-coordinate that is the left edge of the view.
     * @param right  The x-coordinate that is the right edge of the view.
     * @param bottom The y-coordinate that is the bottom edge of the view.
     * @param top    The y-coordinate that is the top edge of the view.
     * @param near   The nearest visible z-coordinate.
     * @param far    The farthest visible z-coordinate.
     * @return A native transform with the provided orthographic projection.
     * @see #isPerspectiveTransformSupported()
     */
    public Object makeTransformOrtho(float left, float right, float bottom, float top, float near, float far) {
<span class="nc" id="L6464">        throw new RuntimeException(&quot;Transforms not supported&quot;);</span>
    }

    public void setTransformOrtho(Object nativeTransform, float left, float right, float bottom, float top, float near, float far) {
<span class="nc" id="L6468">        Object ortho = makeTransformOrtho(left, right, bottom, top, near, far);</span>
<span class="nc" id="L6469">        copyTransform(ortho, nativeTransform);</span>
<span class="nc" id="L6470">    }</span>

    /**
     * Makes a transform to simulate a camera's perspective at a given location. Each implementation can decide the format
     * to use internally for transforms.  This should return a transform in that internal format.
     * This is used by the {@link com.codename1.ui.Transform} class.
     * &lt;p&gt;This can only be used if {@link #isTransformSupported()} returns true.&lt;/p&gt;
     *
     * @param eyeX    The x-coordinate of the camera's eye.
     * @param eyeY    The y-coordinate of the camera's eye.
     * @param eyeZ    The z-coordinate of the camera's eye.
     * @param centerX The center x coordinate of the view.
     * @param centerY The center y coordinate of the view.
     * @param centerZ The center z coordinate of the view.
     * @param upX     The x-coordinate of the up vector for the camera.
     * @param upY     The y-coordinate of the up vector for the camera.
     * @param upZ     The z-coordinate of the up vector for the camera.
     * @return A native transform with the provided camera's view perspective.
     * @see #isPerspectiveTransformSupported()
     */
    public Object makeTransformCamera(float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ) {
<span class="nc" id="L6491">        throw new RuntimeException(&quot;Transforms not supported&quot;);</span>
    }

    public void setTransformCamera(Object nativeTransform, float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ) {
<span class="nc" id="L6495">        Object cam = makeTransformCamera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);</span>
<span class="nc" id="L6496">        copyTransform(cam, nativeTransform);</span>
<span class="nc" id="L6497">    }</span>

    /**
     * Rotates the provided  transform.
     *
     * @param nativeTransform The transform to rotate. Each implementation can decide the format
     *                        to use internally for transforms.  This should return a transform in that internal format.
     *                        This is used by the {@link com.codename1.ui.Transform} class.
     *                        &lt;p&gt;This can only be used if {@link #isTransformSupported()} returns true.&lt;/p&gt;
     * @param angle           The angle to rotate.
     * @param x               The x-coordinate of the vector around which to rotate.
     * @param y               The y-coordinate of the vector around which to rotate.
     * @param z               The z-coordinate of the vector around which to rotate.
     * @see #isTransformSupported()
     */
    public void transformRotate(Object nativeTransform, float angle, float x, float y, float z) {
<span class="nc" id="L6513">        Object rot = makeTransformRotation(angle, x, y, z);</span>
<span class="nc" id="L6514">        concatenateTransform(nativeTransform, rot);</span>
<span class="nc" id="L6515">    }</span>

    /**
     * Translates the transform by the specified amounts.
     * with the specified translation.
     *
     * @param nativeTransform The native transform to translate. Each implementation can decide the format
     *                        to use internally for transforms.  This should return a transform in that internal format.
     *                        This is used by the {@link com.codename1.ui.Transform} class.
     *                        &lt;p&gt;This can only be used if {@link #isTransformSupported()} returns true.&lt;/p&gt;
     * @param x               The x translation.
     * @param y               The y translation.
     * @param z               The z translation.
     * @see #isTransformSupported()
     */
    public void transformTranslate(Object nativeTransform, float x, float y, float z) {
<span class="nc" id="L6531">        Object tr = makeTransformTranslation(x, y, z);</span>
<span class="nc" id="L6532">        concatenateTransform(nativeTransform, tr);</span>
<span class="nc" id="L6533">    }</span>

    /**
     * Scales the provided transform by the provide scale factors.
     *
     * @param nativeTransform Each implementation can decide the format
     *                        to use internally for transforms.  This should return a transform in that internal format.
     *                        This is used by the {@link com.codename1.ui.Transform} class.
     *                        &lt;p&gt;This can only be used if {@link #isTransformSupported()} returns true.&lt;/p&gt;
     * @param x               The x-scale factor
     * @param y               The y-scale factor
     * @param z               The z-scale factor
     * @see #isTransformSupported()
     */
    public void transformScale(Object nativeTransform, float x, float y, float z) {
<span class="nc" id="L6548">        Object scale = makeTransformScale(x, y, z);</span>
<span class="nc" id="L6549">        concatenateTransform(nativeTransform, scale);</span>
<span class="nc" id="L6550">    }</span>

    /**
     * Gets the inverse transformation for the provided transform.
     *
     * @param nativeTransform The native transform of which to make the inverse.  Each implementation can decide the format
     *                        to use internally for transforms.  This should return a transform in that internal format.
     *                        This is used by the {@link com.codename1.ui.Transform} class.
     *                        &lt;p&gt;This can only be used if {@link #isTransformSupported()} returns true.&lt;/p&gt;
     * @return The inverse transform as a native transform object.  Each implementation can decide the format
     * to use internally for transforms.  This should return a transform in that internal format.
     * This is used by the {@link com.codename1.ui.Transform} class.
     * @see #isTransformSupported()
     */
    public Object makeTransformInverse(Object nativeTransform) {
<span class="nc" id="L6565">        throw new RuntimeException(&quot;Transforms not supported&quot;);</span>
    }

    public void setTransformInverse(Object nativeTransform) throws Transform.NotInvertibleException {
<span class="nc" id="L6569">        copyTransform(makeTransformInverse(nativeTransform), nativeTransform);</span>
<span class="nc" id="L6570">    }</span>

    /**
     * Makes a new identity native transform. Each implementation can decide the format
     * to use internally for transforms.  This should return a transform in that internal format.
     * This is used by the {@link com.codename1.ui.Transform} class.
     * &lt;p&gt;This can only be used if {@link #isTransformSupported()} returns true.&lt;/p&gt;
     *
     * @return An identity native transform.
     * @see #isTransformSupported()
     */
    public Object makeTransformIdentity() {
<span class="nc" id="L6582">        throw new RuntimeException(&quot;Transforms not supported&quot;);</span>
    }

    /**
     * Sets the given native transform to the identiy transform
     *
     * @param transform
     */
    public void setTransformIdentity(Object transform) {
<span class="nc" id="L6591">        copyTransform(makeTransformIdentity(), transform);</span>
<span class="nc" id="L6592">    }</span>

    /**
     * Copies the setting of one transform into another.  Each implementation can decide the format
     * to use internally for transforms.  This should return a transform in that internal format.
     * This is used by the {@link com.codename1.ui.Transform} class.
     * &lt;p&gt;This can only be used if {@link #isTransformSupported()} returns true.&lt;/p&gt;
     *
     * @param src  The source native transform.
     * @param dest The destination native transform.
     * @see #isTransformSupported()
     */
    public void copyTransform(Object src, Object dest) {
<span class="nc" id="L6605">        throw new RuntimeException(&quot;Transforms not supported&quot;);</span>
    }

    /**
     * Concatenates two transforms and sets the first transform to be the result of the concatenation.
     * &lt;p&gt;This can only be used if {@link #isTransformSupported()} returns true.&lt;/p&gt;
     *
     * @param t1 The left native transform.  The result will also be stored in this transform.
     * @param t2 The right native transform.
     * @see #isTransformSupported()
     */
    public void concatenateTransform(Object t1, Object t2) {
<span class="nc" id="L6617">        throw new RuntimeException(&quot;Transforms not supported&quot;);</span>
    }

    // END TRANSFORMATION METHODS-------------------------------------------------------------------- 

    /**
     * Transforms a point and stores the result in a provided array.
     *
     * @param nativeTransform The native transform to use for the transformation. Each implementation can decide the format
     *                        to use internally for transforms.  This should return a transform in that internal format.
     *                        &lt;p&gt;This can only be used if {@link #isTransformSupported()} returns true.&lt;/p&gt;
     *                        This is used by the {@link com.codename1.ui.Transform} class.
     * @param in              A 2 or 3 element array representing either an (x,y) or (x,y,z) tuple to be transformed.
     * @param out             A 2 or 3 element array (length should match {@var in}) to store the result of the transformation.
     * @see #isTransformSupported()
     */
    public void transformPoint(Object nativeTransform, float[] in, float[] out) {
<span class="nc" id="L6634">        throw new RuntimeException(&quot;Transforms not supported&quot;);</span>
    }

    /**
     * Transforms a set of points using the provided transform.
     *
     * @param nativeTransform The transform to use for transforming the points
     * @param pointSize       The size of the points (either 2 or 3)
     * @param in              Input array of points.
     * @param srcPos          The start position of the input array
     * @param out             The output array of points
     * @param destPos         The start position of the output array.
     * @param numPoints       The number of points to transform.
     */
    public void transformPoints(Object nativeTransform, int pointSize, float[] in, int srcPos, float[] out, int destPos, int numPoints) {
<span class="nc" id="L6649">        float[] bufIn = new float[pointSize];</span>
<span class="nc" id="L6650">        float[] bufOut = new float[pointSize];</span>
<span class="nc" id="L6651">        int len = numPoints * pointSize;</span>
<span class="nc bnc" id="L6652" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i += pointSize) {</span>
<span class="nc" id="L6653">            System.arraycopy(in, srcPos + i, bufIn, 0, pointSize);</span>
<span class="nc" id="L6654">            transformPoint(nativeTransform, bufIn, bufOut);</span>
<span class="nc" id="L6655">            System.arraycopy(bufOut, 0, out, destPos + i, pointSize);</span>
        }
<span class="nc" id="L6657">    }</span>

    /**
     * Translates a set of points.
     *
     * @param pointSize The size of each point (2 or 3)
     * @param tX        Size of translation along x-axis
     * @param tY        Size of translation along y-axis
     * @param tZ        Size of translation along z-axis (only used if pointSize == 3)
     * @param in        Input array of points.
     * @param srcPos    Start position in input array
     * @param out       Output array of points
     * @param destPos   Start position in output array
     * @param numPoints Number of points to translate.
     */
    public void translatePoints(int pointSize, float tX, float tY, float tZ, float[] in, int srcPos, float[] out, int destPos, int numPoints) {
<span class="fc" id="L6673">        int len = numPoints * pointSize;</span>
<span class="fc bfc" id="L6674" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i += pointSize) {</span>
<span class="fc" id="L6675">            int d0 = destPos + i;</span>
<span class="fc" id="L6676">            int s0 = srcPos + i;</span>
<span class="fc" id="L6677">            out[d0++] = in[s0++] + tX;</span>
<span class="fc" id="L6678">            out[d0++] = in[s0++] + tY;</span>
<span class="pc bpc" id="L6679" title="1 of 2 branches missed.">            if (pointSize &gt; 2) {</span>
<span class="nc" id="L6680">                out[d0] = in[s0] + tZ;</span>
            }
        }
<span class="fc" id="L6683">    }</span>

    /**
     * Scales a set of points.
     *
     * @param pointSize The size of each point (2 or 3)
     * @param sX        Scale factor along x-axis
     * @param sY        Scale factor along y-axis
     * @param sZ        Scale factor along z-axis (only used if pointSize == 3)
     * @param in        Input array of points.
     * @param srcPos    Start position in input array
     * @param out       Output array of points
     * @param destPos   Start position in output array
     * @param numPoints Number of points to translate.
     */
    public void scalePoints(int pointSize, float sX, float sY, float sZ, float[] in, int srcPos, float[] out, int destPos, int numPoints) {
<span class="fc" id="L6699">        int len = numPoints * pointSize;</span>
<span class="fc bfc" id="L6700" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i += pointSize) {</span>
<span class="fc" id="L6701">            int d0 = destPos + i;</span>
<span class="fc" id="L6702">            int s0 = srcPos + i;</span>
<span class="fc" id="L6703">            out[d0++] = in[s0++] * sX;</span>
<span class="fc" id="L6704">            out[d0++] = in[s0++] * sY;</span>
<span class="pc bpc" id="L6705" title="1 of 2 branches missed.">            if (pointSize &gt; 2) {</span>
<span class="nc" id="L6706">                out[d0] = in[s0] * sZ;</span>
            }
        }
<span class="fc" id="L6709">    }</span>

    /**
     * Clears the addressbook cache.  This is only necessary on iOS since its AddressBookRef is transactional.
     */
    public void refreshContacts() {

<span class="nc" id="L6716">    }</span>

    /**
     * Sets the given transform to the current transform in the given graphics object.
     *
     * @param nativeGraphics
     * @param t
     */
    public void getTransform(Object nativeGraphics, Transform t) {
<span class="nc" id="L6725">        t.setIdentity();</span>
<span class="nc" id="L6726">    }</span>

    public boolean isScrollWheeling() {
<span class="fc" id="L6729">        return false;</span>
    }

    /**
     * Blocks or enables copy and paste in the entire app.
     *
     * @param blockCopyPaste True to block copy and paste.  False to enable it.
     */
    public void blockCopyPaste(boolean blockCopyPaste) {

<span class="nc" id="L6739">    }</span>

    /**
     * Checks if this platform supports custom database paths.  On platforms
     * where this returns {@literal true}, {@link #openOrCreateDB(java.lang.String) }
     * will accept a file path (starting with &quot;file://&quot;
     *
     * @return True if platform supports custom paths.
     */
    public boolean isDatabaseCustomPathSupported() {
<span class="nc" id="L6749">        return false;</span>
    }

    /**
     * Attempt to enter full-screen mode.  Should be overridden by the
     * platform implementation.
     *
     * @return True if already in full-screen mode, or successfully entered full-screen mode.
     */
    public boolean requestFullScreen() {
<span class="nc" id="L6759">        return false;</span>
    }

    /**
     * Exit full-screen mode.
     *
     * @return True if already not in full-screen mode or successfully exited full-screen mode.
     */
    public boolean exitFullScreen() {
<span class="nc" id="L6768">        return false;</span>
    }

    /**
     * Checks to see if the app is currently running in full-screen mode.
     *
     * @return True if the app is currently running in full-screen mode.
     */
    public boolean isInFullScreenMode() {
<span class="nc" id="L6777">        return false;</span>
    }

    /**
     * Checks if the platform supports full-screen mode.  If this returns true
     * then a call to {@link #requestFullScreen() } should enter full-screen mode.
     *
     * @return
     */
    public boolean isFullScreenSupported() {
<span class="fc" id="L6787">        return false;</span>
    }

    /**
     * Initializes text selection.  This provides an opportunity for the native
     * platform to register listeners on text selection to ensure that it works.
     * &lt;p&gt;
     * Implementations that implement this method should also implement {@link #deinitializeTextSelection(com.codename1.ui.TextSelection) }
     *
     * @param aThis
     * @see #deinitializeTextSelection(com.codename1.ui.TextSelection)
     * @since 7.0
     */
    public void initializeTextSelection(TextSelection aThis) {

<span class="nc" id="L6802">    }</span>

    /**
     * Deinitializes text selection.
     *
     * @param aThis
     * @see #initializeTextSelection(com.codename1.ui.TextSelection)
     * @since 7.0
     */
    public void deinitializeTextSelection(TextSelection aThis) {

<span class="nc" id="L6813">    }</span>

    /**
     * Creates the native side of a {@link com.codename1.ui.HeavyButton}.  A HeavyButton
     * is a button that has a native button displayed over top of it.  It is primarily used
     * in the Javascript port where some functions can only be executed as a direct result
     * of user interaction.
     *
     * @param aThis The lightweight button for which a heavy peer is created
     * @return Native peer.  Format chosen by implementation.
     * @see #addHeavyActionListener(java.lang.Object, com.codename1.ui.events.ActionListener)
     * @since 7.0
     */
    public Object createHeavyButton(Button aThis) {
<span class="nc" id="L6827">        return null;</span>
    }

    /**
     * Adds an action listener which will be run in response to the native button's
     * click event.  {@link ActionListener#actionPerformed(com.codename1.ui.events.ActionEvent) } will
     * be executed on the native UI thread, not the EDT.
     *
     * @param peer The peer.
     * @param l    The action listener.
     * @see #createHeavyButton(com.codename1.ui.Button)
     * @see #removeHeavyActionListener(java.lang.Object, com.codename1.ui.events.ActionListener)
     * @since 7.0
     */
    public void addHeavyActionListener(Object peer, ActionListener l) {

<span class="nc" id="L6843">    }</span>

    /**
     * Removes a heavy action listener from a heavy button.
     *
     * @param peer THe heavy button peer.
     * @param l    The action listener.
     * @see #addHeavyActionListener(java.lang.Object, com.codename1.ui.events.ActionListener)
     * @see #createHeavyButton(com.codename1.ui.Button)
     * @since 7.0
     */
    public void removeHeavyActionListener(Object peer, ActionListener l) {

<span class="nc" id="L6856">    }</span>

    /**
     * Updates the bounds of the native heavy button to match the bounds of the lightweight button.
     *
     * @param peer   The heavy peer.
     * @param x      The absolute X coordinate of the light peer.
     * @param y      The absolute Y coordinate of the light peer.
     * @param width  The width of the light peer.
     * @param height The height of the light peer.
     * @since 7.0
     */
    public void updateHeavyButtonBounds(Object peer, int x, int y, int width, int height) {

<span class="nc" id="L6870">    }</span>

    /**
     * Initializes a heavy button.  This is called whenever the light peer's initComponent() method is called.
     * It should add the heavy button to the native UI hierarchy.
     *
     * @param peer The heavy peer.
     * @see #createHeavyButton(com.codename1.ui.Button)
     * @since 7.0
     */
    public void initHeavyButton(Object peer) {

<span class="nc" id="L6882">    }</span>

    /**
     * Deinitializes a heavy button.  This is called whenever the light peer's deinitialize() method is called.  It
     * should remove the heavy button from the native UI hierarchy.
     *
     * @param peer The heavy peer.
     * @see #initHeavyButton(java.lang.Object)
     * @see #createHeavyButton(com.codename1.ui.Button)
     * @since 7.0
     */
    public void deinitializeHeavyButton(Object peer) {

<span class="nc" id="L6895">    }</span>

    /**
     * Checks whether the current platform requires a heavy button for copy to clipboard functionality to work.
     * This will be true on the Javascript port.
     *
     * @return
     * @see #createHeavyButton(com.codename1.ui.Button)
     * @since 7.0
     */
    public boolean requiresHeavyButtonForCopyToClipboard() {
<span class="nc" id="L6906">        return false;</span>
    }

    /**
     * Copies the current text selection to the clipboard.
     *
     * @param sel The current TextSelection instance for the current form.
     * @since 7.0
     */
    public void copySelectionToClipboard(TextSelection sel) {
<span class="nc" id="L6916">        copyToClipboard(sel.getSelectionAsText());</span>
<span class="nc" id="L6917">    }</span>

    /**
     * Sets the rendering hints for a graphics context.
     *
     * @param nativeGraphics The native graphics context
     * @param hints          Hints
     * @see Graphics#RENDERING_HINT_FAST
     * @since 7.0
     */
    public void setRenderingHints(Object nativeGraphics, int hints) {

<span class="nc" id="L6929">    }</span>

    // START NATIVE BROWSER WINDOW METHODS----------------------------------------
    // These are useed by the com.codename1.ui.BrowserWindow class
    // to provide a native implementation for a BrowserWindow.  The JavaSE port
    // overrides these methods to provide a JavaFX implementation of a browser window.
    // The AppleSignIn.cn1lib bundles its own implementation of a WebBrowser that it
    // uses for logging in because JavaFX's webview doesn't seem to support Apple login.

    /**
     * Gets the rendering hints for this graphics context
     *
     * @param nativeGraphics The native graphics context.
     * @return The current rendering hints.
     * @see Graphics#RENDERING_HINT_FAST
     * @since 7.0
     */
    public int getRenderingHints(Object nativeGraphics) {
<span class="nc" id="L6947">        return 0;</span>
    }

    /**
     * Starts the remote control service.  This should be implemented
     * in the platform to handle binding the {@link RemoteControlListener} with
     * the platform's remote control.
     *
     * &lt;p&gt;This is executed when the user registers a new listener using {@link MediaManager#setRemoteControlListener(com.codename1.media.RemoteControlListener) }&lt;/p&gt;
     *
     * @since 7.0
     */
    public void startRemoteControl() {

<span class="nc" id="L6961">    }</span>

    /**
     * Stops the remote control service.  This should be implemented in the platform
     * to handle unbinding the {@link RemoteControlListener} with the platform's remote control.
     * &lt;p&gt;This is executed when a new listener is registered using {@link MediaManager#setRemoteControlListener(com.codename1.media.RemoteControlListener) }&lt;/p&gt;
     *
     * @since 7.0
     */
    public void stopRemoteControl() {

<span class="nc" id="L6972">    }</span>

    /**
     * Sets the read timeout of a connection.
     *
     * @param connection
     * @param readTimeout
     * @since 7.0
     */
    public void setReadTimeout(Object connection, int readTimeout) {

<span class="nc" id="L6983">    }</span>

    /**
     * Sets connection to be insecure.  If platform supports it, this will turn off SSL cerficate checks for validity.
     *
     * @param connection
     * @param insecure   True to make connection insecure.
     * @see ConnectionRequest#setInsecure(boolean)
     * @see ConnectionRequest#isInsecure()
     * @since 7.0
     */
    public void setInsecure(Object connection, boolean insecure) {

<span class="nc" id="L6996">    }</span>

    /**
     * Checks if this platform supports read timeout in network connections.
     *
     * @return True if the platform supports read timeouts.
     * @since 7.0
     */
    public boolean isReadTimeoutSupported() {
<span class="nc" id="L7005">        return false;</span>
    }

    /**
     * Creates a native web browser window object.  Default implementation returns null.
     * Platform may override this to return its own browser window.
     *
     * @param startURL The Start URL to open in the browser window.
     * @return The browser window object, or null.
     * @see com.codename1.ui.BrowserWindow
     * @see #addNativeBrowserWindowOnLoadListener(java.lang.Object, com.codename1.ui.events.ActionListener)
     * @see #removeNativeBrowserWindowOnLoadListener(java.lang.Object, com.codename1.ui.events.ActionListener)
     * @see #nativeBrowserWindowAddCloseListener(java.lang.Object, com.codename1.ui.events.ActionListener)
     * @see #nativeBrowserWindowRemoveCloseListener(java.lang.Object, com.codename1.ui.events.ActionListener)
     * @see #nativeBrowserWindowCleanup(java.lang.Object)
     * @see #nativeBrowserWindowHide(java.lang.Object)
     * @see #nativeBrowserWindowShow(java.lang.Object)
     * @see #nativeBrowserWindowSetTitle(java.lang.Object, java.lang.String)
     * @see #nativeBrowserWindowSetSize(java.lang.Object, int, int)
     * @see #nativeBrowserWindowEval(java.lang.Object, com.codename1.ui.BrowserWindow.EvalRequest)
     * @since 7.0
     */
    public Object createNativeBrowserWindow(String startURL) {
<span class="nc" id="L7028">        return null;</span>
    }

    /**
     * Adds a load listener to a native browser window.
     *
     * @param window The window to add the listener to.
     * @param l      The listener
     * @see #createNativeBrowserWindow(java.lang.String)
     * @since 7.0
     */
    public void addNativeBrowserWindowOnLoadListener(Object window, ActionListener l) {

<span class="nc" id="L7041">    }</span>

    /**
     * Removes a load listener from a native browser window.
     *
     * @param window The window from which to remove the listener.
     * @param l      The listener
     * @see #createNativeBrowserWindow(java.lang.String)
     * @since 7.0
     */
    public void removeNativeBrowserWindowOnLoadListener(Object window, ActionListener l) {

<span class="nc" id="L7053">    }</span>

    /**
     * Sets the size of a native browser window.
     *
     * @param window The window
     * @param width  The width in pixels.
     * @param height The height in pixels.
     * @see #createNativeBrowserWindow(java.lang.String)
     * @since 7.0
     */
    public void nativeBrowserWindowSetSize(Object window, int width, int height) {

<span class="nc" id="L7066">    }</span>

    /**
     * Sets the window title of a native browser window.
     *
     * @param window The window
     * @param title  The title
     * @see #createNativeBrowserWindow(java.lang.String)
     * @since 7.0
     */
    public void nativeBrowserWindowSetTitle(Object window, String title) {

<span class="nc" id="L7078">    }</span>

    // END NATIVE BROWSER WINDOW METHODS--------------------------------------------------

    /**
     * Shows a native browser window.
     *
     * @param window The window
     * @see #createNativeBrowserWindow(java.lang.String)
     * @since 7.0
     */
    public void nativeBrowserWindowShow(Object window) {

<span class="nc" id="L7091">    }</span>

    /**
     * Hides a native browser window.
     *
     * @param window The window
     * @see #createNativeBrowserWindow(java.lang.String)
     * @since 7.0
     */
    public void nativeBrowserWindowHide(Object window) {

<span class="nc" id="L7102">    }</span>

    /**
     * Cleans up and disposes of a native browser window.
     *
     * @param window The window
     * @see #createNativeBrowserWindow(java.lang.String)
     * @since 7.0
     */
    public void nativeBrowserWindowCleanup(Object window) {

<span class="nc" id="L7113">    }</span>

    /**
     * Evaluates javascript on native browser window.
     *
     * @param window The window
     * @param req    The javascript eval request.
     * @see #createNativeBrowserWindow(java.lang.String)
     * @since 7.0
     */
    public void nativeBrowserWindowEval(Object window, BrowserWindow.EvalRequest req) {
<span class="nc bnc" id="L7124" title="All 2 branches missed.">        if (!req.isDone()) {</span>
<span class="nc" id="L7125">            req.error(new RuntimeException(&quot;Not implemented&quot;));</span>
        }
<span class="nc" id="L7127">    }</span>

    /**
     * Adds close listener to native browser window.
     *
     * @param window The window.
     * @param l      The listener
     * @see #createNativeBrowserWindow(java.lang.String)
     * @since 7.0
     */
    public void nativeBrowserWindowAddCloseListener(Object window, ActionListener l) {

<span class="nc" id="L7139">    }</span>

    /**
     * Removes close listener from native browser window.
     *
     * @param window The window.
     * @param l      The listener
     * @see #createNativeBrowserWindow(java.lang.String)
     * @since 7.0
     */
    public void nativeBrowserWindowRemoveCloseListener(Object window, ActionListener l) {

<span class="nc" id="L7151">    }</span>

    /**
     * User register to receive push notification
     *
     * @param noFallback some devices don't support an efficient push API and will resort to polling
     *                   to provide push like functionality. If this flag is set to true no polling will occur and
     *                   the error PushCallback.REGISTRATION_ERROR_SERVICE_NOT_AVAILABLE will be sent to the push interface.
     */
    public void registerPush(Hashtable metaData, boolean noFallback) {
<span class="nc bnc" id="L7161" title="All 2 branches missed.">        if (!noFallback) {</span>
<span class="nc" id="L7162">            Preferences.set(&quot;PollingPush&quot;, true);</span>
<span class="nc" id="L7163">            registerPushOnServer(getPackageName(), getApplicationKey(), (byte) 10, &quot;&quot;, getPackageName());</span>

            // Call pushCallback's registeredForPush
<span class="nc" id="L7166">            Display.getInstance().callSerially(new RPush());</span>
<span class="nc" id="L7167">            registerPollingFallback();</span>
        }
<span class="nc" id="L7169">    }</span>

    /**
     * Stop receiving push notifications to this client application
     */
    public void deregisterPush() {
<span class="nc" id="L7175">        Preferences.delete(&quot;PollingPush&quot;);</span>
<span class="nc" id="L7176">        stopPolling();</span>
<span class="nc" id="L7177">    }</span>

    /**
     * Creates a Media recorder Object which will record from the device mic to
     * a file in the given path.
     *
     * @param path     a file path to where to store the recording, if the file does
     *                 not exists it will be created.
     * @param mimeType the output mime type that is supported see
     *                 getAvailableRecordingMimeTypes()
     */
    public Media createMediaRecorder(String path, String mimeType) throws IOException {
<span class="nc" id="L7189">        return null;</span>
    }

    /**
     * Creates a Media recorder Object which will record from the device mic to
     * a file in the given path.
     *
     * @param builder THe media builder with settings for the recorder.
     *                getAvailableRecordingMimeTypes()
     * @since 7.0
     */
    public Media createMediaRecorder(MediaRecorderBuilder builder) throws IOException {
<span class="nc" id="L7201">        return createMediaRecorder(builder.getPath(), builder.getMimeType());</span>
    }

    protected final void sendRegisteredForPush(String id) {
<span class="nc bnc" id="L7205" title="All 2 branches missed.">        if (callback != null) {</span>
<span class="nc" id="L7206">            callback.registeredForPush(id);</span>
        }
<span class="nc" id="L7208">    }</span>

    protected final void pushReceived(String data) {
<span class="nc bnc" id="L7211" title="All 2 branches missed.">        if (callback != null) {</span>
<span class="nc" id="L7212">            callback.push(data);</span>
        }
<span class="nc" id="L7214">    }</span>

    /**
     * Sets the frequency for polling the server in case of polling based push notification
     *
     * @param freq the frequency in milliseconds
     */
    public void setPollingFrequency(int freq) {
        // PMD Fix (UnusedPrivateField): Removed obsolete pollingMillis state; method now only triggers listener wake-up.
<span class="nc bnc" id="L7223" title="All 4 branches missed.">        if (callback != null &amp;&amp; pollingThreadRunning) {</span>
<span class="nc" id="L7224">            synchronized (callback) {</span>
<span class="nc" id="L7225">                callback.notify();</span>
<span class="nc" id="L7226">            }</span>
        }
<span class="nc" id="L7228">    }</span>

    /**
     * Returns the image IO instance that allows scaling image files.
     *
     * @return the image IO instance
     */
    public ImageIO getImageIO() {
<span class="nc" id="L7236">        return null;</span>
    }

    /**
     * Workaround for XMLVM bug
     */
    public boolean instanceofObjArray(Object o) {
<span class="nc" id="L7243">        return o instanceof Object[];</span>
    }

    /**
     * Workaround for XMLVM bug
     */
    public boolean instanceofByteArray(Object o) {
<span class="nc" id="L7250">        return o instanceof byte[];</span>
    }

    /**
     * Workaround for XMLVM bug
     */
    public boolean instanceofShortArray(Object o) {
<span class="nc" id="L7257">        return o instanceof short[];</span>
    }

    /**
     * Workaround for XMLVM bug
     */
    public boolean instanceofLongArray(Object o) {
<span class="nc" id="L7264">        return o instanceof long[];</span>
    }

    /**
     * Workaround for XMLVM bug
     */
    public boolean instanceofIntArray(Object o) {
<span class="nc" id="L7271">        return o instanceof int[];</span>
    }

    /**
     * Workaround for XMLVM bug
     */
    public boolean instanceofFloatArray(Object o) {
<span class="nc" id="L7278">        return o instanceof float[];</span>
    }

    /**
     * Workaround for XMLVM bug
     */
    public boolean instanceofDoubleArray(Object o) {
<span class="nc" id="L7285">        return o instanceof double[];</span>
    }

    /**
     * Gets the available recording MimeTypes
     */
    public String[] getAvailableRecordingMimeTypes() {
<span class="nc" id="L7292">        return new String[]{&quot;audio/amr&quot;, &quot;audio/aac&quot;};</span>
    }

    /**
     * Opens a database or create one if not exists
     *
     * @param databaseName the name of the database
     * @return Database Object or null if not supported on the platform
     * @throws IOException if database cannot be created
     */
    public Database openOrCreateDB(String databaseName) throws IOException {
<span class="nc" id="L7303">        return null;</span>
    }

    /**
     * Deletes database
     *
     * @param databaseName the name of the database
     * @throws IOException if database cannot be deleted
     */
    public void deleteDB(String databaseName) throws IOException {
<span class="nc" id="L7313">    }</span>

    /**
     * Indicates weather a database exists
     *
     * @param databaseName the name of the database
     * @return true if database exists
     */
    public boolean existsDB(String databaseName) {
<span class="nc" id="L7322">        return false;</span>
    }

    /**
     * Returns the file path of the Database if exists and if supported on
     * the platform.
     *
     * @return the file path of the database or null if not exists
     */
    public String getDatabasePath(String databaseName) {
<span class="nc" id="L7332">        return null;</span>
    }

    /**
     * Indicates if the title of the Form is native title(in android ICS devices
     * if the command behavior is native the ActionBar is used to display the title
     * and the menu)
     *
     * @return true if platform would like to show the Form title
     */
    public boolean isNativeTitle() {
<span class="nc" id="L7343">        return false;</span>
    }

    /**
     * if the title is native(e.g the android action bar), notify the native title
     * that is needs to be refreshed
     */
    public void refreshNativeTitle() {
<span class="nc" id="L7351">    }</span>

    /**
     * Indicates the way commands should be added to a form as one of the ocmmand constants defined
     * in this class
     *
     * @return the commandBehavior
     */
    public int getCommandBehavior() {
<span class="fc" id="L7360">        return commandBehavior;</span>
    }

    /**
     * Indicates the way commands should be added to a form as one of the ocmmand constants defined
     * in this class
     *
     * @param commandBehavior the commandBehavior to set
     */
    public void setCommandBehavior(int commandBehavior) {
        // PMD Fix (CollapsibleIfStatements): Combine touch capability and behavior checks.
<span class="pc bpc" id="L7371" title="3 of 4 branches missed.">        if (!isTouchDevice() &amp;&amp; commandBehavior == Display.COMMAND_BEHAVIOR_BUTTON_BAR) {</span>
<span class="nc" id="L7372">            commandBehavior = Display.COMMAND_BEHAVIOR_SOFTKEY;</span>
        }
<span class="fc" id="L7374">        this.commandBehavior = commandBehavior;</span>
<span class="fc" id="L7375">        notifyCommandBehavior(commandBehavior);</span>
<span class="fc" id="L7376">    }</span>

    /**
     * Place a notification on the device status bar (if device has this
     * functionality).
     * The notification will re-start the Application.
     *
     * @param tickerText   the ticker text of the Notification
     * @param contentTitle the title of the Notification
     * @param contentBody  the content of the Notification
     * @param vibrate      enable/disable notification alert
     * @param flashLights  enable/disable notification flashing
     * @param args         additional arguments to the notification
     * @return a platform native object that allows modifying notification state
     * @deprecated use scheduleLocalNotification instead
     */
    public Object notifyStatusBar(String tickerText, String contentTitle,
                                  String contentBody, boolean vibrate, boolean flashLights, Hashtable args) {
<span class="nc" id="L7394">        return null;</span>
    }

    /**
     * Indicates whether the notify status bar method will present a notification to the user
     *
     * @return true if the notify status bar method will present a notification to the user
     */
    public boolean isNotificationSupported() {
<span class="nc" id="L7403">        return false;</span>
    }

    /**
     * Removes the notification previously posted with the notify status bar method
     *
     * @param o the object returned from the notifyStatusBar method
     */
    public void dismissNotification(Object o) {
<span class="nc" id="L7412">    }</span>

    /**
     * Returns true if the underlying OS supports numeric badges on icons. Notice this is only available on iOS
     * and only when push notification is enabled
     *
     * @return true if the underlying OS supports numeric badges
     */
    public boolean isBadgingSupported() {
<span class="nc" id="L7421">        return false;</span>
    }

    /**
     * Sets the number that appears on the application icon in iOS
     *
     * @param number number to show on the icon
     */
    public void setBadgeNumber(int number) {
<span class="nc" id="L7430">    }</span>

    /**
     * Returns true if the underlying OS supports opening the native navigation
     * application
     *
     * @return true if the underlying OS supports launch of native navigation app
     */
    public boolean isOpenNativeNavigationAppSupported() {
<span class="nc" id="L7439">        return false;</span>
    }

    /**
     * Opens the native navigation app in the given coordinate.
     *
     * @param latitude
     * @param longitude
     */
    public void openNativeNavigationApp(double latitude, double longitude) {
<span class="nc" id="L7449">    }</span>

    /**
     * Opens the native navigation app with the given search location
     *
     * @param location the location to search for in the native navigation map
     */
    public void openNativeNavigationApp(String location) {
<span class="nc" id="L7457">        execute(&quot;http://maps.google.com/?q=&quot; + Util.encodeUrl(location));</span>
<span class="nc" id="L7458">    }</span>

    /**
     * Returns the UDID for devices that support it
     *
     * @return the UDID or null
     */
    public String getUdid() {
<span class="nc" id="L7466">        return getProperty(&quot;UDID&quot;, null);</span>
    }

    /**
     * Returns the MSISDN for devices that expose it
     *
     * @return the msisdn or null
     */
    public String getMsisdn() {
<span class="nc" id="L7475">        return getProperty(&quot;MSISDN&quot;, null);</span>
    }

    /**
     * Returns the native OS purchase implementation if applicable, if not this
     * method will fallback to a cross platform purchase manager.
     *
     * @return instance of the purchase class
     */
    public Purchase getInAppPurchase() {
<span class="nc" id="L7485">        return null;</span>
    }

    /**
     * Returns the native implementation of the code scanner or null
     *
     * @return code scanner instance
     * @deprecated Use cn1-codescan cn1lib instead.
     */
    public CodeScanner getCodeScanner() {
<span class="nc" id="L7495">        return null;</span>
    }

    /**
     * Converts a FileSystemStorage path to a native path.
     *
     * @param path The file system storage path.
     * @return The native path.
     */
    public String toNativePath(String path) {
<span class="nc" id="L7505">        return path;</span>
    }

    /**
     * This will return the application home directory.
     *
     * @return a writable directory that represent the application home directory
     */
    public String getAppHomePath() {
<span class="nc" id="L7514">        String home = listFilesystemRoots()[0];</span>
<span class="nc" id="L7515">        String name = getProperty(&quot;AppName&quot;, packageName);</span>
<span class="nc bnc" id="L7516" title="All 2 branches missed.">        if (!home.endsWith(&quot;&quot; + getFileSystemSeparator())) {</span>
<span class="nc" id="L7517">            home += getFileSystemSeparator();</span>
        }
<span class="nc" id="L7519">        home = home + name + getFileSystemSeparator();</span>
<span class="nc bnc" id="L7520" title="All 2 branches missed.">        if (!exists(home)) {</span>
<span class="nc" id="L7521">            mkdir(home);</span>
        }
<span class="nc" id="L7523">        return home;</span>
    }

    /**
     * Returns true if the device has a directory dedicated for &quot;cache&quot; files
     *
     * @return true if a caches style directory exists in this device type
     */
    public boolean hasCachesDir() {
<span class="nc" id="L7532">        return false;</span>
    }

    /**
     * Returns a device specific directory designed for cache style files, or null if {@link #hasCachesDir()}
     * is false
     *
     * @return file URL or null
     */
    public String getCachesDir() {
<span class="nc" id="L7542">        return null;</span>
    }

    /**
     * Uses the native cookie store if applicable, this might break simulator compatibility
     *
     * @return the useNativeCookieStore
     */
    public boolean isUseNativeCookieStore() {
<span class="nc" id="L7551">        return useNativeCookieStore;</span>
    }

    /**
     * Uses the native cookie store if applicable, this might break simulator compatibility
     *
     * @param useNativeCookieStore the useNativeCookieStore to set
     */
    public void setUseNativeCookieStore(boolean useNativeCookieStore) {
<span class="nc" id="L7560">        this.useNativeCookieStore = useNativeCookieStore;</span>
<span class="nc" id="L7561">    }</span>

    /**
     * Indicates the implementation is capable of keeping the background painted by being non-destructive.
     *
     * @return whether to paint the background
     */
    public boolean shouldPaintBackground() {
<span class="fc" id="L7569">        return true;</span>
    }

    /**
     * This method allows a native implementation to implement a native version of a given transition that
     * can be faster
     *
     * @param t the transition that is about to execute
     * @return the given transition or a native version of that transition
     */
    public Transition getNativeTransition(Transition t) {
<span class="nc" id="L7580">        return t;</span>
    }

    /**
     * Checks if the device supports locking the screen display from dimming, allowing
     * the developer to keep the screen display on.
     */
    public boolean isScreenLockSupported() {
<span class="nc" id="L7588">        return false;</span>
    }

    /**
     * If Locking isScreenLockSupported() returns true calling this method will
     * lock the screen display on
     */
    public void lockScreen() {
<span class="nc" id="L7596">    }</span>

    /**
     * Unlock the screen display allowing the screen to dim.
     */
    public void unlockScreen() {
<span class="nc" id="L7602">    }</span>

    /**
     * Returns true if the device has camera false otherwise.
     */
    public boolean hasCamera() {
<span class="nc" id="L7608">        return true;</span>
    }

    /**
     * Returns the platform EDT thread priority
     */
    public int getEDTThreadPriority() {
<span class="fc" id="L7615">        return Thread.NORM_PRIORITY + 1;</span>
    }

    /**
     * This method is used by the JavaSE implementation for performance logging
     *
     * @param img the image being drawn
     */
    public void drawingEncodedImage(EncodedImage img) {
<span class="nc" id="L7624">    }</span>

    /**
     * Indicates whether the native picker dialog is supported for the given type
     * which can include one of PICKER_TYPE_DATE_AND_TIME, PICKER_TYPE_TIME, PICKER_TYPE_DATE
     *
     * @param pickerType the picker type constant
     * @return true if the native platform supports this picker type
     */
    public boolean isNativePickerTypeSupported(int pickerType) {
<span class="nc" id="L7634">        return false;</span>
    }

    /**
     * Shows a native modal dialog allowing us to perform the picking for the given type
     * which can include one of PICKER_TYPE_DATE_AND_TIME, PICKER_TYPE_TIME, PICKER_TYPE_DATE
     *
     * @param type         the picker type constant
     * @param source       the source component (optional) the native dialog will be placed in relation to this
     *                     component if applicable
     * @param currentValue the currently selected value
     * @param data         additional meta data specific to the picker type when applicable
     * @return the value from the picker or null if the operation was canceled.
     */
    public Object showNativePicker(int type, Component source, Object currentValue, Object data) {
<span class="nc" id="L7649">        return null;</span>
    }

    /**
     * Creates a socket to connect to the given host on the given port
     *
     * @param host the host
     * @param port the port
     * @return the socket object to use
     */
    public Object connectSocket(String host, int port) {
<span class="nc" id="L7660">        return connectSocket(host, port, 0);</span>
    }

    /**
     * Creates a socket to connect to the given host on the given port
     *
     * @param host           the host
     * @param port           the port
     * @param connectTimeout connect timeout.  0 for infinite timeout.
     * @return the socket object to use
     * @since 7.0
     */
    public Object connectSocket(String host, int port, int connectTimeout) {
<span class="nc" id="L7673">        throw new RuntimeException(&quot;Not supported&quot;);</span>
    }

    /**
     * Listens on the given port similar to the accept method of server socket in Java. This method
     * will only work if isServerSocketAvailable() is true.
     *
     * @param port the port to listen on
     * @return server socket instance
     */
    public Object listenSocket(int port) {
<span class="nc" id="L7684">        throw new RuntimeException(&quot;Not supported&quot;);</span>
    }

    /**
     * Returns the device host or ip address if available
     *
     * @return device host or ip
     */
    public String getHostOrIP() {
<span class="nc" id="L7693">        return null;</span>
    }

    /**
     * Disconnects the current socket from the server/client on the other side
     *
     * @param socket the socket instance
     */
    public void disconnectSocket(Object socket) {
<span class="nc" id="L7702">    }</span>

    /**
     * Indicates whether the socket is currently connected
     *
     * @param socket is the socket we are connected to
     * @return true if the socket is connected
     */
    public boolean isSocketConnected(Object socket) {
<span class="nc" id="L7711">        return false;</span>
    }

    /**
     * Indicates whether the underlying implementation supports server sockets
     *
     * @return false by default
     */
    public boolean isServerSocketAvailable() {
<span class="nc" id="L7720">        return false;</span>
    }

    /**
     * Indicates whether the underlying implementation supports sockets
     *
     * @return false by default
     */
    public boolean isSocketAvailable() {
<span class="nc" id="L7729">        return false;</span>
    }

    /**
     * Return the pending error message on the given socket
     *
     * @param socket the socket instance
     * @return the error message if available
     */
    public String getSocketErrorMessage(Object socket) {
<span class="nc" id="L7739">        return null;</span>
    }

    /**
     * Returns the pending error code on the given socket
     *
     * @param socket the socket instance
     * @return the error code
     */
    public int getSocketErrorCode(Object socket) {
<span class="nc" id="L7749">        return -1;</span>
    }

    /**
     * Returns whether data is available for input on the socket
     *
     * @param socket the socket instance
     * @return a none zero value if data is available for input
     */
    public int getSocketAvailableInput(Object socket) {
<span class="nc" id="L7759">        return 0;</span>
    }

    /**
     * Read pending bytes from the socket
     *
     * @param socket the socket object
     * @return byte array with data read from the socket
     */
    public byte[] readFromSocketStream(Object socket) {
<span class="nc" id="L7769">        return null;</span>
    }

    /**
     * Write the following byte array to the socket
     *
     * @param socket the socket instance
     * @param data   the data written
     */
    public void writeToSocketStream(Object socket, byte[] data) {
<span class="nc" id="L7779">    }</span>

    private void mkdirs(FileSystemStorage fs, String path) {
<span class="nc" id="L7782">        int lastPos = path.lastIndexOf('/');</span>
<span class="nc bnc" id="L7783" title="All 2 branches missed.">        if (lastPos &gt;= 0) {</span>
<span class="nc" id="L7784">            mkdirs(fs, path.substring(0, lastPos));</span>
        }
<span class="nc bnc" id="L7786" title="All 2 branches missed.">        if (!fs.exists(path)) {</span>
<span class="nc" id="L7787">            mkdir(path);</span>
        }

<span class="nc" id="L7790">    }</span>

    /**
     * Installs a tar file from the build server into the file system storage so it can be used with respect for hierarchy
     */
    public void installTar() throws IOException {
<span class="nc" id="L7796">        String p = Preferences.get(&quot;cn1$InstallKey&quot;, null);</span>
<span class="nc" id="L7797">        String buildKey = Display.getInstance().getProperty(&quot;build_key&quot;, null);</span>
<span class="nc bnc" id="L7798" title="All 4 branches missed.">        if (p == null || !p.equals(buildKey)) {</span>
<span class="nc" id="L7799">            FileSystemStorage fs = FileSystemStorage.getInstance();</span>
<span class="nc" id="L7800">            String tardir = fs.getAppHomePath() + &quot;cn1html/&quot;;</span>
<span class="nc" id="L7801">            fs.mkdir(tardir);</span>
<span class="nc" id="L7802">            TarInputStream is = new TarInputStream(Display.getInstance().getResourceAsStream(getClass(), &quot;/html.tar&quot;));</span>

<span class="nc" id="L7804">            TarEntry t = is.getNextEntry();</span>
<span class="nc" id="L7805">            byte[] data = new byte[8192];</span>
<span class="nc bnc" id="L7806" title="All 2 branches missed.">            while (t != null) {</span>
<span class="nc" id="L7807">                String name = t.getName();</span>
<span class="nc bnc" id="L7808" title="All 2 branches missed.">                if (t.isDirectory()) {</span>
<span class="nc" id="L7809">                    fs.mkdir(tardir + name);</span>
                } else {
<span class="nc" id="L7811">                    String path = tardir + name;</span>
<span class="nc" id="L7812">                    String dir = path.substring(0, path.lastIndexOf('/'));</span>
<span class="nc bnc" id="L7813" title="All 2 branches missed.">                    if (!fs.exists(dir)) {</span>
<span class="nc" id="L7814">                        mkdirs(fs, dir);</span>
                    }

<span class="nc" id="L7817">                    OutputStream os = fs.openOutputStream(tardir + name);</span>
                    int count;
<span class="nc bnc" id="L7819" title="All 2 branches missed.">                    while ((count = is.read(data)) != -1) {</span>
<span class="nc" id="L7820">                        os.write(data, 0, count);</span>
                    }

<span class="nc" id="L7823">                    os.close();</span>
                }

<span class="nc" id="L7826">                t = is.getNextEntry();</span>
<span class="nc" id="L7827">            }</span>

<span class="nc" id="L7829">            Util.cleanup(is);</span>
<span class="nc" id="L7830">            Preferences.set(&quot;cn1$InstallKey&quot;, buildKey);</span>
        }
<span class="nc" id="L7832">    }</span>

    public void splitString(String source, char separator, ArrayList&lt;String&gt; out) {
<span class="nc" id="L7835">        int len = source.length();</span>
<span class="nc" id="L7836">        boolean lastSeparator = false;</span>
<span class="nc" id="L7837">        StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L7838" title="All 2 branches missed.">        for (int iter = 0; iter &lt; len; iter++) {</span>
<span class="nc" id="L7839">            char current = source.charAt(iter);</span>
<span class="nc bnc" id="L7840" title="All 2 branches missed.">            if (current == separator) {</span>
<span class="nc bnc" id="L7841" title="All 2 branches missed.">                if (lastSeparator) {</span>
                    //buf.append(separator);
<span class="nc" id="L7843">                    lastSeparator = false;</span>
<span class="nc" id="L7844">                    continue;</span>
                }
<span class="nc" id="L7846">                lastSeparator = true;</span>
<span class="nc bnc" id="L7847" title="All 2 branches missed.">                if (buf.length() &gt; 0) {</span>
<span class="nc" id="L7848">                    out.add(buf.toString());</span>
<span class="nc" id="L7849">                    buf.setLength(0);</span>
                }
            } else {
<span class="nc" id="L7852">                lastSeparator = false;</span>
<span class="nc" id="L7853">                buf.append(current);</span>
            }
        }
<span class="nc bnc" id="L7856" title="All 2 branches missed.">        if (buf.length() &gt; 0) {</span>
<span class="nc" id="L7857">            out.add(buf.toString());</span>
        }
<span class="nc" id="L7859">    }</span>

    /**
     * Allows detecting development mode so debugging code and special cases can be used to simplify flow
     *
     * @return true if we are running in the simulator, false otherwise
     */
    public boolean isSimulator() {
<span class="fc" id="L7867">        return false;</span>
    }

    /**
     * Paints the background of a component based on the style values on the
     * given graphics context, the style could be accessed from the drawing
     * thread in read only capacity to make the code slightly more efficient
     *
     * @param nativeGraphics the graphics context
     * @param x              coordinate to draw
     * @param y              coordinate to draw
     * @param width          coordinate to draw
     * @param height         coordinate to draw
     * @param s              the style object to draw
     */
    public void paintComponentBackground(Object nativeGraphics, int x, int y, int width, int height, Style s) {
<span class="pc bpc" id="L7883" title="2 of 4 branches missed.">        if (width &lt;= 0 || height &lt;= 0) {</span>
<span class="nc" id="L7884">            return;</span>
        }
<span class="fc" id="L7886">        Image bgImageOrig = s.getBgImage();</span>
<span class="pc bpc" id="L7887" title="1 of 2 branches missed.">        if (bgImageOrig == null) {</span>
<span class="pc bpc" id="L7888" title="1 of 2 branches missed.">            if (s.getBackgroundType() &gt;= Style.BACKGROUND_GRADIENT_LINEAR_VERTICAL) {</span>
<span class="nc" id="L7889">                drawGradientBackground(s, nativeGraphics, x, y, width, height);</span>
<span class="nc" id="L7890">                return;</span>
            }
<span class="fc" id="L7892">            setColor(nativeGraphics, s.getBgColor());</span>
<span class="fc" id="L7893">            fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
        } else {
<span class="nc" id="L7895">            int iW = bgImageOrig.getWidth();</span>
<span class="nc" id="L7896">            int iH = bgImageOrig.getHeight();</span>
<span class="nc" id="L7897">            Object bgImage = bgImageOrig.getImage();</span>
<span class="nc bnc" id="L7898" title="All 22 branches missed.">            switch (s.getBackgroundType()) {</span>
                case Style.BACKGROUND_NONE:
<span class="nc bnc" id="L7900" title="All 2 branches missed.">                    if (s.getBgTransparency() != 0) {</span>
<span class="nc" id="L7901">                        setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L7902">                        fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
                    }
<span class="nc" id="L7904">                    return;</span>
                case Style.BACKGROUND_IMAGE_SCALED:
<span class="nc bnc" id="L7906" title="All 2 branches missed.">                    if (isScaledImageDrawingSupported()) {</span>
<span class="nc" id="L7907">                        drawImage(nativeGraphics, bgImage, x, y, width, height);</span>
                    } else {
<span class="nc bnc" id="L7909" title="All 4 branches missed.">                        if (iW != width || iH != height) {</span>
<span class="nc" id="L7910">                            bgImageOrig = bgImageOrig.scaled(width, height);</span>
<span class="nc" id="L7911">                            s.setBgImage(bgImageOrig, true);</span>
<span class="nc" id="L7912">                            bgImage = bgImageOrig.getImage();</span>
                        }
<span class="nc" id="L7914">                        drawImage(nativeGraphics, bgImage, x, y);</span>
                    }
<span class="nc" id="L7916">                    return;</span>
                case Style.BACKGROUND_IMAGE_SCALED_FILL:
<span class="nc" id="L7918">                    float r = Math.max(((float) width) / ((float) iW), ((float) height) / ((float) iH));</span>
<span class="nc" id="L7919">                    int bwidth = (int) (((float) iW) * r);</span>
<span class="nc" id="L7920">                    int bheight = (int) (((float) iH) * r);</span>
<span class="nc bnc" id="L7921" title="All 2 branches missed.">                    if (isScaledImageDrawingSupported()) {</span>
<span class="nc" id="L7922">                        drawImage(nativeGraphics, bgImage, x + (width - bwidth) / 2, y + (height - bheight) / 2, bwidth, bheight);</span>
                    } else {
<span class="nc bnc" id="L7924" title="All 4 branches missed.">                        if (iW != bwidth || iH != bheight) {</span>
<span class="nc" id="L7925">                            bgImageOrig = bgImageOrig.scaled(bwidth, bheight);</span>
<span class="nc" id="L7926">                            s.setBgImage(bgImageOrig, true);</span>
<span class="nc" id="L7927">                            bgImage = bgImageOrig.getImage();</span>
                        }
<span class="nc" id="L7929">                        drawImage(nativeGraphics, bgImage, x + (width - bwidth) / 2, y + (height - bheight) / 2);</span>
                    }
<span class="nc" id="L7931">                    return;</span>
                case Style.BACKGROUND_IMAGE_SCALED_FIT:
<span class="nc bnc" id="L7933" title="All 2 branches missed.">                    if (s.getBgTransparency() != 0) {</span>
<span class="nc" id="L7934">                        setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L7935">                        fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
                    }
<span class="nc" id="L7937">                    float r2 = Math.min(((float) width) / ((float) iW), ((float) height) / ((float) iH));</span>
<span class="nc" id="L7938">                    int awidth = (int) (((float) iW) * r2);</span>
<span class="nc" id="L7939">                    int aheight = (int) (((float) iH) * r2);</span>
<span class="nc bnc" id="L7940" title="All 2 branches missed.">                    if (isScaledImageDrawingSupported()) {</span>
<span class="nc" id="L7941">                        drawImage(nativeGraphics, bgImage, x + (width - awidth) / 2, y + (height - aheight) / 2, awidth, aheight);</span>
                    } else {
<span class="nc bnc" id="L7943" title="All 4 branches missed.">                        if (iW != awidth || iH != aheight) {</span>
<span class="nc" id="L7944">                            bgImageOrig = bgImageOrig.scaled(awidth, aheight);</span>
<span class="nc" id="L7945">                            s.setBgImage(bgImageOrig, true);</span>
<span class="nc" id="L7946">                            bgImage = bgImageOrig.getImage();</span>
                        }
<span class="nc" id="L7948">                        drawImage(nativeGraphics, bgImage, x + (width - awidth) / 2, y + (height - aheight) / 2, awidth, aheight);</span>
                    }
<span class="nc" id="L7950">                    return;</span>
                case Style.BACKGROUND_IMAGE_TILE_BOTH:
<span class="nc" id="L7952">                    tileImage(nativeGraphics, bgImage, x, y, width, height);</span>
<span class="nc" id="L7953">                    return;</span>
                case Style.BACKGROUND_IMAGE_TILE_HORIZONTAL_ALIGN_TOP:
<span class="nc" id="L7955">                    setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L7956">                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L7957">                    tileImage(nativeGraphics, bgImage, x, y, width, iH);</span>
<span class="nc" id="L7958">                    return;</span>
                case Style.BACKGROUND_IMAGE_TILE_HORIZONTAL_ALIGN_CENTER:
<span class="nc" id="L7960">                    setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L7961">                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L7962">                    tileImage(nativeGraphics, bgImage, x, y + (height / 2 - iH / 2), width, iH);</span>
<span class="nc" id="L7963">                    return;</span>
                case Style.BACKGROUND_IMAGE_TILE_HORIZONTAL_ALIGN_BOTTOM:
<span class="nc" id="L7965">                    setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L7966">                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L7967">                    tileImage(nativeGraphics, bgImage, x, y + (height - iH), width, iH);</span>
<span class="nc" id="L7968">                    return;</span>
                case Style.BACKGROUND_IMAGE_TILE_VERTICAL_ALIGN_LEFT:
<span class="nc" id="L7970">                    setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L7971">                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc bnc" id="L7972" title="All 2 branches missed.">                    for (int yPos = 0; yPos &lt;= height; yPos += iH) {</span>
<span class="nc" id="L7973">                        drawImage(nativeGraphics, bgImage, x, y + yPos);</span>
                    }
<span class="nc" id="L7975">                    return;</span>
                case Style.BACKGROUND_IMAGE_TILE_VERTICAL_ALIGN_CENTER:
<span class="nc" id="L7977">                    setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L7978">                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc bnc" id="L7979" title="All 2 branches missed.">                    for (int yPos = 0; yPos &lt;= height; yPos += iH) {</span>
<span class="nc" id="L7980">                        drawImage(nativeGraphics, bgImage, x + (width / 2 - iW / 2), y + yPos);</span>
                    }
<span class="nc" id="L7982">                    return;</span>
                case Style.BACKGROUND_IMAGE_TILE_VERTICAL_ALIGN_RIGHT:
<span class="nc" id="L7984">                    setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L7985">                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc bnc" id="L7986" title="All 2 branches missed.">                    for (int yPos = 0; yPos &lt;= height; yPos += iH) {</span>
<span class="nc" id="L7987">                        drawImage(nativeGraphics, bgImage, x + width - iW, y + yPos);</span>
                    }
<span class="nc" id="L7989">                    return;</span>
                case Style.BACKGROUND_IMAGE_ALIGNED_TOP:
<span class="nc" id="L7991">                    setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L7992">                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L7993">                    drawImage(nativeGraphics, bgImage, x + (width / 2 - iW / 2), y);</span>
<span class="nc" id="L7994">                    return;</span>
                case Style.BACKGROUND_IMAGE_ALIGNED_BOTTOM:
<span class="nc" id="L7996">                    setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L7997">                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L7998">                    drawImage(nativeGraphics, bgImage, x + (width / 2 - iW / 2), y + (height - iH));</span>
<span class="nc" id="L7999">                    return;</span>
                case Style.BACKGROUND_IMAGE_ALIGNED_LEFT:
<span class="nc" id="L8001">                    setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L8002">                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8003">                    drawImage(nativeGraphics, bgImage, x, y + (height / 2 - iH / 2));</span>
<span class="nc" id="L8004">                    return;</span>
                case Style.BACKGROUND_IMAGE_ALIGNED_RIGHT:
<span class="nc" id="L8006">                    setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L8007">                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8008">                    drawImage(nativeGraphics, bgImage, x + width - iW, y + (height / 2 - iH / 2));</span>
<span class="nc" id="L8009">                    return;</span>
                case Style.BACKGROUND_IMAGE_ALIGNED_CENTER:
<span class="nc" id="L8011">                    setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L8012">                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8013">                    drawImage(nativeGraphics, bgImage, x + (width / 2 - iW / 2), y + (height / 2 - iH / 2));</span>
<span class="nc" id="L8014">                    return;</span>
                case Style.BACKGROUND_IMAGE_ALIGNED_TOP_LEFT:
<span class="nc" id="L8016">                    setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L8017">                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8018">                    drawImage(nativeGraphics, bgImage, x, y);</span>
<span class="nc" id="L8019">                    return;</span>
                case Style.BACKGROUND_IMAGE_ALIGNED_TOP_RIGHT:
<span class="nc" id="L8021">                    setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L8022">                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8023">                    drawImage(nativeGraphics, bgImage, x + width - iW, y);</span>
<span class="nc" id="L8024">                    return;</span>
                case Style.BACKGROUND_IMAGE_ALIGNED_BOTTOM_LEFT:
<span class="nc" id="L8026">                    setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L8027">                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8028">                    drawImage(nativeGraphics, bgImage, x, y + (height - iH));</span>
<span class="nc" id="L8029">                    return;</span>
                case Style.BACKGROUND_IMAGE_ALIGNED_BOTTOM_RIGHT:
<span class="nc" id="L8031">                    setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L8032">                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8033">                    drawImage(nativeGraphics, bgImage, x + width - iW, y + (height - iH));</span>
<span class="nc" id="L8034">                    return;</span>
                case Style.BACKGROUND_GRADIENT_LINEAR_HORIZONTAL:
                case Style.BACKGROUND_GRADIENT_LINEAR_VERTICAL:
                case Style.BACKGROUND_GRADIENT_RADIAL:
<span class="nc" id="L8038">                    drawGradientBackground(s, nativeGraphics, x, y, width, height);</span>
            }
        }
<span class="fc" id="L8041">    }</span>

    private void drawGradientBackground(Style s, Object nativeGraphics, int x, int y, int width, int height) {
<span class="nc bnc" id="L8044" title="All 4 branches missed.">        switch (s.getBackgroundType()) {</span>
            case Style.BACKGROUND_GRADIENT_LINEAR_HORIZONTAL:
<span class="nc" id="L8046">                fillLinearGradient(nativeGraphics, s.getBackgroundGradientStartColor(), s.getBackgroundGradientEndColor(),</span>
                        x, y, width, height, true);
<span class="nc" id="L8048">                return;</span>
            case Style.BACKGROUND_GRADIENT_LINEAR_VERTICAL:
<span class="nc" id="L8050">                fillLinearGradient(nativeGraphics, s.getBackgroundGradientStartColor(), s.getBackgroundGradientEndColor(),</span>
                        x, y, width, height, false);
<span class="nc" id="L8052">                return;</span>
            case Style.BACKGROUND_GRADIENT_RADIAL:
<span class="nc" id="L8054">                fillRectRadialGradient(nativeGraphics, s.getBackgroundGradientStartColor(), s.getBackgroundGradientEndColor(),</span>
<span class="nc" id="L8055">                        x, y, width, height, s.getBackgroundGradientRelativeX(), s.getBackgroundGradientRelativeY(),</span>
<span class="nc" id="L8056">                        s.getBackgroundGradientRelativeSize());</span>
<span class="nc" id="L8057">                return;</span>
        }
<span class="nc" id="L8059">        setColor(nativeGraphics, s.getBgColor());</span>
<span class="nc" id="L8060">        fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8061">    }</span>

    /**
     * Fills a rectangle with an optionally translucent fill color
     *
     * @param nativeGraphics the underlying native graphics object
     * @param x              the x coordinate of the rectangle to be filled
     * @param y              the y coordinate of the rectangle to be filled
     * @param w              the width of the rectangle to be filled
     * @param h              the height of the rectangle to be filled
     * @param alpha          the alpha values specify semitransparency
     */
    public void fillRect(Object nativeGraphics, int x, int y, int w, int h, byte alpha) {
<span class="fc bfc" id="L8074" title="All 2 branches covered.">        if (alpha != 0) {</span>
<span class="fc" id="L8075">            int oldAlpha = getAlpha(nativeGraphics);</span>
<span class="fc" id="L8076">            setAlpha(nativeGraphics, alpha &amp; 0xff);</span>
<span class="fc" id="L8077">            fillRect(nativeGraphics, x, y, w, h);</span>
<span class="fc" id="L8078">            setAlpha(nativeGraphics, oldAlpha);</span>
        }
<span class="fc" id="L8080">    }</span>

    /**
     * Draws a label on the given graphics context, this method allows optimizing the very common drawing operation
     * using platform native code
     */
    public void drawLabelComponent(Object nativeGraphics, int cmpX, int cmpY, int cmpHeight, int cmpWidth,
                                   Style style, String text, Object icon, Object stateIcon, int preserveSpaceForState, int gap, boolean rtl,
                                   boolean isOppositeSide, int textPosition, int stringWidth, boolean isTickerRunning, int tickerShiftText,
                                   boolean endsWith3Points, int valign) {
<span class="fc" id="L8090">        Font font = style.getFont();</span>
<span class="fc" id="L8091">        Object nativeFont = font.getNativeFont();</span>
<span class="fc" id="L8092">        setNativeFont(nativeGraphics, nativeFont);</span>
<span class="fc" id="L8093">        setColor(nativeGraphics, style.getFgColor());</span>

<span class="fc" id="L8095">        int alpha = concatenateAlpha(nativeGraphics, style.getFgAlpha());</span>

<span class="fc" id="L8097">        int iconWidth = 0;</span>
<span class="fc" id="L8098">        int iconHeight = 0;</span>
<span class="pc bpc" id="L8099" title="1 of 2 branches missed.">        if (icon != null) {</span>
<span class="nc" id="L8100">            iconWidth = getImageWidth(icon);</span>
<span class="nc" id="L8101">            iconHeight = getImageHeight(icon);</span>
        }

<span class="fc" id="L8104">        int textDecoration = style.getTextDecoration();</span>
<span class="fc" id="L8105">        int stateIconSize = 0;</span>
<span class="fc" id="L8106">        int stateIconYPosition = 0;</span>

<span class="fc" id="L8108">        int leftPadding = style.getPaddingLeft(rtl);</span>
<span class="fc" id="L8109">        int rightPadding = style.getPaddingRight(rtl);</span>
<span class="fc" id="L8110">        int topPadding = style.getPaddingTop();</span>
<span class="fc" id="L8111">        int bottomPadding = style.getPaddingBottom();</span>

<span class="fc" id="L8113">        int fontHeight = 0;</span>
<span class="pc bpc" id="L8114" title="1 of 2 branches missed.">        if (text == null) {</span>
<span class="nc" id="L8115">            text = &quot;&quot;;</span>
        }
<span class="pc bpc" id="L8117" title="1 of 2 branches missed.">        if (text.length() &gt; 0) {</span>
<span class="fc" id="L8118">            fontHeight = font.getHeight();</span>
        }

<span class="pc bpc" id="L8121" title="1 of 2 branches missed.">        if (stateIcon != null) {</span>
<span class="nc" id="L8122">            stateIconSize = getImageWidth(stateIcon);</span>
<span class="nc" id="L8123">            stateIconYPosition = cmpY + topPadding</span>
                    + (cmpHeight - topPadding
                    - bottomPadding) / 2 - stateIconSize / 2;
<span class="nc" id="L8126">            int tX = cmpX;</span>
<span class="nc bnc" id="L8127" title="All 2 branches missed.">            if (isOppositeSide) {</span>
<span class="nc bnc" id="L8128" title="All 2 branches missed.">                if (rtl) {</span>
<span class="nc" id="L8129">                    tX += leftPadding;</span>
                } else {
<span class="nc" id="L8131">                    tX = tX + cmpWidth - leftPadding - stateIconSize;</span>
                }
<span class="nc" id="L8133">                cmpWidth -= leftPadding - stateIconSize;</span>
            } else {
<span class="nc" id="L8135">                preserveSpaceForState = stateIconSize + gap;</span>
<span class="nc bnc" id="L8136" title="All 2 branches missed.">                if (rtl) {</span>
<span class="nc" id="L8137">                    tX = tX + cmpWidth - leftPadding - stateIconSize;</span>
                } else {
<span class="nc" id="L8139">                    tX += leftPadding;</span>
                }
            }

<span class="nc" id="L8143">            drawImage(nativeGraphics, stateIcon, tX, stateIconYPosition);</span>
        }

        //default for bottom left alignment
<span class="fc" id="L8147">        int x = cmpX + leftPadding + preserveSpaceForState;</span>
<span class="fc" id="L8148">        int y = cmpY + topPadding;</span>

<span class="fc" id="L8150">        int align = reverseAlignForBidi(rtl, style.getAlignment());</span>

<span class="fc" id="L8152">        int textPos = reverseAlignForBidi(rtl, textPosition);</span>

        //set initial x,y position according to the alignment and textPosition
<span class="pc bpc" id="L8155" title="2 of 4 branches missed.">        switch (align) {</span>
            case Component.LEFT:
<span class="pc bpc" id="L8157" title="2 of 3 branches missed.">                switch (textPos) {</span>
                    case Label.LEFT:
                    case Label.RIGHT:
<span class="pc bpc" id="L8160" title="1 of 2 branches missed.">                        y = y + (cmpHeight - (topPadding + bottomPadding + Math.max(((icon != null) ? iconHeight : 0), fontHeight))) / 2;</span>
<span class="fc" id="L8161">                        break;</span>
                    case Label.BOTTOM:
                    case Label.TOP:
<span class="nc bnc" id="L8164" title="All 2 branches missed.">                        y = y + (cmpHeight - (topPadding + bottomPadding + ((icon != null) ? iconHeight + gap : 0) + fontHeight)) / 2;</span>
                        break;
                }
<span class="fc" id="L8167">                break;</span>
            case Component.CENTER:
<span class="pc bpc" id="L8169" title="2 of 3 branches missed.">                switch (textPos) {</span>
                    case Label.LEFT:
                    case Label.RIGHT:
<span class="pc bpc" id="L8172" title="1 of 2 branches missed.">                        x = x + (cmpWidth - (preserveSpaceForState</span>
                                + leftPadding
                                + rightPadding
                                + ((icon != null) ? iconWidth + gap : 0)
                                + stringWidth)) / 2;
<span class="fc" id="L8177">                        x = Math.max(x, cmpX + leftPadding + preserveSpaceForState);</span>
<span class="pc bpc" id="L8178" title="1 of 2 branches missed.">                        y = y + (cmpHeight - (topPadding</span>
                                + bottomPadding
<span class="fc" id="L8180">                                + Math.max(((icon != null) ? iconHeight : 0),</span>
                                fontHeight))) / 2;
<span class="fc" id="L8182">                        break;</span>
                    case Label.BOTTOM:
                    case Label.TOP:
<span class="nc bnc" id="L8185" title="All 2 branches missed.">                        x = x + (cmpWidth - (preserveSpaceForState + leftPadding</span>
                                + rightPadding
<span class="nc" id="L8187">                                + Math.max(((icon != null) ? iconWidth + gap : 0),</span>
                                stringWidth))) / 2;
<span class="nc" id="L8189">                        x = Math.max(x, cmpX + leftPadding + preserveSpaceForState);</span>
<span class="nc bnc" id="L8190" title="All 2 branches missed.">                        y = y + (cmpHeight - (topPadding</span>
                                + bottomPadding
                                + ((icon != null) ? iconHeight + gap : 0)
                                + fontHeight)) / 2;
                        break;
                }
<span class="fc" id="L8196">                break;</span>
            case Component.RIGHT:
<span class="nc bnc" id="L8198" title="All 3 branches missed.">                switch (textPos) {</span>
                    case Label.LEFT:
                    case Label.RIGHT:
<span class="nc bnc" id="L8201" title="All 2 branches missed.">                        x = cmpX + cmpWidth - rightPadding</span>
                                - (((icon != null) ? (iconWidth + gap) : 0)
                                + stringWidth);
<span class="nc bnc" id="L8204" title="All 2 branches missed.">                        if (rtl) {</span>
<span class="nc" id="L8205">                            x = Math.max(x - preserveSpaceForState, cmpX + leftPadding);</span>
                        } else {
<span class="nc" id="L8207">                            x = Math.max(x, cmpX + leftPadding + preserveSpaceForState);</span>
                        }
<span class="nc bnc" id="L8209" title="All 2 branches missed.">                        y = y + (cmpHeight - (topPadding</span>
                                + bottomPadding
<span class="nc" id="L8211">                                + Math.max(((icon != null) ? iconHeight : 0),</span>
                                fontHeight))) / 2;
<span class="nc" id="L8213">                        break;</span>
                    case Label.BOTTOM:
                    case Label.TOP:
<span class="nc bnc" id="L8216" title="All 2 branches missed.">                        x = cmpX + cmpWidth - rightPadding</span>
<span class="nc" id="L8217">                                - (Math.max(((icon != null) ? (iconWidth) : 0),</span>
                                stringWidth));
<span class="nc" id="L8219">                        x = Math.max(x, cmpX + leftPadding + preserveSpaceForState);</span>
<span class="nc bnc" id="L8220" title="All 2 branches missed.">                        y = y + (cmpHeight - (topPadding</span>
                                + bottomPadding
                                + ((icon != null) ? iconHeight + gap : 0) + fontHeight)) / 2;
                        break;
                }
<span class="nc" id="L8225">                break;</span>
            default:
                break;
        }

<span class="fc" id="L8230">        int textSpaceW = cmpWidth - rightPadding - leftPadding;</span>

<span class="pc bpc" id="L8232" title="5 of 6 branches missed.">        if (icon != null &amp;&amp; (textPos == Label.RIGHT || textPos == Label.LEFT)) {</span>
<span class="nc" id="L8233">            textSpaceW = textSpaceW - iconWidth;</span>
        }

<span class="pc bpc" id="L8236" title="1 of 2 branches missed.">        if (stateIcon != null) {</span>
<span class="nc" id="L8237">            textSpaceW = textSpaceW - stateIconSize;</span>
        } else {
<span class="fc" id="L8239">            textSpaceW = textSpaceW - preserveSpaceForState;</span>
        }

<span class="pc bpc" id="L8242" title="1 of 2 branches missed.">        if (icon == null) {</span>
            // no icon only string
<span class="fc" id="L8244">            drawLabelString(nativeGraphics, nativeFont, text, x, y, textSpaceW, isTickerRunning, tickerShiftText,</span>
                    textDecoration, rtl, endsWith3Points, stringWidth, fontHeight);
        } else {
<span class="nc" id="L8247">            int strWidth = stringWidth;</span>
            int iconStringWGap;
            int iconStringHGap;

<span class="nc bnc" id="L8251" title="All 5 branches missed.">            switch (textPos) {</span>
                case Label.LEFT:
<span class="nc bnc" id="L8253" title="All 2 branches missed.">                    if (iconHeight &gt; fontHeight) {</span>
<span class="nc" id="L8254">                        iconStringHGap = (iconHeight - fontHeight) / 2;</span>
<span class="nc" id="L8255">                        strWidth = drawLabelStringValign(nativeGraphics, nativeFont, text, x, y, textSpaceW, isTickerRunning,</span>
                                tickerShiftText, textDecoration, rtl, endsWith3Points, strWidth, iconStringHGap, iconHeight,
                                fontHeight, valign);

<span class="nc" id="L8259">                        drawImage(nativeGraphics, icon, x + strWidth + gap, y);</span>
                    } else {
<span class="nc" id="L8261">                        iconStringHGap = (fontHeight - iconHeight) / 2;</span>
<span class="nc" id="L8262">                        strWidth = drawLabelString(nativeGraphics, nativeFont, text, x, y, textSpaceW, isTickerRunning,</span>
                                tickerShiftText, textDecoration, rtl, endsWith3Points, strWidth, fontHeight);

<span class="nc" id="L8265">                        drawImage(nativeGraphics, icon, x + strWidth + gap, y + iconStringHGap);</span>
                    }
<span class="nc" id="L8267">                    break;</span>
                case Label.RIGHT:
<span class="nc bnc" id="L8269" title="All 2 branches missed.">                    if (iconHeight &gt; fontHeight) {</span>
<span class="nc" id="L8270">                        iconStringHGap = (iconHeight - fontHeight) / 2;</span>
<span class="nc" id="L8271">                        drawImage(nativeGraphics, icon, x, y);</span>
<span class="nc" id="L8272">                        drawLabelStringValign(nativeGraphics, nativeFont, text, x + iconWidth + gap, y, textSpaceW, isTickerRunning,</span>
                                tickerShiftText, textDecoration, rtl, endsWith3Points, stringWidth, iconStringHGap, iconHeight, fontHeight, valign);
                    } else {
<span class="nc" id="L8275">                        iconStringHGap = (fontHeight - iconHeight) / 2;</span>
<span class="nc" id="L8276">                        drawImage(nativeGraphics, icon, x, y + iconStringHGap);</span>
<span class="nc" id="L8277">                        drawLabelString(nativeGraphics, nativeFont, text, x + iconWidth + gap, y, textSpaceW, isTickerRunning,</span>
                                tickerShiftText, textDecoration, rtl, endsWith3Points, stringWidth, fontHeight);
                    }
<span class="nc" id="L8280">                    break;</span>
                case Label.BOTTOM:
                    //center align the smaller
<span class="nc bnc" id="L8283" title="All 2 branches missed.">                    if (iconWidth &gt; strWidth) {</span>
<span class="nc" id="L8284">                        iconStringWGap = (iconWidth - strWidth) / 2;</span>
<span class="nc" id="L8285">                        drawImage(nativeGraphics, icon, x, y);</span>
<span class="nc" id="L8286">                        drawLabelString(nativeGraphics, nativeFont, text, x + iconStringWGap, y + iconHeight + gap, textSpaceW,</span>
                                isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, stringWidth, fontHeight);
                    } else {
<span class="nc" id="L8289">                        iconStringWGap = (Math.min(strWidth, textSpaceW) - iconWidth) / 2;</span>
<span class="nc" id="L8290">                        drawImage(nativeGraphics, icon, x + iconStringWGap, y);</span>

<span class="nc" id="L8292">                        drawLabelString(nativeGraphics, nativeFont, text, x, y + iconHeight + gap, textSpaceW, isTickerRunning,</span>
                                tickerShiftText, textDecoration, rtl, endsWith3Points, stringWidth, fontHeight);
                    }
<span class="nc" id="L8295">                    break;</span>
                case Label.TOP:
                    //center align the smaller
<span class="nc bnc" id="L8298" title="All 2 branches missed.">                    if (iconWidth &gt; strWidth) {</span>
<span class="nc" id="L8299">                        iconStringWGap = (iconWidth - strWidth) / 2;</span>
<span class="nc" id="L8300">                        drawLabelString(nativeGraphics, nativeFont, text, x + iconStringWGap, y, textSpaceW, isTickerRunning,</span>
                                tickerShiftText, textDecoration, rtl, endsWith3Points, stringWidth, fontHeight);
<span class="nc" id="L8302">                        drawImage(nativeGraphics, icon, x, y + fontHeight + gap);</span>
                    } else {
<span class="nc" id="L8304">                        iconStringWGap = (Math.min(strWidth, textSpaceW) - iconWidth) / 2;</span>
<span class="nc" id="L8305">                        drawLabelString(nativeGraphics, nativeFont, text, x, y, textSpaceW, isTickerRunning, tickerShiftText,</span>
                                textDecoration, rtl, endsWith3Points, stringWidth, fontHeight);
<span class="nc" id="L8307">                        drawImage(nativeGraphics, icon, x + iconStringWGap, y + fontHeight + gap);</span>
                    }
                    break;
            }
        }
<span class="fc" id="L8312">        setAlpha(nativeGraphics, alpha);</span>
<span class="fc" id="L8313">    }</span>

    /**
     * Implements the drawString for the text component and adjust the valign
     * assuming the icon is in one of the sides
     */
    private int drawLabelStringValign(
            Object nativeGraphics, Object nativeFont, String str, int x, int y, int textSpaceW,
            boolean isTickerRunning, int tickerShiftText, int textDecoration, boolean rtl,
            boolean endsWith3Points, int textWidth,
            int iconStringHGap, int iconHeight, int fontHeight, int valign) {
<span class="nc bnc" id="L8324" title="All 3 branches missed.">        switch (valign) {</span>
            case Component.TOP:
<span class="nc" id="L8326">                return drawLabelString(nativeGraphics, nativeFont, str, x, y, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, textWidth, fontHeight);</span>
            case Component.CENTER:
<span class="nc" id="L8328">                return drawLabelString(nativeGraphics, nativeFont, str, x, y + iconHeight / 2 - fontHeight / 2, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, textWidth, fontHeight);</span>
            default:
<span class="nc" id="L8330">                return drawLabelString(nativeGraphics, nativeFont, str, x, y + iconStringHGap, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, textWidth, fontHeight);</span>
        }
    }

    /**
     * Implements the drawString for the text component and adjust the valign
     * assuming the icon is in one of the sides
     */
    private int drawLabelString(Object nativeGraphics, Object nativeFont, String text, int x, int y, int textSpaceW,
                                boolean isTickerRunning, int tickerShiftText, int textDecoration, boolean rtl, boolean endsWith3Points, int textWidth,
                                int fontHeight) {
<span class="fc" id="L8341">        int cx = getClipX(nativeGraphics);</span>
<span class="fc" id="L8342">        int cy = getClipY(nativeGraphics);</span>
<span class="fc" id="L8343">        int cw = getClipWidth(nativeGraphics);</span>
<span class="fc" id="L8344">        int ch = getClipHeight(nativeGraphics);</span>
<span class="fc" id="L8345">        clipRect(nativeGraphics, x, cy, textSpaceW, ch);</span>

<span class="fc" id="L8347">        int drawnW = drawLabelText(nativeGraphics, textDecoration, rtl, isTickerRunning, endsWith3Points, nativeFont,</span>
                textWidth, textSpaceW, tickerShiftText, text, x, y, fontHeight);

<span class="fc" id="L8350">        setClip(nativeGraphics, cx, cy, cw, ch);</span>

<span class="fc" id="L8352">        return drawnW;</span>
    }

    private boolean fastCharWidthCheck(String s, int length, int width, int charWidth, Object f) {
<span class="nc bnc" id="L8356" title="All 2 branches missed.">        if (length * charWidth &lt; width) {</span>
<span class="nc" id="L8357">            return true;</span>
        }
<span class="nc" id="L8359">        length = Math.min(s.length(), length);</span>
<span class="nc bnc" id="L8360" title="All 2 branches missed.">        return stringWidth(f, s.substring(0, length)) &lt; width;</span>
    }

    /**
     * Draws the text of a label
     *
     * @param nativeGraphics graphics context
     * @param textDecoration decoration information for the text
     * @param text           the text for the label
     * @param x              position for the label
     * @param y              position for the label
     * @param txtW           stringWidth(text) equivalent which is faster than just
     *                       invoking string width all the time
     * @param textSpaceW     the width available for the component
     * @return the space used by the drawing
     */
    protected int drawLabelText(Object nativeGraphics, int textDecoration, boolean rtl, boolean isTickerRunning,
                                boolean endsWith3Points, Object nativeFont, int txtW, int textSpaceW, int shiftText, String text, int x, int y, int fontHeight) {
<span class="pc bpc" id="L8378" title="3 of 4 branches missed.">        if ((!isTickerRunning) || rtl) {</span>
            //if there is no space to draw the text add ... at the end
<span class="pc bpc" id="L8380" title="3 of 4 branches missed.">            if (txtW &gt; textSpaceW &amp;&amp; textSpaceW &gt; 0) {</span>
                // Handling of adding 3 points and in fact all text positioning when the text is bigger than
                // the allowed space is handled differently in RTL, this is due to the reverse algorithm
                // effects - i.e. when the text includes both Hebrew/Arabic and English/numbers then simply
                // trimming characters from the end of the text (as done with LTR) won't do.
                // Instead we simple reposition the text, and draw the 3 points, this is quite simple, but
                // the downside is that a part of a letter may be shown here as well.

<span class="nc bnc" id="L8388" title="All 6 branches missed.">                if (rtl &amp;&amp; !isTickerRunning &amp;&amp; endsWith3Points) {</span>
                    // PMD Fix (CollapsibleIfStatements): Separate combined RTL and ticker checks into a single conditional.
<span class="nc" id="L8390">                    String points = &quot;...&quot;;</span>
<span class="nc" id="L8391">                    int pointsW = stringWidth(nativeFont, points);</span>
<span class="nc" id="L8392">                    drawString(nativeGraphics, nativeFont, points, shiftText + x, y, textDecoration, fontHeight);</span>
<span class="nc" id="L8393">                    clipRect(nativeGraphics, pointsW + shiftText + x, y, textSpaceW - pointsW, fontHeight);</span>
                }
<span class="nc bnc" id="L8395" title="All 2 branches missed.">                if (rtl) {</span>
<span class="nc" id="L8396">                    x = x - txtW + textSpaceW;</span>
<span class="nc bnc" id="L8397" title="All 2 branches missed.">                } else if (endsWith3Points) {</span>
<span class="nc" id="L8398">                    String points = &quot;...&quot;;</span>
<span class="nc" id="L8399">                    int index = 1;</span>
<span class="nc" id="L8400">                    int widest = charWidth(nativeFont, 'W');</span>
<span class="nc" id="L8401">                    int pointsW = stringWidth(nativeFont, points);</span>
<span class="nc" id="L8402">                    int textLen = text.length();</span>
<span class="nc bnc" id="L8403" title="All 4 branches missed.">                    while (fastCharWidthCheck(text, index, textSpaceW - pointsW, widest, nativeFont) &amp;&amp; index &lt; textLen) {</span>
<span class="nc" id="L8404">                        index++;</span>
                    }
<span class="nc" id="L8406">                    text = text.substring(0, Math.min(textLen, Math.max(1, index - 1))) + points;</span>
<span class="nc" id="L8407">                    txtW = stringWidth(nativeFont, text);</span>
                }
            }
        }

<span class="fc" id="L8412">        drawString(nativeGraphics, nativeFont, text, shiftText + x, y, textDecoration, fontHeight);</span>
<span class="fc" id="L8413">        return Math.min(txtW, textSpaceW);</span>
    }

    /**
     * Draw a string using the current font and color in the x,y coordinates.
     * The font is drawn from the top position and not the baseline.
     *
     * @param nativeGraphics the graphics context
     * @param nativeFont     the font used
     * @param str            the string to be drawn.
     * @param x              the x coordinate.
     * @param y              the y coordinate.
     * @param textDecoration Text decoration bitmask (See Style's
     *                       TEXT_DECORATION_* constants)
     */
    public void drawString(Object nativeGraphics, Object nativeFont, String str, int x, int y, int textDecoration) {
<span class="fc" id="L8429">        drawString(nativeGraphics, nativeFont, str, x, y, textDecoration, getHeight(nativeFont));</span>
<span class="fc" id="L8430">    }</span>

    /**
     * Draw a string using the current font and color in the x,y coordinates.
     * The font is drawn from the top position and not the baseline.
     *
     * @param nativeGraphics the graphics context
     * @param nativeFont     the font used
     * @param str            the string to be drawn.
     * @param x              the x coordinate.
     * @param y              the y coordinate.
     * @param textDecoration Text decoration bitmask (See Style's
     *                       TEXT_DECORATION_* constants)
     */
    private void drawString(Object nativeGraphics, Object nativeFont, String str, int x, int y, int textDecoration, int fontHeight) {
<span class="pc bpc" id="L8445" title="1 of 2 branches missed.">        if (str.length() == 0) {</span>
<span class="nc" id="L8446">            return;</span>
        }

        // this if has only the minor effect of providing a slighly faster execution path
<span class="pc bpc" id="L8450" title="1 of 2 branches missed.">        if (textDecoration != 0) {</span>
<span class="nc bnc" id="L8451" title="All 2 branches missed.">            boolean raised = (textDecoration &amp; Style.TEXT_DECORATION_3D) != 0;</span>
<span class="nc bnc" id="L8452" title="All 2 branches missed.">            boolean lowerd = (textDecoration &amp; Style.TEXT_DECORATION_3D_LOWERED) != 0;</span>
<span class="nc bnc" id="L8453" title="All 2 branches missed.">            boolean north = (textDecoration &amp; Style.TEXT_DECORATION_3D_SHADOW_NORTH) != 0;</span>
<span class="nc bnc" id="L8454" title="All 6 branches missed.">            if (raised || lowerd || north) {</span>
<span class="nc" id="L8455">                textDecoration = textDecoration &amp; (~Style.TEXT_DECORATION_3D) &amp; (~Style.TEXT_DECORATION_3D_LOWERED) &amp; (~Style.TEXT_DECORATION_3D_SHADOW_NORTH);</span>
<span class="nc" id="L8456">                int c = getColor(nativeGraphics);</span>
<span class="nc" id="L8457">                int a = getAlpha(nativeGraphics);</span>
<span class="nc" id="L8458">                int newColor = 0;</span>
<span class="nc" id="L8459">                int offset = -2;</span>
<span class="nc bnc" id="L8460" title="All 2 branches missed.">                if (lowerd) {</span>
<span class="nc" id="L8461">                    offset = 2;</span>
<span class="nc" id="L8462">                    newColor = 0xffffff;</span>
<span class="nc bnc" id="L8463" title="All 2 branches missed.">                } else if (north) {</span>
<span class="nc" id="L8464">                    offset = 2;</span>
                }
<span class="nc" id="L8466">                setColor(nativeGraphics, newColor);</span>
<span class="nc" id="L8467">                concatenateAlpha(nativeGraphics, 140);</span>
<span class="nc" id="L8468">                drawString(nativeGraphics, nativeFont, str, x, y + offset, textDecoration, fontHeight);</span>
<span class="nc" id="L8469">                setAlpha(nativeGraphics, a);</span>
<span class="nc" id="L8470">                setColor(nativeGraphics, c);</span>
<span class="nc" id="L8471">                drawString(nativeGraphics, nativeFont, str, x, y, textDecoration, fontHeight);</span>
<span class="nc" id="L8472">                return;</span>
            }
<span class="nc" id="L8474">            drawString(nativeGraphics, str, x, y);</span>
<span class="nc bnc" id="L8475" title="All 2 branches missed.">            if ((textDecoration &amp; Style.TEXT_DECORATION_UNDERLINE) != 0) {</span>
<span class="nc" id="L8476">                drawLine(nativeGraphics, x, y + fontHeight - 1, x + stringWidth(nativeFont, str), y + fontHeight - 1);</span>
            }
<span class="nc bnc" id="L8478" title="All 2 branches missed.">            if ((textDecoration &amp; Style.TEXT_DECORATION_STRIKETHRU) != 0) {</span>
<span class="nc" id="L8479">                drawLine(nativeGraphics, x, y + fontHeight / 2, x + stringWidth(nativeFont, str), y + fontHeight / 2);</span>
            }
<span class="nc bnc" id="L8481" title="All 2 branches missed.">            if ((textDecoration &amp; Style.TEXT_DECORATION_OVERLINE) != 0) {</span>
<span class="nc" id="L8482">                drawLine(nativeGraphics, x, y, x + stringWidth(nativeFont, str), y);</span>
            }
<span class="nc" id="L8484">        } else {</span>
<span class="fc" id="L8485">            drawString(nativeGraphics, str, x, y);</span>
        }
<span class="fc" id="L8487">    }</span>

    /**
     * Reverses alignment in the case of bidi
     */
    private int reverseAlignForBidi(boolean rtl, int align) {
<span class="pc bpc" id="L8493" title="1 of 2 branches missed.">        if (rtl) {</span>
<span class="nc bnc" id="L8494" title="All 3 branches missed.">            switch (align) {</span>
                case Component.RIGHT:
<span class="nc" id="L8496">                    return Component.LEFT;</span>
                case Component.LEFT:
<span class="nc" id="L8498">                    return Component.RIGHT;</span>
            }
        }
<span class="fc" id="L8501">        return align;</span>
    }

    /**
     * Makes it easier to pass hints to the underlying implementation for quicker hacks/pipelines
     *
     * @param key   the key
     * @param value the value
     */
    public void setPlatformHint(String key, String value) {
<span class="nc" id="L8511">    }</span>

    //METHODS FOR DEALING Local Notifications
    public void scheduleLocalNotification(LocalNotification notif, long firstTime, int repeat) {
<span class="nc" id="L8515">    }</span>

    public void cancelLocalNotification(String notificationId) {
<span class="nc" id="L8518">    }</span>

    /**
     * Gets the preferred time (in seconds) between background fetches.
     *
     * @return The time interval in seconds.
     * @see #isBackgroundFetchSupported()
     * @see #setPreferredBackgroundFetchInterval(int)
     * @see com.codename1.background.BackgroundFetch
     * @see com.codename1.ui.Display.setPreferredBackgroundFetchInterval(int)
     */
    public int getPreferredBackgroundFetchInterval() {
<span class="nc bnc" id="L8530" title="All 2 branches missed.">        if (isBackgroundFetchSupported()) {</span>
<span class="nc" id="L8531">            return Preferences.get(&quot;$$CN1_BACKGROUND_FETCH_INTERVAL&quot;, 60 * 60);</span>
        } else {
<span class="nc" id="L8533">            return -1;</span>
        }
    }
    //ENDS METHODS FOR DEALING Local Notifications

    /**
     * Sets the preferred time interval between background fetches.  This is only a
     * preferred interval and is not guaranteed.  Some platforms, like iOS, maintain sovereign
     * control over when and if background fetches will be allowed. This number is used
     * only as a guideline.
     *
     * &lt;p&gt;&lt;strong&gt;This method must be called in order to activate background fetch.&lt;/strong&gt;&gt;&lt;/p&gt;
     * &lt;p&gt;Note: If the platform doesn't support background fetch (i.e. {@link #isBackgroundFetchSupported() } returns {@code false},
     * then this method does nothing.&lt;/p&gt;
     *
     * @param seconds The time interval in seconds.
     * @see #isBackgroundFetchSupported()
     * @see #getPreferredBackgroundFetchInterval()
     * @see com.codename1.background.BackgroundFetch
     * @see com.codename1.ui.Display.setPreferredBackgroundFetchInterval(int)
     */
    public void setPreferredBackgroundFetchInterval(int seconds) {
<span class="nc bnc" id="L8555" title="All 2 branches missed.">        if (isBackgroundFetchSupported()) {</span>
<span class="nc" id="L8556">            Preferences.set(&quot;$$CN1_BACKGROUND_FETCH_INTERVAL&quot;, seconds);</span>
        }
<span class="nc" id="L8558">    }</span>

    /**
     * Checks to see if the current platform supports background fetch.
     *
     * @return True if the current platform supports background fetch.
     * @see #setPreferredBackgroundFetchInterval(int)
     * @see #getPreferredBackgroundFetchInterval()
     * @see com.codename1.background.BackgroundFetch
     * @see com.codename1.ui.Display.setPreferredBackgroundFetchInterval(int)
     */
    public boolean isBackgroundFetchSupported() {
<span class="nc" id="L8570">        return false;</span>
    }

    public Image gaussianBlurImage(Image image, float radius) {
<span class="nc" id="L8574">        return image;</span>
    }

    public boolean isGaussianBlurSupported() {
<span class="nc" id="L8578">        return false;</span>
    }

    /**
     * Returns true if this device is jailbroken or rooted, false if not or unknown. Notice that this method isn't
     * accurate and can't detect all jailbreak/rooting cases
     *
     * @return true if this device is jailbroken or rooted, false if not or unknown.
     */
    public boolean isJailbrokenDevice() {
<span class="nc" id="L8588">        return false;</span>
    }

    /**
     * Returns the build hints for the simulator, this will only work in the debug environment and it's
     * designed to allow extensions/API's to verify user settings/build hints exist
     *
     * @return map of the build hints that isn't modified without the codename1.arg. prefix
     */
    public Map&lt;String, String&gt; getProjectBuildHints() {
<span class="nc" id="L8598">        return null;</span>
    }

    /**
     * Sets a build hint into the settings while overwriting any previous value. This will only work in the
     * debug environment and it's designed to allow extensions/API's to verify user settings/build hints exist.
     * Important: this will throw an exception outside of the simulator!
     *
     * @param key   the build hint without the codename1.arg. prefix
     * @param value the value for the hint
     */
    public void setProjectBuildHint(String key, String value) {
<span class="nc" id="L8610">        throw new RuntimeException();</span>
    }

    /**
     * Checks to see if you can prompt the user to install the app on their homescreen.
     * This is only relevant for the Javascript port with PWAs.  This is not a &quot;static&quot; property, as it
     * only returns true if the app is in a state that allows you to prompt the user.  E.g. if you have
     * previously prompted the user and they have declined, then this will return false.
     *
     * &lt;p&gt;Best practice is to use {@link #onCanInstallOnHomescreen(java.lang.Runnable) } to be notified
     * when you are allowed to prompt the user for installation.  Then call {@link #promptInstallOnHomescreen() }
     * inside that method - or sometime after.&lt;/p&gt;
     *
     * &lt;h3&gt;Example&lt;/h3&gt;
     * &lt;pre&gt;{@code
     * onCanInstallOnHomescreen(()-&gt;{
     *      if (canInstallOnHomescreen()) {
     *           if (promptInstallOnHomescreen()) {
     *               // User accepted installation
     *           } else {
     *               // user rejected installation
     *           }
     *      }
     * });
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * https://developers.google.com/web/fundamentals/app-install-banners/
     *
     * @return True if you are able to prompt the user to install the app on their homescreen.
     * @see #promptInstallOnHomescreen()
     * @see #onCanInstallOnHomescreen(java.lang.Runnable)
     */
    public boolean canInstallOnHomescreen() {
<span class="nc" id="L8643">        return false;</span>
    }

    /**
     * Prompts the user to install this app on their homescreen.  This is only relevant in the
     * javascript port.
     *
     * @return The result of the user prompt.  {@literal true} if the user accepts the installation,
     * {@literal false} if they reject it.
     * @see #canInstallOnHomescreen()
     * @see #onCanInstallOnHomescreen(java.lang.Runnable)
     */
    public boolean promptInstallOnHomescreen() {
<span class="nc" id="L8656">        return false;</span>
    }

    /**
     * A callback fired when you are allowed to prompt the user to install the app on their homescreen.
     * Only relevant in the javascript port.
     *
     * @param r Runnable that will be run when/if you are permitted to prompt the user to install
     *          the app on their homescreen.
     */
    public void onCanInstallOnHomescreen(Runnable r) {

<span class="nc" id="L8668">    }</span>

    /**
     * Checks whether the platform's native text areas support vertical alignment.
     *
     * @return
     */
    public boolean supportsNativeTextAreaVerticalAlignment() {
<span class="nc" id="L8676">        return false;</span>
    }

    /**
     * Posts a message to the native platform.
     *
     * @param message The message.
     * @since 7.0
     */
    public void postMessage(MessageEvent message) {

<span class="nc" id="L8687">    }</span>

    /**
     * Returns true if the platform is in dark mode, null is returned for
     * unknown status
     *
     * @return true in case of dark mode
     */
    public Boolean isDarkMode() {
<span class="nc" id="L8696">        return null;</span>
    }

    /**
     * Manually announces text to native accessibility services, associating the announcement with
     * a specific component when possible. Components are typically announced automatically when
     * focused; this hook allows platforms to expose announcements triggered outside the normal
     * focus lifecycle. The default implementation is a no-op.
     *
     * @param cmp  the component related to this announcement or {@code null} for the root context
     * @param text the message to announce
     */
    public void announceForAccessibility(Component cmp, String text) {
        // No-op by default. Platforms that support accessibility announcements
        // should override this method.
<span class="fc" id="L8711">    }</span>

<span class="nc" id="L8713">    class RPush implements Runnable {</span>
        public void run() {
<span class="nc" id="L8715">            final long pushId = Preferences.get(&quot;push_id&quot;, (long) -1);</span>
<span class="nc bnc" id="L8716" title="All 4 branches missed.">            if (pushId &gt; -1 &amp;&amp; callback != null) {</span>
<span class="nc" id="L8717">                callback.registeredForPush(&quot;&quot; + pushId);</span>
            }
<span class="nc" id="L8719">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>