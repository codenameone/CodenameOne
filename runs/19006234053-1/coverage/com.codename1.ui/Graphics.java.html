<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Graphics.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.ui</a> &gt; <span class="el_source">Graphics.java</span></div><h1>Graphics.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores
 * CA 94065 USA or visit www.oracle.com if you need additional information or
 * have any questions.
 */
package com.codename1.ui;

import com.codename1.impl.CodenameOneImplementation;
import com.codename1.ui.geom.GeneralPath;
import com.codename1.ui.geom.Rectangle;
import com.codename1.ui.geom.Shape;

/**
 * Abstracts the underlying platform graphics context thus allowing us to achieve
 * portability between MIDP devices and CDC devices. This abstaction simplifies
 * and unifies the Graphics implementations of various platforms.
 *
 * &lt;p&gt;A graphics instance should never be created by the developer and is always accessed
 * using either a paint callback or a mutable image. There is no supported  way to create this
 * object directly.
 */
public final class Graphics {

    /**
     * Rendering hint to indicate that the context should prefer to render
     * primitives in a quick way, at the cost of quality, if there is an
     * expensive operation.
     *
     * @see #setRenderingHints(int)
     * @see #getRenderingHints()
     * @since 7.0
     */
    public static final int RENDERING_HINT_FAST = 1;
    /**
     * Flag that specifies that native peers are rendered &quot;behind&quot; the this
     * graphics context.  The main difference is that drawPeerComponent() will
     * call clearRect() for its bounds to &quot;poke a hole&quot; in the graphics context
     * to see through to the native layer.
     */
    boolean paintPeersBehind;
    private int xTranslate;
    private int yTranslate;
    private Transform translation;
    private GeneralPath tmpClipShape;
    /// A buffer shape to use when we need to transform a shape
    private int color;
    private Paint paint;
<span class="fc" id="L66">    private Font current = Font.getDefaultFont();</span>
    private final CodenameOneImplementation impl;
    private Object nativeGraphics;
    private Object[] nativeGraphicsState;
<span class="fc" id="L70">    private float scaleX = 1, scaleY = 1;</span>

    /**
     * Constructing new graphics with a given javax.microedition.lcdui.Graphics
     *
     * @param g an implementation dependent native graphics instance
     */
<span class="fc" id="L77">    Graphics(Object nativeGraphics) {</span>
<span class="fc" id="L78">        setGraphics(nativeGraphics);</span>
<span class="fc" id="L79">        impl = Display.impl;</span>
<span class="fc" id="L80">    }</span>

    protected void finalize() {
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">        if (nativeGraphics != null) {</span>
<span class="fc" id="L84">            impl.disposeGraphics(nativeGraphics);</span>
        }
<span class="fc" id="L86">    }</span>

    private Transform translation() {
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        if (translation == null) {</span>
<span class="fc" id="L90">            translation = Transform.makeTranslation(xTranslate, yTranslate);</span>
        } else {
<span class="nc" id="L92">            translation.setTranslation(xTranslate, yTranslate);</span>
        }
<span class="fc" id="L94">        return translation;</span>
    }

    private GeneralPath tmpClipShape() {
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">        if (tmpClipShape == null) {</span>
<span class="fc" id="L99">            tmpClipShape = new GeneralPath();</span>
        }
<span class="fc" id="L101">        return tmpClipShape;</span>
    }

    /**
     * Returns the underlying native graphics object
     *
     * @return the underlying native graphics object
     */
    Object getGraphics() {
<span class="fc" id="L110">        return nativeGraphics;</span>
    }

    /**
     * Setting graphics with a given javax.microedition.lcdui.Graphics
     *
     * @param g a given javax.microedition.lcdui.Graphics
     */
    void setGraphics(Object g) {
<span class="fc" id="L119">        this.nativeGraphics = g;</span>
<span class="fc" id="L120">    }</span>

    /**
     * Translates the X/Y location for drawing on the underlying surface. Translation
     * is incremental so the new value will be added to the current translation and
     * in order to reset translation we have to invoke
     * {@code translate(-getTranslateX(), -getTranslateY()) }
     *
     * @param x the x coordinate
     * @param y the y coordinate
     */
    public void translate(int x, int y) {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (impl.isTranslationSupported()) {</span>
<span class="fc" id="L133">            impl.translate(nativeGraphics, x, y);</span>
        } else {
<span class="fc" id="L135">            xTranslate += x;</span>
<span class="fc" id="L136">            yTranslate += y;</span>
        }
<span class="fc" id="L138">    }</span>

    /**
     * Returns the current x translate value
     *
     * @return the current x translate value
     */
    public int getTranslateX() {
<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (impl.isTranslationSupported()) {</span>
<span class="fc" id="L147">            return impl.getTranslateX(nativeGraphics);</span>
        } else {
<span class="fc" id="L149">            return xTranslate;</span>
        }
    }

    /**
     * Returns the current y translate value
     *
     * @return the current y translate value
     */
    public int getTranslateY() {
<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (impl.isTranslationSupported()) {</span>
<span class="fc" id="L160">            return impl.getTranslateY(nativeGraphics);</span>
        } else {
<span class="fc" id="L162">            return yTranslate;</span>
        }
    }

    /**
     * Returns the current color
     *
     * @return the RGB graphics color
     */
    public int getColor() {
<span class="fc" id="L172">        return color;</span>
    }

    /**
     * Sets the current rgb color while ignoring any potential alpha component within
     * said color value.
     *
     * @param RGB the RGB value for the color.
     */
    public void setColor(int RGB) {
<span class="fc" id="L182">        paint = null;</span>
<span class="fc" id="L183">        color = 0xffffff &amp; RGB;</span>
<span class="fc" id="L184">        impl.setColor(nativeGraphics, color);</span>
<span class="fc" id="L185">    }</span>

    /**
     * Sets paint to be used for filling shapes.  This is only used for the {@link #fillShape(com.codename1.ui.geom.Shape) } method.
     *
     * @param paint
     * @see LinearGradientPaint
     * @since 7.0
     */
    public void setColor(Paint paint) {
<span class="fc" id="L195">        this.paint = paint;</span>
<span class="fc" id="L196">    }</span>

    /**
     * Gets the current {@link Paint} that is set to be used for filling shapes.
     *
     * @return The paint that is to be used for filling shapes.
     * @see LinearGradientPaint
     * @since 7.0
     */
    public Paint getPaint() {
<span class="fc" id="L206">        return paint;</span>
    }

    /**
     * Sets the current rgb color while ignoring any potential alpha component within
     * said color value.
     *
     * @param RGB the RGB value for the color.
     * @return The previous color value.
     * @since 8.0
     */
    public int setAndGetColor(int RGB) {
<span class="fc" id="L218">        int old = getColor();</span>
<span class="fc" id="L219">        setColor(RGB);</span>
<span class="fc" id="L220">        return old;</span>
    }

    /**
     * Returns the font used with the drawString method calls
     *
     * @return the font used with the drawString method calls
     */
    public Font getFont() {
<span class="fc" id="L229">        return current;</span>
    }

    /**
     * Sets the font to use with the drawString method calls
     *
     * @param font the font used with the drawString method calls
     */
    public void setFont(Font font) {

<span class="fc" id="L239">        this.current = font;</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (!(font instanceof CustomFont)) {</span>
<span class="fc" id="L241">            impl.setNativeFont(nativeGraphics, font.getNativeFont());</span>
        }
<span class="fc" id="L243">    }</span>

    /**
     * Returns the x clipping position
     *
     * @return the x clipping position
     */
    public int getClipX() {
<span class="fc" id="L251">        return impl.getClipX(nativeGraphics) - xTranslate;</span>
    }

    /**
     * Returns the clip as an x,y,w,h array
     *
     * @return clip array copy
     */
    public int[] getClip() {
<span class="fc" id="L260">        return new int[]{getClipX(), getClipY(), getClipWidth(), getClipHeight()};</span>
    }

    /**
     * Sets the clip from an array containing x, y, width, height value
     *
     * @param clip 4 element array
     */
    public void setClip(int[] clip) {
<span class="nc" id="L269">        setClip(clip[0], clip[1], clip[2], clip[3]);</span>
<span class="nc" id="L270">    }</span>

    /**
     * Clips the Graphics context to the Shape.
     * &lt;p&gt;This is not supported on all platforms and contexts currently.
     * Use {@link #isShapeClipSupported} to check if the current
     * context supports clipping shapes.&lt;/p&gt;
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/65f531adae2e8c22afc8.js&quot;&gt;&lt;/script&gt;
     * &lt;img src=&quot;https://www.codenameone.com/img/blog/shaped-clipping.png&quot; alt=&quot;Shaped clipping in action&quot; /&gt;
     *
     * @param shape The shape to clip.
     * @see #isShapeClipSupported
     */
    public void setClip(Shape shape) {
<span class="pc bpc" id="L285" title="1 of 4 branches missed.">        if (xTranslate != 0 || yTranslate != 0) {</span>
<span class="fc" id="L286">            GeneralPath p = tmpClipShape();</span>
<span class="fc" id="L287">            p.setShape(shape, translation());</span>
<span class="fc" id="L288">            shape = p;</span>
        }
<span class="fc" id="L290">        impl.setClip(nativeGraphics, shape);</span>
<span class="fc" id="L291">    }</span>

    /**
     * Returns the y clipping position
     *
     * @return the y clipping position
     */
    public int getClipY() {
<span class="fc" id="L299">        return impl.getClipY(nativeGraphics) - yTranslate;</span>
    }

    /**
     * Returns the clip width
     *
     * @return the clip width
     */
    public int getClipWidth() {
<span class="fc" id="L308">        return impl.getClipWidth(nativeGraphics);</span>
    }

    /**
     * Returns the clip height
     *
     * @return the clip height
     */
    public int getClipHeight() {
<span class="fc" id="L317">        return impl.getClipHeight(nativeGraphics);</span>
    }

    /**
     * Clips the given rectangle by intersecting with the current clipping region, this
     * method can thus only shrink the clipping region and never increase it.
     *
     * @param x      the x coordinate of the rectangle to intersect the clip with
     * @param y      the y coordinate of the rectangle to intersect the clip with
     * @param width  the width of the rectangle to intersect the clip with
     * @param height the height of the rectangle to intersect the clip with
     */
    public void clipRect(int x, int y, int width, int height) {
<span class="fc" id="L330">        impl.clipRect(nativeGraphics, xTranslate + x, yTranslate + y, width, height);</span>
<span class="fc" id="L331">    }</span>

    /**
     * Updates the clipping region to match the given region exactly
     *
     * @param x      the x coordinate of the new clip rectangle.
     * @param y      the y coordinate of the new clip rectangle.
     * @param width  the width of the new clip rectangle.
     * @param height the height of the new clip rectangle.
     */
    public void setClip(int x, int y, int width, int height) {
<span class="fc" id="L342">        impl.setClip(nativeGraphics, xTranslate + x, yTranslate + y, width, height);</span>
<span class="fc" id="L343">    }</span>

    /**
     * Pushes the current clip onto the clip stack.  It can later be restored
     * using {@link #popClip}.
     */
    public void pushClip() {
<span class="nc" id="L350">        impl.pushClip(nativeGraphics);</span>
<span class="nc" id="L351">    }</span>

    /**
     * Pops the top clip from the clip stack and sets it as the current clip.
     */
    public void popClip() {
<span class="nc" id="L357">        impl.popClip(nativeGraphics);</span>
<span class="nc" id="L358">    }</span>

    /**
     * Draws a line between the 2 X/Y coordinates
     *
     * @param x1 first x position
     * @param y1 first y position
     * @param x2 second x position
     * @param y2 second y position
     */
    public void drawLine(int x1, int y1, int x2, int y2) {
<span class="fc" id="L369">        impl.drawLine(nativeGraphics, xTranslate + x1, yTranslate + y1, xTranslate + x2, yTranslate + y2);</span>

<span class="fc" id="L371">    }</span>

    /**
     * Fills the rectangle from the given position according to the width/height
     * minus 1 pixel according to the convention in Java.
     *
     * @param x      the x coordinate of the rectangle to be filled.
     * @param y      the y coordinate of the rectangle to be filled.
     * @param width  the width of the rectangle to be filled.
     * @param height the height of the rectangle to be filled.
     */
    public void fillRect(int x, int y, int width, int height) {
<span class="nc" id="L383">        impl.fillRect(nativeGraphics, xTranslate + x, yTranslate + y, width, height);</span>
<span class="nc" id="L384">    }</span>

    public void drawShadow(Image img, int x, int y, int offsetX, int offsetY, int blurRadius, int spreadRadius, int color, float opacity) {
<span class="nc" id="L387">        impl.drawShadow(nativeGraphics, img.getImage(), xTranslate + x, yTranslate + y, offsetX, offsetY, blurRadius, spreadRadius, color, opacity);</span>
<span class="nc" id="L388">    }</span>

    /**
     * Clears rectangular area of the graphics context.  This will remove any color
     * information that has already been drawn to the graphics context making it transparent.
     * &lt;p&gt;The difference between this method and say {@link #fillRect(int, int, int, int) } with alpha=0 is
     * that fillRect() will just blend with the colors underneath (and thus {@link #fillRect(int, int, int, int) }
     * with an alpha of 0 actually does nothing.&lt;/p&gt;
     * NOTE: In contrast to other drawing methods, coordinates input here
     * are absolute and will not be adjusted by the xTranslate and yTranslate values
     *
     * &lt;p&gt;This method is designed to be used by {@link #drawPeerComponent(com.codename1.ui.PeerComponent) } only.&lt;/p&gt;
     *
     * @param x      The x-coordinate of the box to clear.  In screen coordinates.
     * @param y      The y-coordinate of the box to clear.  In screen coordinates.
     * @param width  The width of the box to clear.
     * @param height The height of the box to clear.
     */
    public void clearRect(int x, int y, int width, int height) {
<span class="nc" id="L407">        clearRectImpl(xTranslate + x, yTranslate + y, width, height);</span>
<span class="nc" id="L408">    }</span>

    /**
     * Clears rectangular area of the graphics context.  This will remove any color
     * information that has already been drawn to the graphics context making it transparent.
     * &lt;p&gt;The difference between this method and say {@link #fillRect(int, int, int, int) } with alpha=0 is
     * that fillRect() will just blend with the colors underneath (and thus {@link #fillRect(int, int, int, int) }
     * with an alpha of 0 actually does nothing.&lt;/p&gt;
     * NOTE: In contrast to other drawing methods, coordinates input here
     * are absolute and will not be adjusted by the xTranslate and yTranslate values
     *
     * &lt;p&gt;This method is designed to be used by {@link #drawPeerComponent(com.codename1.ui.PeerComponent) } only.&lt;/p&gt;
     *
     * @param x      The x-coordinate of the box to clear.  In screen coordinates.
     * @param y      The y-coordinate of the box to clear.  In screen coordinates.
     * @param width  The width of the box to clear.
     * @param height The height of the box to clear.
     */
    private void clearRectImpl(int x, int y, int width, int height) {
<span class="nc" id="L427">        impl.clearRect(nativeGraphics, x, y, width, height);</span>
<span class="nc" id="L428">    }</span>

    /**
     * Draws a rectangle in the given coordinates
     *
     * @param x      the x coordinate of the rectangle to be drawn.
     * @param y      the y coordinate of the rectangle to be drawn.
     * @param width  the width of the rectangle to be drawn.
     * @param height the height of the rectangle to be drawn.
     */
    public void drawRect(int x, int y, int width, int height) {
<span class="fc" id="L439">        impl.drawRect(nativeGraphics, xTranslate + x, yTranslate + y, width, height);</span>
<span class="fc" id="L440">    }</span>

    /**
     * Draws a rectangle in the given coordinates with the given thickness
     *
     * @param x         the x coordinate of the rectangle to be drawn.
     * @param y         the y coordinate of the rectangle to be drawn.
     * @param width     the width of the rectangle to be drawn.
     * @param height    the height of the rectangle to be drawn.
     * @param thickness the thickness in pixels
     */
    public void drawRect(int x, int y, int width, int height, int thickness) {
<span class="nc" id="L452">        impl.drawRect(nativeGraphics, xTranslate + x, yTranslate + y, width, height, thickness);</span>
<span class="nc" id="L453">    }</span>

    /**
     * Draws a rounded corner rectangle in the given coordinates with the arcWidth/height
     * matching the last two arguments respectively.
     *
     * @param x         the x coordinate of the rectangle to be drawn.
     * @param y         the y coordinate of the rectangle to be drawn.
     * @param width     the width of the rectangle to be drawn.
     * @param height    the height of the rectangle to be drawn.
     * @param arcWidth  the horizontal diameter of the arc at the four corners.
     * @param arcHeight the vertical diameter of the arc at the four corners.
     */
    public void drawRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight) {
<span class="nc" id="L467">        impl.drawRoundRect(nativeGraphics, xTranslate + x, yTranslate + y, width, height, arcWidth, arcHeight);</span>
<span class="nc" id="L468">    }</span>

    /**
     * Makes the current color slightly lighter, this is useful for many visual effects
     *
     * @param factor the degree of lightening a color per channel a number from 1 to 255
     */
    public void lighterColor(int factor) {
<span class="fc" id="L476">        int color = getColor();</span>
<span class="fc" id="L477">        int r = color &gt;&gt; 16 &amp; 0xff;</span>
<span class="fc" id="L478">        int g = color &gt;&gt; 8 &amp; 0xff;</span>
<span class="fc" id="L479">        int b = color &amp; 0xff;</span>
<span class="fc" id="L480">        r = Math.min(0xff, r + factor);</span>
<span class="fc" id="L481">        g = Math.min(0xff, g + factor);</span>
<span class="fc" id="L482">        b = Math.min(0xff, b + factor);</span>
<span class="fc" id="L483">        setColor(((r &lt;&lt; 16) &amp; 0xff0000) | ((g &lt;&lt; 8) &amp; 0xff00) | (b &amp; 0xff));</span>
<span class="fc" id="L484">    }</span>

    /**
     * Makes the current color slightly darker, this is useful for many visual effects
     *
     * @param factor the degree of lightening a color per channel a number from 1 to 255
     */
    public void darkerColor(int factor) {
<span class="fc" id="L492">        int color = getColor();</span>
<span class="fc" id="L493">        int r = color &gt;&gt; 16 &amp; 0xff;</span>
<span class="fc" id="L494">        int g = color &gt;&gt; 8 &amp; 0xff;</span>
<span class="fc" id="L495">        int b = color &amp; 0xff;</span>
<span class="fc" id="L496">        r = Math.max(0, r - factor);</span>
<span class="fc" id="L497">        g = Math.max(0, g - factor);</span>
<span class="fc" id="L498">        b = Math.max(0, b - factor);</span>
<span class="fc" id="L499">        setColor(((r &lt;&lt; 16) &amp; 0xff0000) | ((g &lt;&lt; 8) &amp; 0xff00) | (b &amp; 0xff));</span>
<span class="fc" id="L500">    }</span>

    /**
     * Fills a rounded rectangle in the same way as drawRoundRect
     *
     * @param x         the x coordinate of the rectangle to be filled.
     * @param y         the y coordinate of the rectangle to be filled.
     * @param width     the width of the rectangle to be filled.
     * @param height    the height of the rectangle to be filled.
     * @param arcWidth  the horizontal diameter of the arc at the four corners.
     * @param arcHeight the vertical diameter of the arc at the four corners.
     * @see #drawRoundRect
     */
    public void fillRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight) {
<span class="nc" id="L514">        impl.fillRoundRect(nativeGraphics, xTranslate + x, yTranslate + y, width, height, arcWidth, arcHeight);</span>
<span class="nc" id="L515">    }</span>

    /**
     * Fills a circular or elliptical arc based on the given angles and bounding
     * box. The resulting arc begins at startAngle and extends for arcAngle
     * degrees. Usage:
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/31a32bdcf014a9e55a95.js&quot;&gt;&lt;/script&gt;
     *
     * @param x          the x coordinate of the upper-left corner of the arc to be filled.
     * @param y          the y coordinate of the upper-left corner of the arc to be filled.
     * @param width      the width of the arc to be filled, must be 1 or more.
     * @param height     the height of the arc to be filled, must be 1 or more.
     * @param startAngle the beginning angle.
     * @param arcAngle   the angular extent of the arc, relative to the start angle.
     */
    public void fillArc(int x, int y, int width, int height, int startAngle, int arcAngle) {
<span class="nc bnc" id="L532" title="All 4 branches missed.">        if (width &lt; 1 || height &lt; 1) {</span>
<span class="nc" id="L533">            throw new IllegalArgumentException(&quot;Width &amp; Height of fillAsrc must be greater than 0&quot;);</span>
        }
<span class="nc" id="L535">        impl.fillArc(nativeGraphics, xTranslate + x, yTranslate + y, width, height, startAngle, arcAngle);</span>
<span class="nc" id="L536">    }</span>

    /**
     * Draws a circular or elliptical arc based on the given angles and bounding
     * box
     *
     * @param x          the x coordinate of the upper-left corner of the arc to be drawn.
     * @param y          the y coordinate of the upper-left corner of the arc to be drawn.
     * @param width      the width of the arc to be drawn.
     * @param height     the height of the arc to be drawn.
     * @param startAngle the beginning angle.
     * @param arcAngle   the angular extent of the arc, relative to the start angle.
     */
    public void drawArc(int x, int y, int width, int height, int startAngle, int arcAngle) {
<span class="nc" id="L550">        impl.drawArc(nativeGraphics, xTranslate + x, yTranslate + y, width, height, startAngle, arcAngle);</span>
<span class="nc" id="L551">    }</span>

    private void drawStringImpl(String str, int x, int y) {
        // remove a commonly used trick to create a spacer label from the paint queue
<span class="nc bnc" id="L555" title="All 6 branches missed.">        if (str.length() == 0 || (str.length() == 1 &amp;&amp; str.charAt(0) == ' ')) {</span>
<span class="nc" id="L556">            return;</span>
        }
<span class="nc bnc" id="L558" title="All 2 branches missed.">        if (!(current instanceof CustomFont)) {</span>
<span class="nc" id="L559">            impl.drawString(nativeGraphics, str, x + xTranslate, y + yTranslate);</span>
        } else {
<span class="nc" id="L561">            current.drawString(this, str, x, y);</span>
        }
<span class="nc" id="L563">    }</span>

    /**
     * Draw a string using the current font and color in the x,y coordinates. The font is drawn
     * from the top position and not the baseline.
     *
     * @param str            the string to be drawn.
     * @param x              the x coordinate.
     * @param y              the y coordinate.
     * @param textDecoration Text decoration bitmask (See Style's TEXT_DECORATION_* constants)
     */
    public void drawString(String str, int x, int y, int textDecoration) {
        // remove a commonly used trick to create a spacer label from the paint queue
<span class="pc bpc" id="L576" title="4 of 6 branches missed.">        if (str.length() == 0 || (str.length() == 1 &amp;&amp; str.charAt(0) == ' ')) {</span>
<span class="nc" id="L577">            return;</span>
        }

<span class="fc" id="L580">        Object nativeFont = null;</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">        if (current != null) {</span>
<span class="fc" id="L582">            nativeFont = current.getNativeFont();</span>
        }
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">        if (current instanceof CustomFont) {</span>
<span class="nc" id="L585">            current.drawString(this, str, x, y);</span>
        } else {
<span class="fc" id="L587">            impl.drawString(nativeGraphics, nativeFont, str, x + xTranslate, y + yTranslate, textDecoration);</span>
        }
<span class="fc" id="L589">    }</span>

    /**
     * Draws a string using baseline coordinates.
     *
     * @param str The string to be drawn.
     * @param x   The x-coordinate of the start of left edge of the text block.
     * @param y   The y-coordinate of the baseline of the text.
     * @see #drawString(java.lang.String, int, int)
     */
    public void drawStringBaseline(String str, int x, int y) {
<span class="nc" id="L600">        drawString(str, x, y - current.getAscent());</span>
<span class="nc" id="L601">    }</span>

    /**
     * Draws a string using baseline coordinates.
     *
     * @param str            The string to be drawn.
     * @param x              The x-coordinate of the start of left edge of the text block.
     * @param y              The y-coordinate of the baseline of the text.
     * @param textDecoration Text decoration bitmask (See Style's TEXT_DECORATION_* constants)
     * @see #drawString(java.lang.String, int, int, int)
     */
    public void drawStringBaseline(String str, int x, int y, int textDecoration) {
<span class="nc" id="L613">        drawString(str, x, y - current.getAscent(), textDecoration);</span>
<span class="nc" id="L614">    }</span>

    /**
     * Draw a string using the current font and color in the x,y coordinates. The font is drawn
     * from the top position and not the baseline.
     *
     * @param str the string to be drawn.
     * @param x   the x coordinate.
     * @param y   the y coordinate.
     */
    public void drawString(String str, int x, int y) {
<span class="nc" id="L625">        drawString(str, x, y, 0);</span>
<span class="nc" id="L626">    }</span>

    /**
     * Draw the given char using the current font and color in the x,y
     * coordinates. The font is drawn from the top position and not the
     * baseline.
     *
     * @param character - the character to be drawn
     * @param x         the x coordinate of the baseline of the text
     * @param y         the y coordinate of the baseline of the text
     */
    public void drawChar(char character, int x, int y) {
<span class="nc" id="L638">        drawString(&quot;&quot; + character, x, y);</span>
<span class="nc" id="L639">    }</span>

    /**
     * Draw the given char array using the current font and color in the x,y coordinates. The font is drawn
     * from the top position and not the baseline.
     *
     * @param data   the array of characters to be drawn
     * @param offset the start offset in the data
     * @param length the number of characters to be drawn
     * @param x      the x coordinate of the baseline of the text
     * @param y      the y coordinate of the baseline of the text
     */
    public void drawChars(char[] data, int offset, int length, int x, int y) {
<span class="nc bnc" id="L652" title="All 2 branches missed.">        if (!(current instanceof CustomFont)) {</span>
<span class="nc" id="L653">            drawString(new String(data, offset, length), x, y);</span>
        } else {
<span class="nc" id="L655">            CustomFont f = (CustomFont) current;</span>
<span class="nc" id="L656">            f.drawChars(this, data, offset, length, x, y);</span>
        }
<span class="nc" id="L658">    }</span>

    /**
     * Draws the image so its top left coordinate corresponds to x/y
     *
     * @param img the specified image to be drawn. This method does
     *            nothing if img is null.
     * @param x   the x coordinate.
     * @param y   the y coordinate.
     */
    public void drawImage(Image img, int x, int y) {
<span class="nc" id="L669">        img.drawImage(this, nativeGraphics, x, y);</span>
<span class="nc" id="L670">    }</span>

    /**
     * Draws the image so its top left coordinate corresponds to x/y and scales it to width/height
     *
     * @param img the specified image to be drawn. This method does
     *            nothing if img is null.
     * @param x   the x coordinate.
     * @param y   the y coordinate.
     * @param w   the width to occupy
     * @param h   the height to occupy
     */
    public void drawImage(Image img, int x, int y, int w, int h) {
<span class="nc bnc" id="L683" title="All 2 branches missed.">        if (impl.isScaledImageDrawingSupported()) {</span>
<span class="nc" id="L684">            img.drawImage(this, nativeGraphics, x, y, w, h);</span>
        } else {
<span class="nc" id="L686">            drawImage(img.scaled(w, h), x, y);</span>
        }
<span class="nc" id="L688">    }</span>


    void drawImageWH(Object nativeImage, int x, int y, int w, int h) {
<span class="nc" id="L692">        impl.drawImage(nativeGraphics, nativeImage, x + xTranslate, y + yTranslate, w, h);</span>
<span class="nc" id="L693">    }</span>

    void drawImage(Object img, int x, int y) {
<span class="nc" id="L696">        impl.drawImage(nativeGraphics, img, x + xTranslate, y + yTranslate);</span>
<span class="nc" id="L697">    }</span>

    /**
     * Draws an image with a MIDP trasnform for fast rotation
     */
    void drawImage(Object img, int x, int y, int transform) {
<span class="nc bnc" id="L703" title="All 2 branches missed.">        if (transform != 0) {</span>
<span class="nc" id="L704">            impl.drawImageRotated(nativeGraphics, img, x + xTranslate, y + yTranslate, transform);</span>
        } else {
<span class="nc" id="L706">            drawImage(img, x, y);</span>
        }
<span class="nc" id="L708">    }</span>


    //--------------------------------------------------------------------------
    // START SHAPE DRAWING STUFF
    //--------------------------------------------------------------------------


    /**
     * Draws a outline shape inside the specified bounding box.  The bounding box will resize the shape to fit in its dimensions.
     * &lt;p&gt;This is not supported on
     * all platforms and contexts currently.  Use {@link #isShapeSupported} to check if the current
     * context supports drawing shapes.&lt;/p&gt;
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/3f2f8cdaabb7780eae6f.js&quot;&gt;&lt;/script&gt;
     * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/graphics-shape-fill.png&quot; alt=&quot;Fill a shape general path&quot; /&gt;
     *
     * @param shape  The shape to be drawn.
     * @param stroke the stroke to use
     * @see #setStroke
     * @see #isShapeSupported
     */
    public void drawShape(Shape shape, Stroke stroke) {
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">        if (isShapeSupported()) {</span>
<span class="pc bpc" id="L732" title="1 of 4 branches missed.">            if (xTranslate != 0 || yTranslate != 0) {</span>
<span class="fc" id="L733">                GeneralPath p = tmpClipShape();</span>
<span class="fc" id="L734">                p.setShape(shape, translation());</span>
<span class="fc" id="L735">                shape = p;</span>
            }
<span class="fc" id="L737">            impl.drawShape(nativeGraphics, shape, stroke);</span>
        }

<span class="fc" id="L740">    }</span>

    /**
     * Fills the given shape using the current alpha and color settings.
     * &lt;p&gt;This is not supported on
     * all platforms and contexts currently.  Use {@link #isShapeSupported} to check if the current
     * context supports drawing shapes.&lt;/p&gt;
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/3f2f8cdaabb7780eae6f.js&quot;&gt;&lt;/script&gt;
     * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/graphics-shape-fill.png&quot; alt=&quot;Fill a shape general path&quot; /&gt;
     *
     * &lt;p&gt;Note: You can specify a custom {@link Paint} to use for filling the shape using the {@link #setColor(com.codename1.ui.Paint) }
     * method.  This is useful for filling the shape with a {@link LinearGradientPaint}, for example.&lt;/p&gt;
     *
     * @param shape The shape to be filled.
     * @see #isShapeSupported
     */
    public void fillShape(Shape shape) {
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">        if (isShapeSupported()) {</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">            if (paint != null) {</span>
<span class="fc" id="L760">                int clipX = getClipX();</span>
<span class="fc" id="L761">                int clipY = getClipY();</span>
<span class="fc" id="L762">                int clipW = getClipWidth();</span>
<span class="fc" id="L763">                int clipH = getClipHeight();</span>
<span class="fc" id="L764">                setClip(shape);</span>
<span class="fc" id="L765">                clipRect(clipX, clipY, clipW, clipH);</span>
<span class="pc bpc" id="L766" title="2 of 4 branches missed.">                if (xTranslate != 0 || yTranslate != 0) {</span>
<span class="nc" id="L767">                    GeneralPath p = tmpClipShape();</span>
<span class="nc" id="L768">                    p.setShape(shape, translation());</span>
<span class="nc" id="L769">                    shape = p;</span>
                }
<span class="fc" id="L771">                Rectangle bounds = shape.getBounds();</span>
<span class="fc" id="L772">                paint.paint(this, bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());</span>
<span class="fc" id="L773">                setClip(clipX, clipY, clipW, clipH);</span>
<span class="fc" id="L774">                return;</span>

            }
<span class="pc bpc" id="L777" title="2 of 4 branches missed.">            if (xTranslate != 0 || yTranslate != 0) {</span>
<span class="nc" id="L778">                GeneralPath p = tmpClipShape();</span>
<span class="nc" id="L779">                p.setShape(shape, translation());</span>
<span class="nc" id="L780">                shape = p;</span>
            }

<span class="fc" id="L783">            impl.fillShape(nativeGraphics, shape);</span>
        }
<span class="fc" id="L785">    }</span>

    /**
     * Checks to see if {@link com.codename1.ui.geom.Matrix} transforms are supported by this graphics context.
     *
     * @return {@literal true} if this graphics context supports {@link com.codename1.ui.geom.Matrix} transforms.
     * &lt;p&gt;Note that this method only confirms that 2D transforms are supported.  If you need to perform 3D
     * transformations, you should use the {@link #isPerspectiveTransformSupported} method.&lt;/p&gt;
     * @see #setTransform
     * @see #getTransform
     * @see #isPerspectiveTransformSupported
     */
    public boolean isTransformSupported() {
<span class="nc" id="L798">        return impl.isTransformSupported(nativeGraphics);</span>
    }

    /**
     * Checks to see if perspective (3D) {@link com.codename1.ui.geom.Matrix} transforms are supported by this graphics
     * context.  If 3D transforms are supported, you can use a 4x4 transformation {@link com.codename1.ui.geom.Matrix}
     * via {@link #setTransform} to perform 3D transforms.
     *
     * &lt;p&gt;Note: It is possible for 3D transforms to not be supported but Affine (2D)
     * transforms to be supported.  In this case you would be limited to a 3x3 transformation
     * matrix in {@link #setTransform}.  You can check for 2D transformation support using the {@link #isTransformSupported} method.&lt;/p&gt;
     *
     * @return {@literal true} if Perspective (3D) transforms are supported.  {@literal false} otherwise.
     * @see #isTransformSupported
     * @see #setTransform
     * @see #getTransform
     */
    public boolean isPerspectiveTransformSupported() {
<span class="nc" id="L816">        return impl.isPerspectiveTransformSupported(nativeGraphics);</span>
    }

    /**
     * &lt;p&gt;Checks to see if this graphics context supports drawing shapes (i.e. {@link #drawShape}
     * and {@link #fillShape} methods. If this returns {@literal false}, and you call {@link #drawShape} or {@link #fillShape}, then
     * nothing will be drawn.&lt;/p&gt;
     *
     * @return {@literal true} If {@link #drawShape} and {@link #fillShape} are supported.
     * @see #drawShape
     * @see #fillShape
     */
    public boolean isShapeSupported() {
<span class="fc" id="L829">        return impl.isShapeSupported(nativeGraphics);</span>
    }

    /**
     * Checks to see if this graphics context supports clip Shape.
     * If this returns {@literal false}, calling setClip(Shape) will have no effect on the Graphics clipping area
     *
     * @return {@literal true} If setClip(Shape) is supported.
     */
    public boolean isShapeClipSupported() {
<span class="nc" id="L839">        return impl.isShapeClipSupported(nativeGraphics);</span>
    }

    /**
     * Concatenates the given transform to the context's transform.
     *
     * @param transform The transform to concatenate.
     * @since 7.0
     */
    public void transform(Transform transform) {
<span class="nc" id="L849">        Transform existing = getTransform();</span>
<span class="nc" id="L850">        existing.concatenate(transform);</span>
<span class="nc" id="L851">        setTransform(existing);</span>
<span class="nc" id="L852">    }</span>

    /**
     * Gets the transformation matrix that is currently applied to this graphics context.
     *
     * @return The current transformation matrix.
     * @see #setTransform
     * @deprecated Use {@link #getTransform(com.codename1.ui.Transform) } instead.
     */
    public Transform getTransform() {
<span class="nc" id="L862">        return impl.getTransform(nativeGraphics);</span>

    }

    /**
     * Sets the transformation {@link com.codename1.ui.geom.Matrix} to apply to drawing in this graphics context.
     * In order to use this for 2D/Affine transformations you should first check to
     * make sure that transforms are supported by calling the {@link #isTransformSupported}
     * method.  For 3D/Perspective transformations, you should first check to
     * make sure that 3D/Perspective transformations are supported by calling the
     * {@link #isPerspectiveTransformSupported}.
     *
     * &lt;p&gt;Transformations are applied with {@literal (0,0)} as the origin.  So rotations and
     * scales are anchored at this point on the screen.  You can use a different
     * anchor point by either embedding it in the transformation matrix (i.e. pre-transform the {@link com.codename1.ui.geom.Matrix} to anchor at a different point)
     * or use the {@link #setTransform(com.codename1.ui.geom.Matrix, int, int)} variation that allows you to explicitly set the
     * anchor point.&lt;/p&gt;
     *
     * @param transform The transformation {@link com.codename1.ui.geom.Matrix} to use for drawing.  2D/Affine transformations
     *                  can be achieved using a 3x3 transformation {@link com.codename1.ui.geom.Matrix}.  3D/Perspective transformations
     *                  can be achieved using a 4x3 transformation {@link com.codename1.ui.geom.Matrix}.
     * @see #isTransformSupported
     * @see #isPerspectiveTransformSupported
     * @see #setTransform(com.codename1.ui.geom.Matrix, int, int)
     */
    public void setTransform(Transform transform) {
<span class="nc" id="L888">        impl.setTransform(nativeGraphics, transform);</span>
<span class="nc" id="L889">    }</span>

    /**
     * Loads the provided transform with the current transform applied to this graphics context.
     *
     * @param t An &quot;out&quot; parameter to be filled with the current transform.
     */
    public void getTransform(Transform t) {
<span class="nc" id="L897">        impl.getTransform(nativeGraphics, t);</span>
<span class="nc" id="L898">    }</span>

    //--------------------------------------------------------------------------
    // END SHAPE DRAWING METHODS
    //--------------------------------------------------------------------------

    /**
     * Draws a filled triangle with the given coordinates
     *
     * @param x1 the x coordinate of the first vertex of the triangle
     * @param y1 the y coordinate of the first vertex of the triangle
     * @param x2 the x coordinate of the second vertex of the triangle
     * @param y2 the y coordinate of the second vertex of the triangle
     * @param x3 the x coordinate of the third vertex of the triangle
     * @param y3 the y coordinate of the third vertex of the triangle
     */
    public void fillTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {
<span class="nc" id="L915">        impl.fillTriangle(nativeGraphics, xTranslate + x1, yTranslate + y1, xTranslate + x2, yTranslate + y2, xTranslate + x3, yTranslate + y3);</span>
<span class="nc" id="L916">    }</span>

    /**
     * Draws the RGB values based on the MIDP API of a similar name. Renders a
     * series of device-independent RGB+transparency values in a specified
     * region. The values are stored in rgbData in a format with 24 bits of
     * RGB and an eight-bit alpha value (0xAARRGGBB), with the first value
     * stored at the specified offset. The scanlength  specifies the relative
     * offset within the array between the corresponding pixels of consecutive
     * rows. Any value for scanlength is acceptable (even negative values)
     * provided that all resulting references are within the bounds of the
     * rgbData array. The ARGB data is rasterized horizontally from left to
     * right within each row. The ARGB values are rendered in the region
     * specified by x, y, width and height, and the operation is subject
     * to the current clip region and translation for this Graphics object.
     *
     * @param rgbData      an array of ARGB values in the format 0xAARRGGBB
     * @param offset       the array index of the first ARGB value
     * @param x            the horizontal location of the region to be rendered
     * @param y            the vertical location of the region to be rendered
     * @param w            the width of the region to be rendered
     * @param h            the height of the region to be rendered
     * @param processAlpha true if rgbData has an alpha channel, false if
     *                     all pixels are fully opaque
     */
    void drawRGB(int[] rgbData, int offset, int x, int y, int w, int h, boolean processAlpha) {
<span class="nc" id="L942">        impl.drawRGB(nativeGraphics, rgbData, offset, x + xTranslate, y + yTranslate, w, h, processAlpha);</span>
<span class="nc" id="L943">    }</span>

    /**
     * Draws a radial gradient in the given coordinates with the given colors,
     * doesn't take alpha into consideration when drawing the gradient.
     * Notice that a radial gradient will result in a circular shape, to create
     * a square use fillRect or draw a larger shape and clip to the appropriate size.
     *
     * @param startColor the starting RGB color
     * @param endColor   the ending RGB color
     * @param x          the x coordinate
     * @param y          the y coordinate
     * @param width      the width of the region to be filled
     * @param height     the height of the region to be filled
     */
    public void fillRadialGradient(int startColor, int endColor, int x, int y, int width, int height) {
<span class="nc" id="L959">        impl.fillRadialGradient(nativeGraphics, startColor, endColor, x + xTranslate, y + yTranslate, width, height);</span>
<span class="nc" id="L960">    }</span>

    /**
     * Draws a radial gradient in the given coordinates with the given colors,
     * doesn't take alpha into consideration when drawing the gradient.
     * Notice that a radial gradient will result in a circular shape, to create
     * a square use fillRect or draw a larger shape and clip to the appropriate size.
     *
     * @param startColor the starting RGB color
     * @param endColor   the ending RGB color
     * @param x          the x coordinate
     * @param y          the y coordinate
     * @param width      the width of the region to be filled
     * @param height     the height of the region to be filled
     * @param startAngle the beginning angle.  Zero is at 3 o'clock.  Positive angles are counter-clockwise.
     * @param arcAngle   the angular extent of the arc, relative to the start angle. Positive angles are counter-clockwise.
     */
    public void fillRadialGradient(int startColor, int endColor, int x, int y, int width, int height, int startAngle, int arcAngle) {
<span class="nc" id="L978">        impl.fillRadialGradient(nativeGraphics, startColor, endColor, x + xTranslate, y + yTranslate, width, height, startAngle, arcAngle);</span>
<span class="nc" id="L979">    }</span>

    /**
     * Draws a radial gradient in the given coordinates with the given colors,
     * doesn't take alpha into consideration when drawing the gradient. Notice that this method
     * differs from fillRadialGradient since it draws a square gradient at all times
     * and can thus be cached
     * Notice that a radial gradient will result in a circular shape, to create
     * a square use fillRect or draw a larger shape and clip to the appropriate size.
     *
     * @param startColor   the starting RGB color
     * @param endColor     the ending RGB color
     * @param x            the x coordinate
     * @param y            the y coordinate
     * @param width        the width of the region to be filled
     * @param height       the height of the region to be filled
     * @param relativeX    indicates the relative position of the gradient within the drawing region
     * @param relativeY    indicates the relative position of the gradient within the drawing region
     * @param relativeSize indicates the relative size of the gradient within the drawing region
     */
    public void fillRectRadialGradient(int startColor, int endColor, int x, int y, int width, int height, float relativeX, float relativeY, float relativeSize) {
        // people do that a lot sadly...
<span class="nc bnc" id="L1001" title="All 2 branches missed.">        if (startColor == endColor) {</span>
<span class="nc" id="L1002">            setColor(startColor);</span>
<span class="nc" id="L1003">            fillRect(x, y, width, height, (byte) 0xff);</span>
<span class="nc" id="L1004">            return;</span>
        }
<span class="nc" id="L1006">        impl.fillRectRadialGradient(nativeGraphics, startColor, endColor, x + xTranslate, y + yTranslate, width, height, relativeX, relativeY, relativeSize);</span>
<span class="nc" id="L1007">    }</span>

    /**
     * Draws a linear gradient in the given coordinates with the given colors,
     * doesn't take alpha into consideration when drawing the gradient
     *
     * @param startColor the starting RGB color
     * @param endColor   the ending RGB color
     * @param x          the x coordinate
     * @param y          the y coordinate
     * @param width      the width of the region to be filled
     * @param height     the height of the region to be filled
     * @param horizontal indicating wheter it is a horizontal fill or vertical
     */
    public void fillLinearGradient(int startColor, int endColor, int x, int y, int width, int height, boolean horizontal) {
        // people do that a lot sadly...
<span class="nc bnc" id="L1023" title="All 2 branches missed.">        if (startColor == endColor) {</span>
<span class="nc" id="L1024">            setColor(startColor);</span>
<span class="nc" id="L1025">            fillRect(x, y, width, height, (byte) 0xff);</span>
<span class="nc" id="L1026">            return;</span>
        }
<span class="nc" id="L1028">        impl.fillLinearGradient(nativeGraphics, startColor, endColor, x + xTranslate, y + yTranslate, width, height, horizontal);</span>
<span class="nc" id="L1029">    }</span>

    /**
     * Fills a rectangle with an optionally translucent fill color
     *
     * @param x     the x coordinate of the rectangle to be filled
     * @param y     the y coordinate of the rectangle to be filled
     * @param w     the width of the rectangle to be filled
     * @param h     the height of the rectangle to be filled
     * @param alpha the alpha values specify semitransparency
     */
    public void fillRect(int x, int y, int w, int h, byte alpha) {
<span class="nc" id="L1041">        impl.fillRect(nativeGraphics, x + xTranslate, y + yTranslate, w, h, alpha);</span>
<span class="nc" id="L1042">    }</span>

    /**
     * Fills a closed polygon defined by arrays of x and y coordinates.
     * Each pair of (x, y) coordinates defines a point.
     *
     * @param xPoints - a an array of x coordinates.
     * @param yPoints - a an array of y coordinates.
     * @param nPoints - a the total number of points.
     */
    public void fillPolygon(int[] xPoints,
                            int[] yPoints,
                            int nPoints) {
<span class="nc" id="L1055">        int[] cX = xPoints;</span>
<span class="nc" id="L1056">        int[] cY = yPoints;</span>
<span class="nc bnc" id="L1057" title="All 6 branches missed.">        if ((!impl.isTranslationSupported()) &amp;&amp; (xTranslate != 0 || yTranslate != 0)) {</span>
<span class="nc" id="L1058">            cX = new int[nPoints];</span>
<span class="nc" id="L1059">            cY = new int[nPoints];</span>
<span class="nc" id="L1060">            System.arraycopy(xPoints, 0, cX, 0, nPoints);</span>
<span class="nc" id="L1061">            System.arraycopy(yPoints, 0, cY, 0, nPoints);</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">            for (int iter = 0; iter &lt; nPoints; iter++) {</span>
<span class="nc" id="L1063">                cX[iter] += xTranslate;</span>
<span class="nc" id="L1064">                cY[iter] += yTranslate;</span>
            }
        }
<span class="nc" id="L1067">        impl.fillPolygon(nativeGraphics, cX, cY, nPoints);</span>
<span class="nc" id="L1068">    }</span>

    /**
     * Draws a region of an image in the given x/y coordinate
     *
     * @param img         the image to draw
     * @param x           x location for the image
     * @param y           y location for the image
     * @param imageX      location within the image to draw
     * @param imageY      location within the image to draw
     * @param imageWidth  size of the location within the image to draw
     * @param imageHeight size of the location within the image to draw
     */
    void drawImageArea(Image img, int x, int y, int imageX, int imageY, int imageWidth, int imageHeight) {
<span class="nc" id="L1082">        img.drawImageArea(this, nativeGraphics, x, y, imageX, imageY, imageWidth, imageHeight);</span>
<span class="nc" id="L1083">    }</span>

    /**
     * Draws a closed polygon defined by arrays of x and y coordinates.
     * Each pair of (x, y) coordinates defines a point.
     *
     * @param xPoints - a an array of x coordinates.
     * @param yPoints - a an array of y coordinates.
     * @param nPoints - a the total number of points.
     */
    public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints) {
<span class="nc" id="L1094">        int[] cX = xPoints;</span>
<span class="nc" id="L1095">        int[] cY = yPoints;</span>
<span class="nc bnc" id="L1096" title="All 6 branches missed.">        if ((!impl.isTranslationSupported()) &amp;&amp; (xTranslate != 0 || yTranslate != 0)) {</span>
<span class="nc" id="L1097">            cX = new int[nPoints];</span>
<span class="nc" id="L1098">            cY = new int[nPoints];</span>
<span class="nc" id="L1099">            System.arraycopy(xPoints, 0, cX, 0, nPoints);</span>
<span class="nc" id="L1100">            System.arraycopy(yPoints, 0, cY, 0, nPoints);</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">            for (int iter = 0; iter &lt; nPoints; iter++) {</span>
<span class="nc" id="L1102">                cX[iter] += xTranslate;</span>
<span class="nc" id="L1103">                cY[iter] += yTranslate;</span>
            }
        }
<span class="nc" id="L1106">        impl.drawPolygon(nativeGraphics, cX, cY, nPoints);</span>
<span class="nc" id="L1107">    }</span>

    /**
     * Indicates whether invoking set/getAlpha would have an effect on all further
     * rendering from this graphics object.
     *
     * @return false if setAlpha has no effect true if it applies to everything some effect
     */
    public boolean isAlphaSupported() {
<span class="fc" id="L1116">        return impl.isAlphaGlobal();</span>
    }

    /**
     * Sets alpha as a value between 0-255 (0 - 0xff) where 255 is completely opaque
     * and 0 is completely transparent
     *
     * @param a the alpha value
     * @return The previous alpha value.
     */
    public int setAndGetAlpha(int a) {
<span class="fc" id="L1127">        int old = getAlpha();</span>
<span class="fc" id="L1128">        setAlpha(a);</span>
<span class="fc" id="L1129">        return old;</span>
    }

    /**
     * Concatenates the given alpha value to the current alpha setting, and returns the previous alpha
     * setting.
     *
     * @param a Alpha value to concatenate (0-255).
     * @return The previous alpha setting (0-255).
     * @since 7.0
     */
    public int concatenateAlpha(int a) {
<span class="fc bfc" id="L1141" title="All 2 branches covered.">        if (a == 255) return getAlpha();</span>

<span class="fc" id="L1143">        int oldAlpha = getAlpha();</span>
<span class="fc" id="L1144">        setAlpha((int) (oldAlpha * (a / 255f)));</span>
<span class="fc" id="L1145">        return oldAlpha;</span>
    }

    /**
     * Returnes the alpha as a value between 0-255 (0 - 0xff) where 255 is completely opaque
     * and 0 is completely transparent
     *
     * @return the alpha value
     */
    public int getAlpha() {
<span class="fc" id="L1155">        return impl.getAlpha(nativeGraphics);</span>
    }

    /**
     * Sets alpha as a value between 0-255 (0 - 0xff) where 255 is completely opaque
     * and 0 is completely transparent
     *
     * @param a the alpha value
     */
    public void setAlpha(int a) {
<span class="fc" id="L1165">        impl.setAlpha(nativeGraphics, a);</span>
<span class="fc" id="L1166">    }</span>

    /**
     * Returns true if anti-aliasing for standard rendering operations is supported,
     * notice that text anti-aliasing is a separate attribute.
     *
     * @return true if anti aliasing is supported
     */
    public boolean isAntiAliasingSupported() {
<span class="nc" id="L1175">        return impl.isAntiAliasingSupported(nativeGraphics);</span>
    }

    /**
     * Returns true if anti-aliasing for text is supported,
     * notice that text anti-aliasing is a separate attribute from standard anti-alisaing.
     *
     * @return true if text anti aliasing is supported
     */
    public boolean isAntiAliasedTextSupported() {
<span class="nc" id="L1185">        return impl.isAntiAliasedTextSupported(nativeGraphics);</span>
    }


    /**
     * Returns true if anti-aliasing for standard rendering operations is turned on.
     *
     * @return true if anti aliasing is active
     */
    public boolean isAntiAliased() {
<span class="nc" id="L1195">        return impl.isAntiAliased(nativeGraphics);</span>
    }

    /**
     * Set whether anti-aliasing for standard rendering operations is turned on.
     *
     * @param a true if anti aliasing is active
     */
    public void setAntiAliased(boolean a) {
<span class="nc" id="L1204">        impl.setAntiAliased(nativeGraphics, a);</span>
<span class="nc" id="L1205">    }</span>

    /**
     * Indicates whether anti-aliasing for text is active,
     * notice that text anti-aliasing is a separate attribute from standard anti-alisaing.
     *
     * @return true if text anti aliasing is supported
     */
    public boolean isAntiAliasedText() {
<span class="nc" id="L1214">        return impl.isAntiAliasedText(nativeGraphics);</span>
    }

    /**
     * Set whether anti-aliasing for text is active,
     * notice that text anti-aliasing is a separate attribute from standard anti-alisaing.
     *
     * @param a true if text anti aliasing is supported
     */
    public void setAntiAliasedText(boolean a) {
<span class="nc" id="L1224">        impl.setAntiAliasedText(nativeGraphics, a);</span>
<span class="nc" id="L1225">    }</span>

    /**
     * Indicates whether the underlying implementation can draw using an affine
     * transform hence methods such as rotate, scale and shear would work
     *
     * @return true if an affine transformation matrix is present
     */
    public boolean isAffineSupported() {
<span class="nc" id="L1234">        return impl.isAffineSupported();</span>
    }

    /**
     * Resets the affine transform to the default value
     */
    public void resetAffine() {
<span class="fc" id="L1241">        impl.resetAffine(nativeGraphics);</span>
<span class="fc" id="L1242">        scaleX = 1;</span>
<span class="fc" id="L1243">        scaleY = 1;</span>
<span class="fc" id="L1244">    }</span>

    /**
     * Scales the coordinate system using the affine transform
     *
     * @param x scale factor for x
     * @param y scale factor for y
     */
    public void scale(float x, float y) {
<span class="nc" id="L1253">        impl.scale(nativeGraphics, x, y);</span>
<span class="nc" id="L1254">        scaleX = x;</span>
<span class="nc" id="L1255">        scaleY = y;</span>
<span class="nc" id="L1256">    }</span>

    /**
     * Rotates the coordinate system around a radian angle using the affine transform
     *
     * @param angle the rotation angle in radians about the screen origin.
     * @see #rotateRadians(float)
     * @deprecated The behaviour of this method is inconsistent with the rest of the API, in that it doesn't
     * take into account the current Graphics context's translation.  Rotation is performed around the Screen's origin
     * rather than the current Graphics context's translated origin.  Prefer to use {@link #rotateRadians(float) }
     * which pivots around the context's translated origin.
     */
    public void rotate(float angle) {
<span class="nc" id="L1269">        impl.rotate(nativeGraphics, angle);</span>
<span class="nc" id="L1270">    }</span>

    /**
     * RRotates the coordinate system around a radian angle using the affine transform
     *
     * @param angle the rotation angle in radians about graphics context's translated origin.
     * @since 6.0
     */
    public void rotateRadians(float angle) {
<span class="nc" id="L1279">        rotateRadians(angle, 0, 0);</span>
<span class="nc" id="L1280">    }</span>

    /**
     * Rotates the coordinate system around a radian angle using the affine transform
     *
     * @param angle  the rotation angle in radians
     * @param pivotX the pivot point In absolute coordinates.
     * @param pivotY the pivot point In absolute coordinates.
     * @see #rotateRadians(float, int, int)
     * @deprecated The behaviour of this method is inconsistent with the rest of the API, in that the pivotX and pivotY parameters
     * are expressed in absolute screen coordinates and don't take into account the current Graphics context's translation.  Prefer
     * to use {@link #rotateRadians(float, int, int) } whose pivot coordinates are relative to the current translation.
     */
    public void rotate(float angle, int pivotX, int pivotY) {
<span class="nc" id="L1294">        impl.rotate(nativeGraphics, angle, pivotX, pivotY);</span>
<span class="nc" id="L1295">    }</span>

    /**
     * Rotates the coordinate system around a radian angle using the affine transform
     *
     * @param angle  the rotation angle in radians
     * @param pivotX the pivot point relative to the current graphics context's translation.
     * @param pivotY the pivot point relative to the current graphics context's translation.
     * @since 6.0
     */
    public void rotateRadians(float angle, int pivotX, int pivotY) {
<span class="nc" id="L1306">        impl.rotate(nativeGraphics, angle, pivotX + xTranslate, pivotY + yTranslate);</span>
<span class="nc" id="L1307">    }</span>

    /**
     * Shear the graphics coordinate system using the affine transform
     *
     * @param x shear factor for x
     * @param y shear factor for y
     */
    public void shear(float x, float y) {
<span class="nc" id="L1316">        impl.shear(nativeGraphics, x, y);</span>
<span class="nc" id="L1317">    }</span>

    /**
     * Starts accessing the native graphics in the underlying OS, when accessing
     * the native graphics Codename One shouldn't be used! The native graphics is unclipped
     * and untranslated by default and its the responsibility of the caller to clip/translate
     * appropriately.
     * &lt;p&gt;When finished with the native graphics it is essential to &lt;b&gt;invoke endNativeGraphicsAccess&lt;/b&gt;
     *
     * @return an instance of the underlying native graphics object
     */
    public Object beginNativeGraphicsAccess() {
<span class="nc bnc" id="L1329" title="All 2 branches missed.">        if (nativeGraphicsState != null) {</span>
<span class="nc" id="L1330">            throw new IllegalStateException(&quot;beginNativeGraphicsAccess invoked twice in a row&quot;);</span>
        }
<span class="nc" id="L1332">        Boolean a = Boolean.FALSE, b = Boolean.FALSE;</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">        if (isAntiAliasedText()) {</span>
<span class="nc" id="L1334">            b = Boolean.TRUE;</span>
        }
<span class="nc bnc" id="L1336" title="All 2 branches missed.">        if (isAntiAliased()) {</span>
<span class="nc" id="L1337">            a = Boolean.TRUE;</span>
        }

<span class="nc" id="L1340">        nativeGraphicsState = new Object[]{</span>
<span class="nc" id="L1341">                Integer.valueOf(getTranslateX()),</span>
<span class="nc" id="L1342">                Integer.valueOf(getTranslateY()),</span>
<span class="nc" id="L1343">                Integer.valueOf(getColor()),</span>
<span class="nc" id="L1344">                Integer.valueOf(getAlpha()),</span>
<span class="nc" id="L1345">                Integer.valueOf(getClipX()),</span>
<span class="nc" id="L1346">                Integer.valueOf(getClipY()),</span>
<span class="nc" id="L1347">                Integer.valueOf(getClipWidth()),</span>
<span class="nc" id="L1348">                Integer.valueOf(getClipHeight()),</span>
                a, b
        };
<span class="nc" id="L1351">        translate(-getTranslateX(), -getTranslateY());</span>
<span class="nc" id="L1352">        setAlpha(255);</span>
<span class="nc" id="L1353">        setClip(0, 0, Display.getInstance().getDisplayWidth(), Display.getInstance().getDisplayHeight());</span>
<span class="nc" id="L1354">        return nativeGraphics;</span>
    }

    /**
     * Invoke this to restore Codename One's graphics settings into the native graphics
     */
    public void endNativeGraphicsAccess() {
<span class="nc" id="L1361">        translate(((Integer) nativeGraphicsState[0]).intValue(), ((Integer) nativeGraphicsState[1]).intValue());</span>
<span class="nc" id="L1362">        setColor(((Integer) nativeGraphicsState[2]).intValue());</span>
<span class="nc" id="L1363">        setAlpha(((Integer) nativeGraphicsState[3]).intValue());</span>
<span class="nc" id="L1364">        setClip(((Integer) nativeGraphicsState[4]).intValue(),</span>
<span class="nc" id="L1365">                ((Integer) nativeGraphicsState[5]).intValue(),</span>
<span class="nc" id="L1366">                ((Integer) nativeGraphicsState[6]).intValue(),</span>
<span class="nc" id="L1367">                ((Integer) nativeGraphicsState[7]).intValue());</span>
<span class="nc" id="L1368">        setAntiAliased(((Boolean) nativeGraphicsState[8]).booleanValue());</span>
<span class="nc" id="L1369">        setAntiAliasedText(((Boolean) nativeGraphicsState[9]).booleanValue());</span>
<span class="nc" id="L1370">        nativeGraphicsState = null;</span>
<span class="nc" id="L1371">    }</span>

    /**
     * Allows an implementation to optimize image tiling rendering logic
     *
     * @param img the image
     * @param x   coordinate to tile the image along
     * @param y   coordinate to tile the image along
     * @param w   coordinate to tile the image along
     * @param h   coordinate to tile the image along
     */
    public void tileImage(Image img, int x, int y, int w, int h) {
<span class="nc bnc" id="L1383" title="All 2 branches missed.">        if (img.requiresDrawImage()) {</span>
<span class="nc" id="L1384">            int iW = img.getWidth();</span>
<span class="nc" id="L1385">            int iH = img.getHeight();</span>
<span class="nc" id="L1386">            int clipX = getClipX();</span>
<span class="nc" id="L1387">            int clipW = getClipWidth();</span>
<span class="nc" id="L1388">            int clipY = getClipY();</span>
<span class="nc" id="L1389">            int clipH = getClipHeight();</span>
<span class="nc" id="L1390">            clipRect(x, y, w, h);</span>
<span class="nc bnc" id="L1391" title="All 2 branches missed.">            for (int xPos = 0; xPos &lt;= w; xPos += iW) {</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">                for (int yPos = 0; yPos &lt; h; yPos += iH) {</span>
<span class="nc" id="L1393">                    int actualX = xPos + x;</span>
<span class="nc" id="L1394">                    int actualY = yPos + y;</span>
<span class="nc bnc" id="L1395" title="All 2 branches missed.">                    if (actualX &gt; clipX + clipW) {</span>
<span class="nc" id="L1396">                        continue;</span>
                    }
<span class="nc bnc" id="L1398" title="All 2 branches missed.">                    if (actualX + iW &lt; clipX) {</span>
<span class="nc" id="L1399">                        continue;</span>
                    }
<span class="nc bnc" id="L1401" title="All 2 branches missed.">                    if (actualY &gt; clipY + clipH) {</span>
<span class="nc" id="L1402">                        continue;</span>
                    }
<span class="nc bnc" id="L1404" title="All 2 branches missed.">                    if (actualY + iH &lt; clipY) {</span>
<span class="nc" id="L1405">                        continue;</span>
                    }
<span class="nc" id="L1407">                    drawImage(img, actualX, actualY);</span>
                }
            }
<span class="nc" id="L1410">            setClip(clipX, clipY, clipW, clipH);</span>
<span class="nc" id="L1411">        } else {</span>
<span class="nc" id="L1412">            impl.tileImage(nativeGraphics, img.getImage(), x + xTranslate, y + yTranslate, w, h);</span>
        }
<span class="nc" id="L1414">    }</span>

    /**
     * Returns the affine X scale
     *
     * @return the current scale
     */
    public float getScaleX() {
<span class="nc" id="L1422">        return scaleX;</span>
    }

    /**
     * Returns the affine Y scale
     *
     * @return the current scale
     */
    public float getScaleY() {
<span class="nc" id="L1431">        return scaleY;</span>
    }

    /**
     * Draws a peer component.  This doesn't actually draw anything, it just activates
     * the front graphics buffer and begins redirecting drawing operations to that buffer.
     * &lt;p&gt;This is only used on platforms where {@link CodenameOneImplementation#isFrontGraphicsSupported() } is enabled.&lt;/p&gt;
     *
     * @param peer The peer component to be drawn.
     */
    void drawPeerComponent(PeerComponent peer) {
<span class="nc bnc" id="L1442" title="All 2 branches missed.">        if (paintPeersBehind) {</span>
<span class="nc" id="L1443">            clearRectImpl(peer.getAbsoluteX(), peer.getAbsoluteY(), peer.getWidth(), peer.getHeight());</span>
        }

<span class="nc" id="L1446">    }</span>

    /**
     * Gets the current rendering hints for this context.
     *
     * @return The rendering hints.
     * @see #RENDERING_HINT_FAST
     */
    public int getRenderingHints() {
<span class="nc" id="L1455">        return impl.getRenderingHints(nativeGraphics);</span>
    }

    /**
     * Sets rendering hints for this context.
     *
     * @param hints int of rendering hints produced by logical AND on all applicable hints.
     * @see #RENDERING_HINT_FAST
     * @see #getRenderingHints()
     * @since 7.0
     */
    public void setRenderingHints(int hints) {
<span class="nc" id="L1467">        impl.setRenderingHints(nativeGraphics, hints);</span>
<span class="nc" id="L1468">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>