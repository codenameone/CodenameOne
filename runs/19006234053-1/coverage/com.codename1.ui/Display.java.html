<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Display.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.ui</a> &gt; <span class="el_source">Display.java</span></div><h1>Display.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores
 * CA 94065 USA or visit www.oracle.com if you need additional information or
 * have any questions.
 */
package com.codename1.ui;

import com.codename1.annotations.Async;
import com.codename1.capture.VideoCaptureConstraints;
import com.codename1.codescan.CodeScanner;
import com.codename1.contacts.Contact;
import com.codename1.contacts.ContactsManager;
import com.codename1.db.Database;
import com.codename1.impl.CodenameOneImplementation;
import com.codename1.impl.CodenameOneThread;
import com.codename1.impl.ImplementationFactory;
import com.codename1.impl.VirtualKeyboardInterface;
import com.codename1.io.Log;
import com.codename1.io.Preferences;
import com.codename1.l10n.L10NManager;
import com.codename1.location.LocationManager;
import com.codename1.media.Media;
import com.codename1.media.MediaManager;
import com.codename1.media.MediaRecorderBuilder;
import com.codename1.media.RemoteControlListener;
import com.codename1.messaging.Message;
import com.codename1.notifications.LocalNotification;
import com.codename1.payment.Purchase;
import com.codename1.plugin.PluginSupport;
import com.codename1.plugin.event.IsGalleryTypeSupportedEvent;
import com.codename1.plugin.event.OpenGalleryEvent;
import com.codename1.system.CrashReport;
import com.codename1.ui.animations.Animation;
import com.codename1.ui.animations.CommonTransitions;
import com.codename1.ui.animations.Transition;
import com.codename1.ui.events.ActionEvent;
import com.codename1.ui.events.ActionListener;
import com.codename1.ui.events.MessageEvent;
import com.codename1.ui.geom.Dimension;
import com.codename1.ui.geom.Rectangle;
import com.codename1.ui.plaf.Style;
import com.codename1.ui.plaf.UIManager;
import com.codename1.ui.util.EventDispatcher;
import com.codename1.ui.util.ImageIO;
import com.codename1.util.AsyncResource;
import com.codename1.util.RunnableWithResultSync;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;

/**
 * Central class for the API that manages rendering/events and is used to place top
 * level components ({@link Form}) on the &quot;display&quot;.
 * &lt;p&gt;This class handles the main thread for the toolkit referenced here on as the EDT
 * (Event Dispatch Thread) similar to the Swing EDT. This thread encapsulates the platform
 * specific event delivery and painting semantics and enables threading features such as
 * animations etc...
 * &lt;p&gt;The EDT should not be blocked since paint operations and events would also be blocked
 * in much the same way as they would be in other platforms. In order to serialize calls back
 * into the EDT use the methods {@link Display#callSerially} &amp;amp; {@link Display#callSeriallyAndWait}.
 * &lt;p&gt;Notice that all Codename One calls occur on the EDT (events, painting, animations etc...), Codename One
 * should normally be manipulated on the EDT as well (hence the {@link Display#callSerially} &amp;amp;
 * {@link Display#callSeriallyAndWait} methods). Theoretically it should be possible to manipulate
 * some Codename One features from other threads but this can't be guaranteed to work for all use cases.
 *
 * @author Chen Fishbein, Shai Almog
 */
public final class Display extends CN1Constants {
    /**
     * A common sound type that can be used with playBuiltinSound
     */
    public static final String SOUND_TYPE_ALARM = &quot;alarm&quot;;
    /**
     * A common sound type that can be used with playBuiltinSound
     */
    public static final String SOUND_TYPE_CONFIRMATION = &quot;confirmation&quot;;
    /**
     * A common sound type that can be used with playBuiltinSound
     */
    public static final String SOUND_TYPE_ERROR = &quot;error&quot;;
    /**
     * A common sound type that can be used with playBuiltinSound
     */
    public static final String SOUND_TYPE_INFO = &quot;info&quot;;
    /**
     * A common sound type that can be used with playBuiltinSound
     */
    public static final String SOUND_TYPE_WARNING = &quot;warning&quot;;
    /**
     * A common sound type that can be used with playBuiltinSound
     */
    public static final String SOUND_TYPE_BUTTON_PRESS = &quot;press&quot;;
    /**
     * Unknown keyboard type is the default indicating the software should try
     * to detect the keyboard type if necessary
     */
    public static final int KEYBOARD_TYPE_UNKNOWN = 0;
    /**
     * Numeric keypad keyboard type
     */
    public static final int KEYBOARD_TYPE_NUMERIC = 1;
    /**
     * Full QWERTY keypad keyboard type, even if a numeric keyboard also exists
     */
    public static final int KEYBOARD_TYPE_QWERTY = 2;
    /**
     * Touch device without a physical keyboard that should popup a keyboad
     */
    public static final int KEYBOARD_TYPE_VIRTUAL = 3;
    /**
     * Half QWERTY which needs software assistance for completion
     */
    public static final int KEYBOARD_TYPE_HALF_QWERTY = 4;
    /**
     * Game action for fire
     */
    public static final int GAME_FIRE = 8;
    /**
     * Game action for left key
     */
    public static final int GAME_LEFT = 2;
    /**
     * Game action for right key
     */
    public static final int GAME_RIGHT = 5;
    /**
     * Game action for UP key
     */
    public static final int GAME_UP = 1;
    /**
     * Game action for down key
     */
    public static final int GAME_DOWN = 6;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_SKIP_FORWARD = 20;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_SKIP_BACK = 21;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_PLAY = 22;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_STOP = 23;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_PLAY_STOP = 24;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_PLAY_PAUSE = 25;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_FAST_FORWARD = 26;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_FAST_BACKWARD = 27;
    /**
     * An attribute that encapsulates '#' int value.
     */
    public static final int KEY_POUND = '#';
    /**
     * Ignore all calls to show occurring during edit, they are discarded immediately
     */
    public static final int SHOW_DURING_EDIT_IGNORE = 1;
    /**
     * If show is called while editing text in the native text box an exception is thrown
     */
    public static final int SHOW_DURING_EDIT_EXCEPTION = 2;
    /**
     * Allow show to occur during edit and discard all user input at this moment
     */
    public static final int SHOW_DURING_EDIT_ALLOW_DISCARD = 3;
    /**
     * Allow show to occur during edit and save all user input at this moment
     */
    public static final int SHOW_DURING_EDIT_ALLOW_SAVE = 4;
    /**
     * Show will update the current form to which the OK button of the text box
     * will return
     */
    public static final int SHOW_DURING_EDIT_SET_AS_NEXT = 5;
    /**
     * Indicates that the Codename One implementation should decide internally the command
     * behavior most appropriate for this platform.
     */
    public static final int COMMAND_BEHAVIOR_DEFAULT = 1;
    /**
     * Indicates the classic Codename One command behavior where the commands are placed in
     * a list within a dialog. This is the most customizable approach for none touch devices.
     */
    public static final int COMMAND_BEHAVIOR_SOFTKEY = 2;
    /**
     * Indicates the touch menu dialog rendered by Codename One where commands are placed
     * into a scrollable dialog
     */
    public static final int COMMAND_BEHAVIOR_TOUCH_MENU = 3;
    /**
     * Indicates that commands should be added to an always visible bar at the
     * bottom of the form.
     */
    public static final int COMMAND_BEHAVIOR_BUTTON_BAR = 4;
    /**
     * Identical to the bar behavior, places the back command within the title bar
     * of the form/dialg
     */
    public static final int COMMAND_BEHAVIOR_BUTTON_BAR_TITLE_BACK = 5;
    /**
     * Places all commands on the right side of the title bar with a uniform size
     * grid layout
     */
    public static final int COMMAND_BEHAVIOR_BUTTON_BAR_TITLE_RIGHT = 6;
    /**
     * Commands are placed in the same was as they are in the ice cream sandwich Android
     * OS update where the back button has a theme icon the application icon appears next
     * to the
     */
    public static final int COMMAND_BEHAVIOR_ICS = 7;
    /**
     * Commands are placed in a side menu similar to Facebook/Google+ apps
     */
    public static final int COMMAND_BEHAVIOR_SIDE_NAVIGATION = 8;
    /**
     * Indicates that commands should try to add themselves to the native menus
     */
    public static final int COMMAND_BEHAVIOR_NATIVE = 10;
<span class="fc" id="L262">    static final Display INSTANCE = new Display();</span>
<span class="fc" id="L263">    static final Object lock = new Object();</span>
    private static final int POINTER_PRESSED = 1;
    private static final int POINTER_RELEASED = 2;
    private static final int POINTER_DRAGGED = 3;
    private static final int POINTER_HOVER = 8;
    private static final int POINTER_HOVER_RELEASED = 11;
    private static final int POINTER_HOVER_PRESSED = 12;
    private static final int KEY_PRESSED = 4;
    private static final int KEY_RELEASED = 5;
    private static final int KEY_LONG_PRESSED = 6;
    private static final int SIZE_CHANGED = 7;
    private static final int HIDE_NOTIFY = 9;
    private static final int SHOW_NOTIFY = 10;
    private static final int POINTER_PRESSED_MULTI = 21;
    private static final int POINTER_RELEASED_MULTI = 22;
    private static final int POINTER_DRAGGED_MULTI = 23;
    private static final int MAX_ASYNC_EXCEPTION_DEPTH = 10;
<span class="fc" id="L280">    private static final int[] xArray1 = new int[1];</span>
<span class="fc" id="L281">    private static final int[] yArray1 = new int[1];</span>
<span class="fc" id="L282">    static int transitionDelay = -1;</span>
    static CodenameOneImplementation impl;
<span class="fc" id="L284">    private static String selectedVirtualKeyboard = null;</span>
<span class="fc" id="L285">    private static final Map&lt;String, VirtualKeyboardInterface&gt; virtualKeyboards = new HashMap&lt;String, VirtualKeyboardInterface&gt;();</span>
<span class="fc" id="L286">    private final LinkedList&lt;Runnable&gt; runningSerialCallsQueue = new LinkedList&lt;Runnable&gt;();</span>
    boolean codenameOneExited;
    long time;
    private CrashReport crashReporter;
    private EventDispatcher errorHandler;
    private boolean inNativeUI;
    private Runnable bookmark;
    private EventDispatcher messageListeners;
    private boolean disableInvokeAndBlock;
    /**
     * Enable Async stack traces.  This is disabled by default, but will cause
     * stack traces of callSerially() calls to be stored, and logged if the
     * Runnable throws an exception.
     */
    private boolean enableAsyncStackTraces;
    /**
     * A pure touch device has no focus showing when the user is using the touch
     * interface. Selection only shows when the user actually touches the screen
     * or suddenly switches to using a keypad/trackball. This sort of interface
     * is common in Android devices
     */
    private boolean pureTouch;
    private Graphics codenameOneGraphics;
    /**
     * Indicates whether this is a touch device
     */
    private boolean touchScreen;
    private HashMap&lt;String, String&gt; localProperties;
    /**
     * Indicates whether the edt should sleep between each loop
     */
<span class="fc" id="L317">    private boolean noSleep = false;</span>
    /**
     * Normally Codename One folds the VKB when switching forms this field allows us
     * to block that behavior.
     */
<span class="fc" id="L322">    private boolean autoFoldVKBOnFormSwitch = true;</span>
    /**
     * Indicates the maximum drawing speed of no more than 10 frames per second
     * by default (this can be increased or decreased) the advantage of limiting
     * framerate is to allow the CPU to perform other tasks besides drawing.
     * Notice that when no change is occurring on the screen no frame is drawn and
     * so a high/low FPS will have no effect then.
     */
<span class="fc" id="L330">    private int framerateLock = 15;</span>
<span class="fc" id="L331">    private boolean codenameOneRunning = false;</span>
    /**
     * Contains the call serially pending elements
     */
<span class="fc" id="L335">    private final ArrayList&lt;Runnable&gt; pendingSerialCalls = new ArrayList&lt;Runnable&gt;();</span>
    /**
     * Contains the call serially idle elements
     */
<span class="fc" id="L339">    private final ArrayList&lt;Runnable&gt; pendingIdleSerialCalls = new ArrayList&lt;Runnable&gt;();</span>
    /**
     * This is the instance of the EDT used internally to indicate whether
     * we are executing on the EDT or some arbitrary thread
     */
    private Thread edt;
    /**
     * Contains animations that must be played in full by the EDT before anything further
     * may be processed. This is useful for transitions/intro's etc... that animate without
     * user interaction.
     */
    private ArrayList&lt;Animation&gt; animationQueue;
    /**
     * Indicates whether the 3rd softbutton should be supported on this device
     */
<span class="fc" id="L354">    private boolean thirdSoftButton = false;</span>
    private int showDuringEdit;
    /**
     * Events to broadcast on the EDT, we are using a handcoded stack for maximum
     * performance and minimal synchronization. We are using the switching algorithm
     * where we only synchronize on the very minimal point of switching between the stacks
     * and adding to the active stack.
     */
<span class="fc" id="L362">    private int[] inputEventStack = new int[1000];</span>
    private int inputEventStackPointer;
<span class="fc" id="L364">    private int[] inputEventStackTmp = new int[1000];</span>
    private int inputEventStackPointerTmp;
    private boolean longPointerCharged;
    private boolean pointerPressedAndNotReleasedOrDragged;
    private boolean recursivePointerReleaseA;
    private boolean recursivePointerReleaseB;
    private int pointerX, pointerY;
    private boolean keyRepeatCharged;
    private boolean longPressCharged;
    private long longKeyPressTime;
<span class="fc" id="L374">    private int longPressInterval = 500;</span>
    private long nextKeyRepeatEvent;
    private int keyRepeatValue;
<span class="fc" id="L377">    private final int keyRepeatInitialIntervalTime = 800;</span>
<span class="fc" id="L378">    private final int keyRepeatNextIntervalTime = 10;</span>
    private boolean lastInteractionWasKeypad;
    private boolean dragOccured;
    private boolean processingSerialCalls;
    private int PATHLENGTH;
    private float[] dragPathX;
    private float[] dragPathY;
    private long[] dragPathTime;
<span class="fc" id="L386">    private int dragPathOffset = 0;</span>
<span class="fc" id="L387">    private int dragPathLength = 0;</span>
    private Boolean darkMode;
    private PluginSupport pluginSupport;
    /**
     * Internally track display initialization time as a fixed point to allow tagging of pointer
     * events with an integer timestamp (System.currentTimeMillis() - displayInitTime)
     * and not a long value.
     */
<span class="fc" id="L395">    private long displayInitTime = 0;</span>
    /**
     * Allows a Codename One application to minimize without forcing it to the front whenever
     * a new dialog is poped up
     */
    private boolean allowMinimizing;
    private boolean dropEvents;
    private ArrayList&lt;Runnable&gt; backgroundTasks;
    private Thread backgroundThread;
    private boolean multiKeyMode;
    private ActionListener virtualKeyboardListener;
    private EventDispatcher virtualKeyboardListeners;
<span class="fc" id="L407">    private int lastSizeChangeEventWH = -1;</span>
    private DebugRunnable currentEdtContext;
    private int previousKeyPressed;
    private int lastKeyPressed;
    private int lastDragOffset;
<span class="fc" id="L412">    private final Rectangle tmpRect = new Rectangle();</span>
    private Form eventForm;

    /**
     * Private constructor to prevent instanciation
     */
<span class="fc" id="L418">    private Display() {</span>
<span class="fc" id="L419">    }</span>

    /**
     * This is the INTERNAL Display initialization method, it will be removed in future versions of the API.
     * This method must be called before any Form is shown
     *
     * @param m platform specific object used by the implementation
     * @deprecated this method is invoked internally do not invoke it!
     */
    public static void init(Object m) {
<span class="fc bfc" id="L429" title="All 2 branches covered.">        if (!INSTANCE.codenameOneRunning) {</span>
<span class="fc" id="L430">            INSTANCE.codenameOneRunning = true;</span>
<span class="fc" id="L431">            INSTANCE.pluginSupport = new PluginSupport();</span>
<span class="fc" id="L432">            INSTANCE.displayInitTime = System.currentTimeMillis();</span>

            //restore menu state from previous run if exists
<span class="fc" id="L435">            int commandBehaviour = COMMAND_BEHAVIOR_DEFAULT;</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">            if (impl != null) {</span>
<span class="fc" id="L437">                commandBehaviour = impl.getCommandBehavior();</span>
            }
<span class="fc" id="L439">            impl = (CodenameOneImplementation) ImplementationFactory.getInstance().createImplementation();</span>

<span class="fc" id="L441">            impl.setDisplayLock(lock);</span>
<span class="fc" id="L442">            impl.initImpl(m);</span>
<span class="fc" id="L443">            INSTANCE.codenameOneGraphics = new Graphics(impl.getNativeGraphics());</span>
<span class="fc" id="L444">            INSTANCE.codenameOneGraphics.paintPeersBehind = impl.paintNativePeersBehind();</span>
<span class="fc" id="L445">            impl.setCodenameOneGraphics(INSTANCE.codenameOneGraphics);</span>

            // only enable but never disable the third softbutton
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">            if (impl.isThirdSoftButton()) {</span>
<span class="nc" id="L449">                INSTANCE.thirdSoftButton = true;</span>
            }
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">            if (impl.getSoftkeyCount() &gt; 0) {</span>
<span class="fc" id="L452">                MenuBar.leftSK = impl.getSoftkeyCode(0)[0];</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">                if (impl.getSoftkeyCount() &gt; 1) {</span>
<span class="fc" id="L454">                    MenuBar.rightSK = impl.getSoftkeyCode(1)[0];</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">                    if (impl.getSoftkeyCode(1).length &gt; 1) {</span>
<span class="nc" id="L456">                        MenuBar.rightSK2 = impl.getSoftkeyCode(1)[1];</span>
                    }
                }
            }
<span class="fc" id="L460">            MenuBar.backSK = impl.getBackKeyCode();</span>
<span class="fc" id="L461">            MenuBar.backspaceSK = impl.getBackspaceKeyCode();</span>
<span class="fc" id="L462">            MenuBar.clearSK = impl.getClearKeyCode();</span>

<span class="fc" id="L464">            INSTANCE.PATHLENGTH = impl.getDragPathLength();</span>
<span class="fc" id="L465">            INSTANCE.dragPathX = new float[INSTANCE.PATHLENGTH];</span>
<span class="fc" id="L466">            INSTANCE.dragPathY = new float[INSTANCE.PATHLENGTH];</span>
<span class="fc" id="L467">            INSTANCE.dragPathTime = new long[INSTANCE.PATHLENGTH];</span>
<span class="fc" id="L468">            com.codename1.util.StringUtil.setImplementation(impl);</span>
<span class="fc" id="L469">            com.codename1.io.Util.setImplementation(impl);</span>

            // this can happen on some cases where an application was restarted etc...
            // generally its probably a bug but we can let it slide...
<span class="fc bfc" id="L473" title="All 2 branches covered.">            if (INSTANCE.edt == null) {</span>
<span class="fc" id="L474">                INSTANCE.touchScreen = impl.isTouchDevice();</span>
                // initialize the Codename One EDT which from now on will take all responsibility
                // for the event delivery.
<span class="fc" id="L477">                INSTANCE.edt = new CodenameOneThread(new RunnableWrapper(null, 3), &quot;EDT&quot;);</span>
<span class="fc" id="L478">                impl.setThreadPriority(INSTANCE.edt, impl.getEDTThreadPriority());</span>
<span class="fc" id="L479">                INSTANCE.edt.start();</span>
            }
<span class="fc" id="L481">            impl.postInit();</span>
<span class="fc" id="L482">            INSTANCE.setCommandBehavior(commandBehaviour);</span>
<span class="fc" id="L483">        } else {</span>
<span class="fc" id="L484">            impl.confirmControlView();</span>
        }
<span class="fc" id="L486">    }</span>

    /**
     * Closes down the EDT and Codename One, under normal conditions this method is completely unnecessary
     * since exiting the application will shut down Codename One. However, if the application is minimized
     * and the user wishes to free all resources without exiting the application then this method can be used.
     * Once this method is used Codename One will no longer work and Display.init(Object) should be invoked
     * again for any further Codename One call!
     * Notice that minimize (being a Codename One method) MUST be invoked before invoking this method!
     */
    public static void deinitialize() {

<span class="fc" id="L498">        INSTANCE.codenameOneRunning = false;</span>
<span class="fc" id="L499">        synchronized (lock) {</span>
<span class="fc" id="L500">            lock.notifyAll();</span>
<span class="fc" id="L501">        }</span>
<span class="fc" id="L502">    }</span>

    /**
     * This method returns true if the Display is initialized.
     *
     * @return true if the EDT is running
     */
    public static boolean isInitialized() {
<span class="pc bpc" id="L510" title="2 of 6 branches missed.">        return INSTANCE.codenameOneRunning &amp;&amp; (impl != null &amp;&amp; impl.isInitialized());</span>
    }

    /**
     * Return the Display instance
     *
     * @return the Display instance
     */
    public static Display getInstance() {
<span class="fc" id="L519">        return INSTANCE;</span>
    }

    /**
     * Sets a bookmark that can restore the app to a particular state.  This takes a
     * {@link Runnable} that will be run when {@link #restoreToBookmark()} () } is called.
     *
     * &lt;p&gt;The primary purpose of this feature is live code refresh.&lt;/p&gt;
     *
     * @param bookmark A {@link Runnable} that can be run to restore the app to a particular point.
     * @since 8.0
     */
    public void setBookmark(Runnable bookmark) {
<span class="nc" id="L532">        this.bookmark = bookmark;</span>
<span class="nc" id="L533">    }</span>

    /**
     * Runs the last bookmark that was set using {@link #setBookmark(java.lang.Runnable) }
     *
     * @since 8.0
     */
    public void restoreToBookmark() {
<span class="nc bnc" id="L541" title="All 2 branches missed.">        if (this.bookmark != null) {</span>
<span class="nc" id="L542">            this.bookmark.run();</span>
        }
<span class="nc" id="L544">    }</span>

    /**
     * Gets reference to plugin support object.
     *
     * @return The plugin support object.
     * @since 8.0
     */
    public PluginSupport getPluginSupport() {
<span class="nc" id="L553">        return pluginSupport;</span>
    }

    /**
     * This method allows us to manipulate the drag started detection logic.
     * If the pointer was dragged for more than this percentage of the display size it
     * is safe to assume that a drag is in progress.
     *
     * @return motion percentage
     */
    public int getDragStartPercentage() {
<span class="nc" id="L564">        return getImplementation().getDragStartPercentage();</span>
    }

    /**
     * This method allows us to manipulate the drag started detection logic.
     * If the pointer was dragged for more than this percentage of the display size it
     * is safe to assume that a drag is in progress.
     *
     * @param dragStartPercentage percentage of the screen required to initiate drag
     */
    public void setDragStartPercentage(int dragStartPercentage) {
<span class="nc" id="L575">        getImplementation().setDragStartPercentage(dragStartPercentage);</span>
<span class="nc" id="L576">    }</span>

    CodenameOneImplementation getImplementation() {
<span class="fc" id="L579">        return impl;</span>
    }

    /**
     * Indicates the maximum frames the API will try to draw every second
     * by default this is set to 10. The advantage of limiting
     * framerate is to allow the CPU to perform other tasks besides drawing.
     * Notice that when no change is occurring on the screen no frame is drawn and
     * so a high/low FPS will have no effect then.
     * 10FPS would be very reasonable for a business application.
     *
     * @param rate the frame rate
     */
    public void setFramerate(int rate) {
<span class="nc" id="L593">        framerateLock = 1000 / rate;</span>
<span class="nc" id="L594">    }</span>

    /**
     * Vibrates the device for the given length of time, notice that this might ignore the time value completely
     * on some OS's where this level of control isn't supported e.g. iOS see: https://github.com/codenameone/CodenameOne/issues/1904
     *
     * @param duration length of time to vibrate (might be ignored)
     */
    public void vibrate(int duration) {
<span class="nc" id="L603">        impl.vibrate(duration);</span>
<span class="nc" id="L604">    }</span>

    /**
     * Flash the backlight of the device for the given length of time
     *
     * @param duration length of time to flash the backlight
     * @deprecated this refers to functionality of devices that are no longer sold, not to the devices &quot;flash&quot;
     */
    public void flashBacklight(int duration) {
<span class="nc" id="L613">        impl.flashBacklight(duration);</span>
<span class="nc" id="L614">    }</span>

    /**
     * Manually announces text to native accessibility services, optionally associating the
     * announcement with a specific component. Most assistive technologies will announce a
     * component automatically when it gains focus; this method is intended for situations
     * where an announcement should occur independently of focus changes.
     *
     * @param cmp  the component related to this announcement or {@code null} for the root view
     * @param text the message to announce
     */
    public void announceForAccessibility(Component cmp, String text) {
<span class="fc" id="L626">        impl.announceForAccessibility(cmp, text);</span>
<span class="fc" id="L627">    }</span>

    /**
     * Convenience overload to announce text without specifying a component.
     *
     * @param text the message to announce
     */
    public void announceForAccessibility(String text) {
<span class="nc" id="L635">        announceForAccessibility(null, text);</span>
<span class="nc" id="L636">    }</span>

    /**
     * Returns the status of the show during edit flag
     *
     * @return one of the following: SHOW_DURING_EDIT_IGNORE,
     * SHOW_DURING_EDIT_EXCEPTION, SHOW_DURING_EDIT_ALLOW_DISCARD,
     * SHOW_DURING_EDIT_ALLOW_SAVE, SHOW_DURING_EDIT_SET_AS_NEXT
     * @deprecated this method isn't applicable in modern devices
     */
    public int getShowDuringEditBehavior() {
<span class="nc" id="L647">        return showDuringEdit;</span>
    }

    /**
     * Invoking the show() method of a form/dialog while the user is editing
     * text in the native text box can have several behaviors: SHOW_DURING_EDIT_IGNORE,
     * SHOW_DURING_EDIT_EXCEPTION, SHOW_DURING_EDIT_ALLOW_DISCARD,
     * SHOW_DURING_EDIT_ALLOW_SAVE, SHOW_DURING_EDIT_SET_AS_NEXT
     *
     * @param showDuringEdit one of the following: SHOW_DURING_EDIT_IGNORE,
     *                       SHOW_DURING_EDIT_EXCEPTION, SHOW_DURING_EDIT_ALLOW_DISCARD,
     *                       SHOW_DURING_EDIT_ALLOW_SAVE, SHOW_DURING_EDIT_SET_AS_NEXT
     * @deprecated this method isn't applicable in modern devices
     */
    public void setShowDuringEditBehavior(int showDuringEdit) {
<span class="nc" id="L662">        this.showDuringEdit = showDuringEdit;</span>
<span class="nc" id="L663">    }</span>

    /**
     * Indicates the maximum frames the API will try to draw every second
     *
     * @return the frame rate
     */
    public int getFrameRate() {
<span class="fc" id="L671">        return 1000 / framerateLock;</span>
    }

    /**
     * Returns true if we are currently in the event dispatch thread.
     * This is useful for generic code that can be used both with the
     * EDT and outside of it.
     *
     * @return true if we are currently in the event dispatch thread;
     * otherwise false
     */
    public boolean isEdt() {
<span class="fc bfc" id="L683" title="All 2 branches covered.">        return edt == Thread.currentThread();</span>
    }

    /**
     * Plays sound for the dialog
     */
    void playDialogSound(final int type) {
<span class="nc" id="L690">        impl.playDialogSound(type);</span>
<span class="nc" id="L691">    }</span>

    /**
     * Stops the remote control service.  This should be implemented in the platform
     * to handle unbinding the {@link com.codename1.media.RemoteControlListener} with the platform's remote control.
     * &lt;p&gt;This is executed when a new listener is registered using {@link com.codename1.media.MediaManager#setRemoteControlListener(com.codename1.media.RemoteControlListener) }&lt;/p&gt;
     *
     * @since 7.0
     */
    public void stopRemoteControl() {
<span class="fc" id="L701">        impl.stopRemoteControl();</span>
<span class="fc" id="L702">    }</span>

    /**
     * Starts the remote control service.  This should be implemented
     * in the platform to handle binding the {@link RemoteControlListener} with
     * the platform's remote control.
     *
     * &lt;p&gt;This is executed when the user registers a new listener using {@link MediaManager#setRemoteControlListener(com.codename1.media.RemoteControlListener) }&lt;/p&gt;
     *
     * @since 7.0
     */
    public void startRemoteControl() {
<span class="fc" id="L714">        impl.startRemoteControl();</span>
<span class="fc" id="L715">    }</span>

    /**
     * Returns true if the platform is in dark mode, null is returned for
     * unknown status
     *
     * @return true in case of dark mode
     */
    public Boolean isDarkMode() {
<span class="nc bnc" id="L724" title="All 2 branches missed.">        if (darkMode != null) {</span>
<span class="nc" id="L725">            return darkMode;</span>
        }
<span class="nc" id="L727">        return impl.isDarkMode();</span>
    }

    /**
     * Override the default dark mode setting
     *
     * @param darkMode can be set to null to reset to platform default
     */
    public void setDarkMode(Boolean darkMode) {
<span class="nc" id="L736">        this.darkMode = darkMode;</span>
<span class="nc" id="L737">    }</span>

    /**
     * Checks if async stack traces are enabled.  If enabled, the stack trace
     * at the point of {@link #callSerially(java.lang.Runnable) } calls will
     * be recorded, and logged in the case that there is an uncaught exception.
     * &lt;p&gt;Currently this is only supported in the JavaSE/Simulator port.&lt;/p&gt;
     *
     * @return Whether async stack traces are enabled.
     * @see #setEnableAsyncStackTraces(boolean)
     * @since 7.0
     */
    public boolean isEnableAsyncStackTraces() {
<span class="fc" id="L750">        return enableAsyncStackTraces;</span>
    }

    /**
     * Enables or disables async stack traces.  If enabled, the stack trace
     * at the point of {@link #callSerially(java.lang.Runnable) } calls will
     * be recorded, and logged in the case that there is an uncaught exception.
     *
     * &lt;p&gt;Currently this is only supported in the JavaSE/Simulator port.&lt;/p&gt;
     *
     * @param enableAsyncStackTraces True to enable async stack traces.
     * @see #isEnableAsyncStackTraces()
     * @since 7.0
     */
    public void setEnableAsyncStackTraces(boolean enableAsyncStackTraces) {
<span class="nc" id="L765">        this.enableAsyncStackTraces = enableAsyncStackTraces;</span>
<span class="nc" id="L766">    }</span>

    /**
     * Causes the runnable to be invoked on the event dispatch thread. This method
     * returns immediately and will not wait for the serial call to occur
     *
     * @param r runnable (NOT A THREAD!) that will be invoked on the EDT serial to
     *          the paint and key handling events
     */
    public void callSerially(Runnable r) {
        // otherwise this will fail in an odd locaiton. Better it fails here...
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">        if (r == null) {</span>
<span class="nc" id="L778">            throw new NullPointerException();</span>
        }
<span class="fc bfc" id="L780" title="All 2 branches covered.">        if (codenameOneRunning) {</span>
<span class="fc" id="L781">            synchronized (lock) {</span>
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">                scheduleSerialCall(isEnableAsyncStackTraces() ? new DebugRunnable(r) : r);</span>
<span class="fc" id="L783">                lock.notifyAll();</span>
<span class="fc" id="L784">            }</span>
        } else {
<span class="fc" id="L786">            r.run();</span>
        }
<span class="fc" id="L788">    }</span>

    // We factor out the scheduling of a serial call so that we can
    // use the Schedule annotation for IntelliJ async debugging https://www.jetbrains.com/help/idea/debug-asynchronous-code.html
    private void scheduleSerialCall(@Async.Schedule Runnable r) {
<span class="fc" id="L793">        pendingSerialCalls.add(r);</span>
<span class="fc" id="L794">    }</span>

    /**
     * Causes the runnable to be invoked on the event dispatch thread when the event
     * dispatch thread is idle. This method returns immediately and will not wait for the serial call
     * to occur. Notice this method is identical to call serially but will perform the runnable only when
     * the EDT is idle
     *
     * @param r runnable (NOT A THREAD!) that will be invoked on the EDT serial to
     *          the paint and key handling events
     */
    public void callSeriallyOnIdle(Runnable r) {
<span class="nc bnc" id="L806" title="All 2 branches missed.">        if (codenameOneRunning) {</span>
<span class="nc" id="L807">            synchronized (lock) {</span>
<span class="nc" id="L808">                pendingIdleSerialCalls.add(r);</span>
<span class="nc" id="L809">                lock.notifyAll();</span>
<span class="nc" id="L810">            }</span>
        } else {
<span class="nc" id="L812">            r.run();</span>
        }
<span class="nc" id="L814">    }</span>

    public String getLineSeparator() {
<span class="nc" id="L817">        return impl.getLineSeparator();</span>
    }

    /**
     * Allows executing a background task in a separate low priority thread. Tasks are serialized
     * so they don't overload the CPU.
     *
     * @param r the task to perform in the background
     */
    public void scheduleBackgroundTask(@Async.Schedule Runnable r) {
<span class="fc" id="L827">        synchronized (lock) {</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">            if (backgroundTasks == null) {</span>
<span class="fc" id="L829">                backgroundTasks = new ArrayList&lt;Runnable&gt;();</span>
            }
<span class="fc" id="L831">            backgroundTasks.add(r);</span>
<span class="pc bpc" id="L832" title="1 of 2 branches missed.">            if (backgroundThread == null) {</span>
<span class="fc" id="L833">                backgroundThread = new CodenameOneThread(new Runnable() {</span>
                    public void run() {
                        // using while true to avoid double lock optimization with synchronized block
                        while (true) {
<span class="fc" id="L837">                            Runnable nextTask = null;</span>
<span class="fc" id="L838">                            synchronized (lock) {</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">                                if (backgroundTasks.size() &gt; 0) {</span>
<span class="fc" id="L840">                                    nextTask = backgroundTasks.get(0);</span>
                                } else {
<span class="fc" id="L842">                                    backgroundThread = null;</span>
<span class="fc" id="L843">                                    return;</span>
                                }
<span class="fc" id="L845">                                backgroundTasks.remove(0);</span>
<span class="fc" id="L846">                            }</span>
                            //preent a runtime exception to crash the
                            //backgroundThread
                            try {
<span class="fc" id="L850">                                executeBackgroundTaskRunnable(nextTask);</span>
<span class="nc" id="L851">                            } catch (Throwable e) {</span>
<span class="nc" id="L852">                                Log.e(e);</span>
<span class="fc" id="L853">                            }</span>
                            try {
<span class="fc" id="L855">                                Thread.sleep(10);</span>
<span class="nc" id="L856">                            } catch (InterruptedException ex) {</span>
<span class="fc" id="L857">                            }</span>
<span class="fc" id="L858">                        }</span>
                    }
                }, &quot;Task Thread&quot;);
<span class="fc" id="L861">                backgroundThread.setPriority(Thread.MIN_PRIORITY + 1);</span>
<span class="fc" id="L862">                backgroundThread.start();</span>
            }
<span class="fc" id="L864">        }</span>
<span class="fc" id="L865">    }</span>

    private void executeBackgroundTaskRunnable(@Async.Execute Runnable r) {
<span class="fc" id="L868">        r.run();</span>
<span class="fc" id="L869">    }</span>

    /**
     * Identical to callSerially with the added benefit of waiting for the Runnable method to complete.
     *
     * @param r runnable (NOT A THREAD!) that will be invoked on the EDT serial to
     *          the paint and key handling events
     * @throws IllegalStateException if this method is invoked on the event dispatch thread (e.g. during
     *                               paint or event handling).
     */
    public void callSeriallyAndWait(Runnable r) {
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">        if (isEdt()) {</span>
<span class="nc" id="L881">            throw new RuntimeException(&quot;This method MUST NOT be invoked on the EDT&quot;);</span>
        }
<span class="fc" id="L883">        RunnableWrapper c = new RunnableWrapper(r, 0);</span>
<span class="fc" id="L884">        callSerially(c);</span>
<span class="fc" id="L885">        flushEdt();</span>
<span class="fc" id="L886">        synchronized (lock) {</span>
<span class="fc bfc" id="L887" title="All 2 branches covered.">            while (!c.isDone()) {</span>
                try {
                    // poll doneness to prevent potential race conditions
<span class="fc" id="L890">                    lock.wait(50);</span>
<span class="nc" id="L891">                } catch (InterruptedException err) {</span>
<span class="pc" id="L892">                }</span>
            }
<span class="fc" id="L894">        }</span>
<span class="fc" id="L895">    }</span>

    /**
     * Checks if this platform uses input modes.  No current platforms return true for this.  It is a holdover from J2ME.
     *
     * @return True if the platform supports input modes.  Only true for J2ME and RIM.
     */
    public boolean platformUsesInputMode() {
<span class="nc" id="L903">        return impl.platformUsesInputMode();</span>
    }

    /**
     * Identical to callSerially with the added benefit of waiting for the Runnable method to complete.
     *
     * @param r       runnable (NOT A THREAD!) that will be invoked on the EDT serial to
     *                the paint and key handling events
     * @param timeout timeout duration, on timeout the method just returns
     * @throws IllegalStateException if this method is invoked on the event dispatch thread (e.g. during
     *                               paint or event handling).
     */
    public void callSeriallyAndWait(Runnable r, int timeout) {
<span class="nc" id="L916">        RunnableWrapper c = new RunnableWrapper(r, 0);</span>
<span class="nc" id="L917">        callSerially(c);</span>
<span class="nc" id="L918">        synchronized (lock) {</span>
<span class="nc" id="L919">            long t = System.currentTimeMillis();</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">            while (!c.isDone()) {</span>
                try {
                    // poll doneness to prevent potential race conditions
<span class="nc" id="L923">                    lock.wait(20);</span>
<span class="nc" id="L924">                } catch (InterruptedException err) {</span>
<span class="nc" id="L925">                }</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">                if (System.currentTimeMillis() - t &gt;= timeout) {</span>
<span class="nc" id="L927">                    return;</span>
                }
            }
<span class="nc" id="L930">        }</span>
<span class="nc" id="L931">    }</span>

    /**
     * Allows us to &quot;flush&quot; the edt to allow any pending transitions and input to go
     * by before continuing with our other tasks.
     */
    void flushEdt() {
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">        if (!isEdt()) {</span>
<span class="fc" id="L939">            return;</span>
        }
<span class="nc bnc" id="L941" title="All 2 branches missed.">        while (!shouldEDTSleepNoFormAnimation()) {</span>
<span class="nc" id="L942">            edtLoopImpl();</span>
        }
<span class="nc bnc" id="L944" title="All 4 branches missed.">        while (animationQueue != null &amp;&amp; animationQueue.size() &gt; 0) {</span>
<span class="nc" id="L945">            edtLoopImpl();</span>
        }
<span class="nc" id="L947">    }</span>

    /**
     * Restores the menu in the given form
     */
    private void restoreMenu(Form f) {
<span class="nc bnc" id="L953" title="All 2 branches missed.">        if (f != null) {</span>
<span class="nc" id="L954">            f.restoreMenu();</span>
        }
<span class="nc" id="L956">    }</span>

    /**
     * Returns true if the system is currently in the process of transitioning between
     * forms
     *
     * @return true if in the middle of form transition
     */
    public boolean isInTransition() {
<span class="nc bnc" id="L965" title="All 4 branches missed.">        if (animationQueue != null &amp;&amp; animationQueue.size() &gt; 0) {</span>
<span class="nc" id="L966">            Animation ani = animationQueue.get(0);</span>
<span class="nc" id="L967">            return ani instanceof Transition;</span>
        }
<span class="nc" id="L969">        return false;</span>
    }

    private void paintTransitionAnimation() {
<span class="nc" id="L973">        Animation ani = animationQueue.get(0);</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">        if (!ani.animate()) {</span>
<span class="nc" id="L975">            animationQueue.remove(0);</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">            if (ani instanceof Transition) {</span>
<span class="nc" id="L977">                Form source = (Form) ((Transition) ani).getSource();</span>
<span class="nc" id="L978">                restoreMenu(source);</span>

<span class="nc bnc" id="L980" title="All 2 branches missed.">                if (animationQueue.size() &gt; 0) {</span>
<span class="nc" id="L981">                    ani = animationQueue.get(0);</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">                    if (ani instanceof Transition) {</span>
<span class="nc" id="L983">                        ((Transition) ani).initTransition();</span>
                    }
                } else {
<span class="nc" id="L986">                    Form f = (Form) ((Transition) ani).getDestination();</span>
<span class="nc" id="L987">                    restoreMenu(f);</span>
<span class="nc bnc" id="L988" title="All 6 branches missed.">                    if (source == null || source == impl.getCurrentForm() || source == getCurrent()) {</span>
<span class="nc" id="L989">                        setCurrentForm(f);</span>
                    }
<span class="nc" id="L991">                    ((Transition) ani).cleanup();</span>
                }
<span class="nc" id="L993">                return;</span>
            }
        }
<span class="nc" id="L996">        ani.paint(codenameOneGraphics);</span>

<span class="nc" id="L998">        impl.flushGraphics();</span>

<span class="nc bnc" id="L1000" title="All 2 branches missed.">        if (transitionDelay &gt; 0) {</span>
            // yield for a fraction, some devices don't &quot;properly&quot; implement
            // flush and so require the painting thread to get CPU too.
            try {
<span class="nc" id="L1004">                synchronized (lock) {</span>
<span class="nc" id="L1005">                    long end = System.currentTimeMillis() + transitionDelay;</span>
                    while (true) {
<span class="nc" id="L1007">                        long remaining = end - System.currentTimeMillis();</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">                        if (remaining &lt;= 0) {</span>
<span class="nc" id="L1009">                            break;</span>
                        }
<span class="nc" id="L1011">                        lock.wait(remaining);</span>
<span class="nc" id="L1012">                        break;</span>
                    }
<span class="nc" id="L1014">                }</span>
<span class="nc" id="L1015">            } catch (InterruptedException ex) {</span>
<span class="nc" id="L1016">                ex.printStackTrace();</span>
<span class="nc" id="L1017">            }</span>
        }
<span class="nc" id="L1019">    }</span>

    /**
     * This method represents the event thread for the UI library on which
     * all events are carried out. It differs from the MIDP event thread to
     * prevent blocking of actual input and drawing operations. This also
     * enables functionality such as &quot;true&quot; modal dialogs etc...
     */
    void mainEDTLoop() {
<span class="fc" id="L1028">        impl.initEDT();</span>
<span class="fc" id="L1029">        UIManager.getInstance();</span>
        try {
            // when there is no current form the EDT is useful only
            // for features such as call serially
<span class="fc bfc" id="L1033" title="All 2 branches covered.">            while (impl.getCurrentForm() == null) { // PMD Fix: AvoidBranchingStatementAsLastInLoop</span>
<span class="fc" id="L1034">                synchronized (lock) {</span>
<span class="pc bpc" id="L1035" title="1 of 4 branches missed.">                    while (shouldEDTSleep() &amp;&amp; pendingIdleSerialCalls.isEmpty()) {</span>
                        try {
<span class="fc" id="L1037">                            lock.wait();</span>
<span class="nc" id="L1038">                        } catch (InterruptedException ie) {</span>
<span class="nc" id="L1039">                            Thread.currentThread().interrupt();</span>
<span class="nc" id="L1040">                            break;</span>
<span class="fc" id="L1041">                        }</span>
                    }
<span class="pc bpc" id="L1043" title="3 of 4 branches missed.">                    if (shouldEDTSleep() &amp;&amp; !pendingIdleSerialCalls.isEmpty()) {</span>
<span class="nc" id="L1044">                        Runnable r = pendingIdleSerialCalls.remove(0);</span>
<span class="nc" id="L1045">                        callSerially(r);</span>
                    }

                    // paint transition or intro animations and don't do anything else if such
                    // animations are in progress...
<span class="pc bpc" id="L1050" title="3 of 4 branches missed.">                    if (animationQueue != null &amp;&amp; animationQueue.size() &gt; 0) {</span>
<span class="nc" id="L1051">                        paintTransitionAnimation();</span>
<span class="nc" id="L1052">                        continue;</span>
                    }
<span class="fc" id="L1054">                }</span>
<span class="fc" id="L1055">                processSerialCalls();</span>
            }
<span class="nc" id="L1057">        } catch (Throwable err) {</span>
<span class="nc" id="L1058">            Log.e(err);</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">            if (crashReporter != null) {</span>
<span class="nc" id="L1060">                crashReporter.exception(err);</span>
            }
<span class="nc bnc" id="L1062" title="All 2 branches missed.">            if (!impl.handleEDTException(err)) {</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">                if (errorHandler != null) {</span>
<span class="nc" id="L1064">                    errorHandler.fireActionEvent(new ActionEvent(err, ActionEvent.Type.Exception));</span>
                } else {
<span class="nc" id="L1066">                    Dialog.show(&quot;Error&quot;, &quot;An internal application error occurred: &quot; + err, &quot;OK&quot;, null);</span>
                }
            }
<span class="fc" id="L1069">        }</span>

<span class="fc bfc" id="L1071" title="All 2 branches covered.">        while (codenameOneRunning) { // PMD Fix: AvoidBranchingStatementAsLastInLoop</span>
            try {
                // wait indefinetly Lock surrounds the should method to prevent serial calls from
                // getting &quot;lost&quot;
<span class="fc" id="L1075">                synchronized (lock) {</span>
<span class="fc bfc" id="L1076" title="All 2 branches covered.">                    if (shouldEDTSleep()) {</span>
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">                        if (!pendingIdleSerialCalls.isEmpty()) {</span>
<span class="nc" id="L1078">                            Runnable r = pendingIdleSerialCalls.remove(0);</span>
<span class="nc" id="L1079">                            callSerially(r);</span>
<span class="nc" id="L1080">                        } else {</span>
<span class="fc" id="L1081">                            impl.edtIdle(true);</span>
<span class="pc bpc" id="L1082" title="1 of 4 branches missed.">                            while (shouldEDTSleep() &amp;&amp; pendingIdleSerialCalls.isEmpty()) {</span>
                                try {
<span class="fc" id="L1084">                                    lock.wait();</span>
<span class="nc" id="L1085">                                } catch (InterruptedException ie) {</span>
<span class="nc" id="L1086">                                    Thread.currentThread().interrupt();</span>
<span class="nc" id="L1087">                                    break;</span>
<span class="fc" id="L1088">                                }</span>
                            }
<span class="fc" id="L1090">                            impl.edtIdle(false);</span>
<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">                            if (!pendingIdleSerialCalls.isEmpty()) {</span>
<span class="nc" id="L1092">                                Runnable r = pendingIdleSerialCalls.remove(0);</span>
<span class="nc" id="L1093">                                callSerially(r);</span>
                            }
                        }
                    }
<span class="fc" id="L1097">                }</span>


<span class="fc" id="L1100">                edtLoopImpl();</span>
<span class="nc" id="L1101">            } catch (Throwable err) {</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">                if (!codenameOneRunning) {</span>
<span class="nc" id="L1103">                    return;</span>
                }
<span class="nc" id="L1105">                Log.e(err);</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">                if (crashReporter != null) {</span>
<span class="nc" id="L1107">                    CodenameOneThread.handleException(err);</span>
                }
<span class="nc bnc" id="L1109" title="All 2 branches missed.">                if (!impl.handleEDTException(err)) {</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">                    if (errorHandler != null) {</span>
<span class="nc" id="L1111">                        errorHandler.fireActionEvent(new ActionEvent(err, ActionEvent.Type.Exception));</span>
                    } else {
<span class="nc" id="L1113">                        Dialog.show(&quot;Error&quot;, &quot;An internal application error occurred: &quot; + err, &quot;OK&quot;, null);</span>
                    }
                }
<span class="pc" id="L1116">            }</span>
        }
<span class="fc" id="L1118">        impl.deinitialize();</span>
        //INSTANCE.impl = null;
        //INSTANCE.codenameOneGraphics = null;
<span class="fc" id="L1121">        INSTANCE.edt = null;</span>
<span class="fc" id="L1122">    }</span>

    /**
     * Implementation of the event dispatch loop content
     */
    void edtLoopImpl() {
        try {
            // transitions shouldn't be bound by framerate
<span class="pc bpc" id="L1130" title="3 of 4 branches missed.">            if (animationQueue == null || animationQueue.size() == 0) {</span>
                // prevents us from waking up the EDT too much and
                // thus exhausting the systems resources. The + 1
                // prevents us from ever waiting 0 milliseconds which
                // is the same as waiting with no time limit
<span class="pc bpc" id="L1135" title="1 of 2 branches missed.">                if (!noSleep) {</span>
<span class="fc" id="L1136">                    synchronized (lock) {</span>
<span class="fc" id="L1137">                        impl.edtIdle(true);</span>
<span class="fc" id="L1138">                        long waitTime = Math.max(1, framerateLock - (time));</span>
<span class="fc" id="L1139">                        long end = System.currentTimeMillis() + waitTime;</span>
                        while (true) {
<span class="fc" id="L1141">                            long remaining = end - System.currentTimeMillis();</span>
<span class="pc bpc" id="L1142" title="1 of 2 branches missed.">                            if (remaining &lt;= 0) {</span>
<span class="nc" id="L1143">                                break;</span>
                            }
                            try {
<span class="fc" id="L1146">                                lock.wait(remaining);</span>
<span class="fc" id="L1147">                                break;</span>
<span class="nc" id="L1148">                            } catch (InterruptedException ie) {</span>
<span class="nc" id="L1149">                                Thread.currentThread().interrupt();</span>
<span class="nc" id="L1150">                                break;</span>
                            }
                        }
<span class="fc" id="L1153">                        impl.edtIdle(false);</span>
<span class="fc" id="L1154">                    }</span>
                }
            } else {
                // paint transition or intro animations and don't do anything else if such
                // animations are in progress...
<span class="nc" id="L1159">                paintTransitionAnimation();</span>
<span class="nc" id="L1160">                return;</span>
            }
<span class="nc" id="L1162">        } catch (Exception ignor) {</span>
<span class="nc" id="L1163">            Log.e(ignor);</span>
<span class="fc" id="L1164">        }</span>
<span class="fc" id="L1165">        long currentTime = System.currentTimeMillis();</span>

        // minimal amount of sync, just flipping the stack pointers
<span class="fc" id="L1168">        synchronized (lock) {</span>
<span class="fc" id="L1169">            inputEventStackPointerTmp = inputEventStackPointer;</span>
<span class="fc" id="L1170">            inputEventStackPointer = 0;</span>
<span class="fc" id="L1171">            lastDragOffset = -1;</span>
<span class="fc" id="L1172">            int[] qt = inputEventStackTmp;</span>
<span class="fc" id="L1173">            inputEventStackTmp = inputEventStack;</span>

            // We have a special flag here for a case where the input event stack might still be processing this can
            // happen if an event callback calls something like invokeAndBlock while processing and might reach
            // this code again
<span class="pc bpc" id="L1178" title="1 of 2 branches missed.">            if (qt[qt.length - 1] == Integer.MAX_VALUE) {</span>
<span class="nc" id="L1179">                inputEventStack = new int[qt.length];</span>
            } else {
<span class="fc" id="L1181">                inputEventStack = qt;</span>
<span class="fc" id="L1182">                qt[qt.length - 1] = 0;</span>
            }
<span class="fc" id="L1184">        }</span>

        // we copy the variables to the stack since the array might be replaced while we are working if the EDT
        // is nested into an &quot;invokeAndBlock&quot;
<span class="fc" id="L1188">        int actualTmpPointer = inputEventStackPointerTmp;</span>
<span class="fc" id="L1189">        inputEventStackPointerTmp = 0;</span>
<span class="fc" id="L1190">        int[] actualStack = inputEventStackTmp;</span>
<span class="fc" id="L1191">        int offset = 0;</span>
<span class="fc" id="L1192">        actualStack[actualStack.length - 1] = Integer.MAX_VALUE;</span>
<span class="pc bpc" id="L1193" title="1 of 2 branches missed.">        while (offset &lt; actualTmpPointer) {</span>
<span class="nc" id="L1194">            offset = handleEvent(offset, actualStack);</span>
        }

<span class="fc" id="L1197">        actualStack[actualStack.length - 1] = 0;</span>

<span class="pc bpc" id="L1199" title="1 of 2 branches missed.">        if (!impl.isInitialized()) {</span>
<span class="nc" id="L1200">            return;</span>
        }
<span class="fc" id="L1202">        codenameOneGraphics.setGraphics(impl.getNativeGraphics());</span>
<span class="fc" id="L1203">        Form current = impl.getCurrentForm();</span>
<span class="fc bfc" id="L1204" title="All 2 branches covered.">        if (current != null) {</span>
            // Revalidate components that registered to be revalidated
            // before the next paint cycle.
<span class="fc" id="L1207">            current.flushRevalidateQueue();</span>
        }
<span class="fc" id="L1209">        impl.paintDirty();</span>

        // draw the animations

<span class="fc bfc" id="L1213" title="All 2 branches covered.">        if (current != null) {</span>
<span class="fc" id="L1214">            current.repaintAnimations();</span>
            // check key repeat events
<span class="fc" id="L1216">            long t = System.currentTimeMillis();</span>
<span class="pc bpc" id="L1217" title="3 of 4 branches missed.">            if (keyRepeatCharged &amp;&amp; nextKeyRepeatEvent &lt;= t) {</span>
<span class="nc" id="L1218">                current.keyRepeated(keyRepeatValue);</span>
<span class="nc" id="L1219">                nextKeyRepeatEvent = t + keyRepeatNextIntervalTime;</span>
            }
<span class="pc bpc" id="L1221" title="3 of 4 branches missed.">            if (longPressCharged &amp;&amp; longPressInterval &lt;= t - longKeyPressTime) {</span>
<span class="nc" id="L1222">                longPressCharged = false;</span>
<span class="nc" id="L1223">                current.longKeyPress(keyRepeatValue);</span>
            }
<span class="pc bpc" id="L1225" title="3 of 4 branches missed.">            if (longPointerCharged &amp;&amp; longPressInterval &lt;= t - longKeyPressTime) {</span>
<span class="nc" id="L1226">                longPointerCharged = false;</span>
<span class="nc" id="L1227">                current.longPointerPress(pointerX, pointerY);</span>
            }
        }
<span class="fc" id="L1230">        processSerialCalls();</span>

<span class="fc" id="L1232">        time = System.currentTimeMillis() - currentTime;</span>
<span class="fc" id="L1233">    }</span>

    boolean hasNoSerialCallsPending() {
<span class="fc bfc" id="L1236" title="All 2 branches covered.">        return pendingSerialCalls.size() == 0;</span>
    }

    /**
     * Called by the underlying implementation to indicate that editing in the native
     * system has completed and changes should propagate into Codename One
     *
     * @param c    edited component
     * @param text new text for the component
     */
    public void onEditingComplete(final Component c, final String text) {
<span class="pc bpc" id="L1247" title="3 of 4 branches missed.">        if (!isEdt() &amp;&amp; codenameOneRunning) {</span>
<span class="nc" id="L1248">            Display.getInstance().callSerially(new Runnable() {</span>
                public void run() {
<span class="nc" id="L1250">                    onEditingComplete(c, text);</span>
<span class="nc" id="L1251">                }</span>
            });
<span class="nc" id="L1253">            return;</span>
        }
<span class="fc" id="L1255">        c.onEditComplete(text);</span>
<span class="fc" id="L1256">        c.fireActionEvent();</span>
<span class="fc" id="L1257">    }</span>

    /**
     * Used by the EDT to process all the calls submitted via call serially
     */
    void processSerialCalls() {
<span class="fc" id="L1263">        processingSerialCalls = true;</span>
<span class="fc" id="L1264">        int size = pendingSerialCalls.size();</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">        if (size &gt; 0) {</span>
            //Runnable[] array = null;
<span class="fc" id="L1267">            synchronized (lock) {</span>
<span class="fc" id="L1268">                size = pendingSerialCalls.size();</span>
                //array = new Runnable[size];

                // copy all elements to an array and remove them otherwise invokeAndBlock from
                // within a callSerially() can cause an infinite loop...
                //pendingSerialCalls.toArray(array);
<span class="fc" id="L1274">                runningSerialCallsQueue.addAll(pendingSerialCalls);</span>

<span class="pc bpc" id="L1276" title="1 of 2 branches missed.">                if (size == pendingSerialCalls.size()) {</span>
                    // this is faster
<span class="fc" id="L1278">                    pendingSerialCalls.clear();</span>
                } else {
                    // this can occur if an element was added during the loop
<span class="nc bnc" id="L1281" title="All 2 branches missed.">                    for (int iter = 0; iter &lt; size; iter++) {</span>
<span class="nc" id="L1282">                        pendingSerialCalls.remove(0);</span>
                    }
                }
<span class="fc" id="L1285">            }</span>
<span class="fc bfc" id="L1286" title="All 2 branches covered.">            while (!runningSerialCallsQueue.isEmpty()) {</span>
<span class="fc" id="L1287">                executeSerialCall(runningSerialCallsQueue.remove(0));</span>
            }

            // after finishing an event cycle there might be serial calls waiting
            // to return.
<span class="fc" id="L1292">            synchronized (lock) {</span>
<span class="fc" id="L1293">                lock.notify();</span>
<span class="fc" id="L1294">            }</span>
        }
<span class="fc" id="L1296">        processingSerialCalls = false;</span>
<span class="fc" id="L1297">    }</span>

    // Executes a Runnable from a pending serial call. We wrap it in its
    // own function so we can use the Async.Execute annotation for debugging.
    // https://www.jetbrains.com/help/idea/debug-asynchronous-code.html
    private void executeSerialCall(@Async.Execute Runnable r) {
<span class="fc" id="L1303">        r.run();</span>
<span class="fc" id="L1304">    }</span>

    boolean isProcessingSerialCalls() {
<span class="nc" id="L1307">        return processingSerialCalls;</span>
    }

    void notifyDisplay() {
<span class="fc" id="L1311">        synchronized (lock) {</span>
<span class="fc" id="L1312">            lock.notify();</span>
<span class="fc" id="L1313">        }</span>
<span class="fc" id="L1314">    }</span>

    /**
     * Invokes a Runnable with blocking disabled.  If any attempt is made to block
     * (i.e. call {@link #invokeAndBlock(java.lang.Runnable) } from inside this Runnable,
     * it will result in a {@link BlockingDisallowedException} being thrown.
     *
     * @param r Runnable to be run immediately.
     * @throws BlockingDisallowedException If {@link #invokeAndBlock(java.lang.Runnable) } is attempted
     *                                     anywhere in the Runnable.
     * @since 7.0
     */
    public void invokeWithoutBlocking(Runnable r) {
<span class="nc bnc" id="L1327" title="All 4 branches missed.">        if (disableInvokeAndBlock || !isEdt()) {</span>
<span class="nc" id="L1328">            r.run();</span>
        } else {
<span class="nc" id="L1330">            disableInvokeAndBlock = true;</span>
            try {
<span class="nc" id="L1332">                r.run();</span>
            } finally {
<span class="nc" id="L1334">                disableInvokeAndBlock = false;</span>
            }
        }
<span class="nc" id="L1337">    }</span>

    /**
     * Invokes a RunnableWithResultSync with blocking disabled.  If any attempt is made to block
     * (i.e. call {@link #invokeAndBlock(java.lang.Runnable) } from inside this Runnable,
     * it will result in a {@link BlockingDisallowedException} being thrown.
     *
     * @param r RunnableWithResultSync to be run immediately.
     * @throws BlockingDisallowedException If {@link #invokeAndBlock(java.lang.Runnable) } is attempted
     *                                     anywhere in the Runnable.
     * @since 7.0
     */
    public &lt;T&gt; T invokeWithoutBlockingWithResultSync(RunnableWithResultSync&lt;T&gt; r) {
<span class="nc bnc" id="L1350" title="All 4 branches missed.">        if (disableInvokeAndBlock || !isEdt()) {</span>
<span class="nc" id="L1351">            return r.run();</span>
        } else {
<span class="nc" id="L1353">            disableInvokeAndBlock = true;</span>
            try {
<span class="nc" id="L1355">                return r.run();</span>
            } finally {
<span class="nc" id="L1357">                disableInvokeAndBlock = false;</span>
            }
        }
    }

    /**
     * Invokes runnable and blocks the current thread, if the current thread is the
     * EDT it will still be blocked in a way that doesn't break event dispatch .
     * &lt;b&gt;Important:&lt;/b&gt; calling this method spawns a new thread that shouldn't access the UI!&lt;br /&gt;
     * See &lt;a href=&quot;https://www.codenameone.com/manual/edt.html#_invoke_and_block&quot;&gt;
     * this section&lt;/a&gt; in the developer guide for further information.
     *
     * @param r          runnable (NOT A THREAD!) that will be invoked synchronously by this method
     * @param dropEvents indicates if the display should drop all events
     *                   while this runnable is running
     * @throws BlockingDisallowedException if this method is called while blocking is disabled (i.e. we are running
     *                                     inside a call to {@link #invokeWithoutBlocking(java.lang.Runnable) } on the EDT).
     */
    public void invokeAndBlock(Runnable r, boolean dropEvents) {
<span class="fc" id="L1376">        this.dropEvents = dropEvents;</span>
        try {
<span class="pc bpc" id="L1378" title="1 of 2 branches missed.">            if (isEdt()) {</span>
<span class="pc bpc" id="L1379" title="1 of 2 branches missed.">                if (disableInvokeAndBlock) {</span>
<span class="nc" id="L1380">                    throw new BlockingDisallowedException();</span>
                }
                // this class allows a runtime exception to propogate correctly out of the
                // internal thread
<span class="fc" id="L1384">                RunnableWrapper w = new RunnableWrapper(r, 1);</span>
<span class="fc" id="L1385">                RunnableWrapper.pushToThreadPool(w);</span>

<span class="fc" id="L1387">                synchronized (lock) {</span>
                    // prevent an invoke and block loop from breaking the ongoing event processing
<span class="pc bpc" id="L1389" title="1 of 2 branches missed.">                    if (inputEventStackPointerTmp &gt; 0) {</span>
<span class="nc" id="L1390">                        inputEventStackPointerTmp = inputEventStackPointer;</span>
                    }
                    try {
                        // yield the CPU for a very short time to let the invoke thread
                        // get started
<span class="fc" id="L1395">                        lock.wait(2);</span>
<span class="nc" id="L1396">                    } catch (InterruptedException ex) {</span>
<span class="nc" id="L1397">                        ex.printStackTrace();</span>
<span class="fc" id="L1398">                    }</span>

<span class="pc bpc" id="L1400" title="1 of 2 branches missed.">                    while (!runningSerialCallsQueue.isEmpty()) {</span>
<span class="nc" id="L1401">                        pendingSerialCalls.add(0, runningSerialCallsQueue.removeLast());</span>
                    }
<span class="fc" id="L1403">                }</span>


                // loop over the EDT until the thread completes then return
<span class="pc bpc" id="L1407" title="1 of 4 branches missed.">                while (!w.isDone() &amp;&amp; codenameOneRunning) {</span>
<span class="fc" id="L1408">                    edtLoopImpl();</span>
<span class="fc" id="L1409">                    synchronized (lock) {</span>
<span class="fc bfc" id="L1410" title="All 2 branches covered.">                        if (shouldEDTSleep()) {</span>
<span class="fc" id="L1411">                            impl.edtIdle(true);</span>
                            try {
<span class="fc" id="L1413">                                lock.wait(10);</span>
<span class="nc" id="L1414">                            } catch (InterruptedException ex) {</span>
<span class="fc" id="L1415">                            }</span>
<span class="fc" id="L1416">                            impl.edtIdle(false);</span>
                        }
<span class="fc" id="L1418">                    }</span>
                }
                // if the thread thew an exception we need to throw it onwards
<span class="pc bpc" id="L1421" title="1 of 2 branches missed.">                if (w.getErr() != null) {</span>
<span class="nc" id="L1422">                    throw w.getErr();</span>
                }
<span class="fc" id="L1424">            } else {</span>
<span class="nc" id="L1425">                r.run();</span>
            }
<span class="nc" id="L1427">        } catch (RuntimeException re) {</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">            if (!(re instanceof BlockingDisallowedException)) {</span>
<span class="nc" id="L1429">                Log.e(re);</span>
            }
<span class="nc" id="L1431">            throw re;</span>
        } finally {
<span class="fc" id="L1433">            this.dropEvents = false;</span>
        }
<span class="fc" id="L1435">    }</span>

    /**
     * Invokes runnable and blocks the current thread, if the current thread is the
     * EDT it will still be blocked in a way that doesn't break event dispatch .
     * &lt;b&gt;Important:&lt;/b&gt; calling this method spawns a new thread that shouldn't access the UI!&lt;br /&gt;
     * See &lt;a href=&quot;https://www.codenameone.com/manual/edt.html#_invoke_and_block&quot;&gt;
     * this section&lt;/a&gt; in the developer guide for further information.
     *
     * @param r runnable (NOT A THREAD!) that will be invoked synchroniously by this method
     */
    public void invokeAndBlock(Runnable r) {
<span class="fc" id="L1447">        invokeAndBlock(r, false);</span>
<span class="fc" id="L1448">    }</span>

    /**
     * The name of this method is misleading due to it's legacy. It will return true on the desktop too where
     * the mouse sends pointer events.
     *
     * @return true if this device supports touch/pointer events
     */
    public boolean isTouchScreenDevice() {
<span class="fc" id="L1457">        return touchScreen;</span>
    }

    /**
     * Indicates if this is a touch screen device that will return pen events,
     * defaults to true if the device has pen events but can be overriden by
     * the developer.
     *
     * @param touchScreen false if this is not a touch screen device
     */
    public void setTouchScreenDevice(boolean touchScreen) {
<span class="fc" id="L1468">        this.touchScreen = touchScreen;</span>
<span class="fc" id="L1469">    }</span>

    /**
     * Calling this method with noSleep=true will cause the edt to run without sleeping.
     *
     * @param noSleep causes the edt to stop the sleeping periods between 2 cycles
     */
    public void setNoSleep(boolean noSleep) {
<span class="nc" id="L1477">        this.noSleep = noSleep;</span>
<span class="nc" id="L1478">    }</span>

    /**
     * Displays the given Form on the screen.
     *
     * @param newForm the Form to Display
     */
    void setCurrent(final Form newForm, boolean reverse) {
<span class="pc bpc" id="L1486" title="1 of 2 branches missed.">        if (edt == null) {</span>
<span class="nc" id="L1487">            throw new IllegalStateException(&quot;Initialize must be invoked before setCurrent!&quot;);</span>
        }
<span class="fc" id="L1489">        Form current = impl.getCurrentForm();</span>


<span class="pc bpc" id="L1492" title="2 of 4 branches missed.">        if (autoFoldVKBOnFormSwitch &amp;&amp; !(newForm instanceof Dialog)) {</span>
<span class="fc" id="L1493">            setShowVirtualKeyboard(false);</span>
        }

<span class="fc bfc" id="L1496" title="All 2 branches covered.">        if (current == newForm) {</span>
<span class="fc" id="L1497">            current.revalidate();</span>
<span class="fc" id="L1498">            current.repaint();</span>
<span class="fc" id="L1499">            current.onShowCompletedImpl();</span>
<span class="fc" id="L1500">            return;</span>
        }

<span class="pc bpc" id="L1503" title="1 of 2 branches missed.">        if (impl.isEditingText()) {</span>
<span class="nc bnc" id="L1504" title="All 6 branches missed.">            switch (showDuringEdit) {</span>
                case SHOW_DURING_EDIT_ALLOW_DISCARD:
<span class="nc" id="L1506">                    break;</span>
                case SHOW_DURING_EDIT_ALLOW_SAVE:
<span class="nc" id="L1508">                    impl.saveTextEditingState();</span>
<span class="nc" id="L1509">                    break;</span>
                case SHOW_DURING_EDIT_EXCEPTION:
<span class="nc" id="L1511">                    throw new IllegalStateException(&quot;Show during edit&quot;);</span>
                case SHOW_DURING_EDIT_IGNORE:
<span class="nc" id="L1513">                    return;</span>
                case SHOW_DURING_EDIT_SET_AS_NEXT:
<span class="nc" id="L1515">                    impl.setCurrentForm(newForm);</span>
<span class="nc" id="L1516">                    return;</span>
            }
        }

<span class="pc bpc" id="L1520" title="1 of 2 branches missed.">        if (!isEdt()) {</span>
<span class="nc" id="L1521">            callSerially(new RunnableWrapper(newForm, null, reverse));</span>
<span class="nc" id="L1522">            return;</span>
        }

<span class="fc bfc" id="L1525" title="All 2 branches covered.">        if (current != null) {</span>
<span class="pc bpc" id="L1526" title="1 of 2 branches missed.">            if (current.isInitialized()) {</span>
<span class="fc" id="L1527">                current.deinitializeImpl();</span>
            } else {
<span class="nc" id="L1529">                Form fg = getCurrentUpcoming();</span>
<span class="nc bnc" id="L1530" title="All 2 branches missed.">                if (fg != current) {</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">                    if (fg.isInitialized()) {</span>
<span class="nc" id="L1532">                        fg.deinitializeImpl();</span>
                    }
                }
            }
        }
<span class="pc bpc" id="L1537" title="1 of 2 branches missed.">        if (!newForm.isInitialized()) {</span>
<span class="fc" id="L1538">            newForm.initComponentImpl();</span>
        }

<span class="pc bpc" id="L1541" title="2 of 4 branches missed.">        if (newForm.getWidth() != getDisplayWidth() || newForm.getHeight() != getDisplayHeight()) {</span>
<span class="nc" id="L1542">            newForm.setSize(new Dimension(getDisplayWidth(), getDisplayHeight()));</span>
<span class="nc" id="L1543">            newForm.setShouldCalcPreferredSize(true);</span>
<span class="nc" id="L1544">            newForm.layoutContainer();</span>
<span class="nc" id="L1545">            newForm.revalidate();</span>
        } else {
            // if shouldLayout is true
<span class="fc" id="L1548">            newForm.layoutContainer();</span>
<span class="fc" id="L1549">            newForm.revalidate();</span>

        }

<span class="fc" id="L1553">        boolean transitionExists = false;</span>
<span class="pc bpc" id="L1554" title="3 of 4 branches missed.">        if (animationQueue != null &amp;&amp; animationQueue.size() &gt; 0) {</span>
<span class="nc" id="L1555">            Object o = animationQueue.get(animationQueue.size() - 1);</span>
<span class="nc bnc" id="L1556" title="All 2 branches missed.">            if (o instanceof Transition) {</span>
<span class="nc" id="L1557">                current = (Form) ((Transition) o).getDestination();</span>
<span class="nc" id="L1558">                impl.setCurrentForm(current);</span>
            }
        }

<span class="fc bfc" id="L1562" title="All 2 branches covered.">        if (current != null) {</span>
            // make sure the fold menu occurs as expected then set the current
            // to the correct parent!
<span class="pc bpc" id="L1565" title="3 of 4 branches missed.">            if (current instanceof Dialog &amp;&amp; current.isMenu()) {</span>
<span class="nc" id="L1566">                Transition t = current.getTransitionOutAnimator();</span>
<span class="nc bnc" id="L1567" title="All 2 branches missed.">                if (t != null) {</span>
                    // go back to the parent form first
<span class="nc bnc" id="L1569" title="All 2 branches missed.">                    if (current.getPreviousForm() != null) {</span>
<span class="nc" id="L1570">                        initTransition(t.copy(false), current, current.getPreviousForm());</span>
                    }
                }
<span class="nc" id="L1573">                current = current.getPreviousForm();</span>
<span class="nc" id="L1574">                impl.setCurrentForm(current);</span>
            }

            // prevent the transition from occurring from a form into itself
<span class="pc bpc" id="L1578" title="1 of 2 branches missed.">            if (newForm != current) {</span>
<span class="pc bpc" id="L1579" title="3 of 6 branches missed.">                if ((current != null &amp;&amp; current.getTransitionOutAnimator() != null) || newForm.getTransitionInAnimator() != null) {</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">                    if (animationQueue == null) {</span>
<span class="nc" id="L1581">                        animationQueue = new ArrayList&lt;Animation&gt;();</span>
                    }
                    // prevent form transitions from breaking our dialog based
                    // transitions which are a bit sensitive
<span class="nc bnc" id="L1585" title="All 4 branches missed.">                    if (current != null &amp;&amp; (!(newForm instanceof Dialog))) {</span>
<span class="nc" id="L1586">                        Transition t = current.getTransitionOutAnimator();</span>
<span class="nc bnc" id="L1587" title="All 4 branches missed.">                        if (current != null &amp;&amp; t != null) {</span>
<span class="nc" id="L1588">                            transitionExists = initTransition(t.copy(reverse), current, newForm);</span>
                        }
                    }
<span class="nc bnc" id="L1591" title="All 4 branches missed.">                    if (current != null &amp;&amp; !(current instanceof Dialog)) {</span>
<span class="nc" id="L1592">                        Transition t = newForm.getTransitionInAnimator();</span>
<span class="nc bnc" id="L1593" title="All 2 branches missed.">                        if (t != null) {</span>
<span class="nc" id="L1594">                            transitionExists = initTransition(t.copy(reverse), current, newForm);</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L1600">        synchronized (lock) {</span>
<span class="fc" id="L1601">            lock.notify();</span>
<span class="fc" id="L1602">        }</span>

<span class="pc bpc" id="L1604" title="1 of 2 branches missed.">        if (!transitionExists) {</span>
<span class="pc bpc" id="L1605" title="3 of 4 branches missed.">            if (animationQueue == null || animationQueue.size() == 0) {</span>
<span class="fc" id="L1606">                setCurrentForm(newForm);</span>
            } else {
                // we need to add an empty transition to &quot;serialize&quot; this
                // screen change...
<span class="nc" id="L1610">                Transition t = CommonTransitions.createEmpty();</span>
<span class="nc" id="L1611">                initTransition(t, current, newForm);</span>
            }
        }
<span class="fc" id="L1614">    }</span>

    /**
     * Initialize the transition and add it to the queue
     */
    private boolean initTransition(Transition transition, Form source, Form dest) {
        try {
<span class="nc" id="L1621">            dest.setVisible(true);</span>
<span class="nc" id="L1622">            transition.init(source, dest);</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">            if (source != null) {</span>
<span class="nc" id="L1624">                source.setLightweightMode(true);</span>
            }
<span class="nc bnc" id="L1626" title="All 2 branches missed.">            if (dest != null) {</span>
<span class="nc" id="L1627">                dest.setLightweightMode(true);</span>
            }

            // if a native transition implementation exists then substitute it into place
<span class="nc" id="L1631">            transition = impl.getNativeTransition(transition);</span>
<span class="nc" id="L1632">            animationQueue.add(transition);</span>

<span class="nc bnc" id="L1634" title="All 2 branches missed.">            if (animationQueue.size() == 1) {</span>
<span class="nc" id="L1635">                transition.initTransition();</span>
            }
<span class="nc" id="L1637">        } catch (Throwable e) {</span>
<span class="nc" id="L1638">            Log.e(e);</span>
<span class="nc" id="L1639">            transition.cleanup();</span>
<span class="nc" id="L1640">            animationQueue.remove(transition);</span>
<span class="nc" id="L1641">            return false;</span>
<span class="nc" id="L1642">        }</span>
<span class="nc" id="L1643">        return true;</span>
    }

    void setCurrentForm(Form newForm) {
<span class="fc" id="L1647">        boolean forceShow = false;</span>
<span class="fc" id="L1648">        Form current = impl.getCurrentForm();</span>
<span class="fc bfc" id="L1649" title="All 2 branches covered.">        if (current != null) {</span>
<span class="fc" id="L1650">            current.setVisible(false);</span>
        } else {
<span class="fc" id="L1652">            forceShow = true;</span>
        }
<span class="fc" id="L1654">        keyRepeatCharged = false;</span>
<span class="fc" id="L1655">        longPressCharged = false;</span>
<span class="fc" id="L1656">        longPointerCharged = false;</span>
<span class="fc" id="L1657">        current = newForm;</span>
<span class="fc" id="L1658">        impl.setCurrentForm(current);</span>
<span class="fc" id="L1659">        current.setVisible(true);</span>
<span class="pc bpc" id="L1660" title="3 of 6 branches missed.">        if (forceShow || !allowMinimizing || inNativeUI) {</span>
<span class="fc" id="L1661">            impl.confirmControlView();</span>
        }
<span class="fc" id="L1663">        int w = current.getWidth();</span>
<span class="fc" id="L1664">        int h = current.getHeight();</span>
<span class="pc bpc" id="L1665" title="3 of 6 branches missed.">        if (isEdt() &amp;&amp; (w != impl.getDisplayWidth() || h != impl.getDisplayHeight())) {</span>
<span class="nc" id="L1666">            current.sizeChangedInternal(impl.getDisplayWidth(), impl.getDisplayHeight());</span>
        } else {
<span class="fc" id="L1668">            repaint(current);</span>
        }
<span class="fc" id="L1670">        lastKeyPressed = 0;</span>
<span class="fc" id="L1671">        previousKeyPressed = 0;</span>
<span class="fc" id="L1672">        newForm.onShowCompletedImpl();</span>
<span class="fc" id="L1673">    }</span>

    /**
     * Indicates whether a delay should exist between calls to flush graphics during
     * transition. In some devices flushGraphics is asynchronious causing it to be
     * very slow with our background thread. The solution is to add a short wait allowing
     * the implementation time to paint the screen. This value is set automatically by default
     * but can be overriden for some devices.
     *
     * @param transitionD -1 for no delay otherwise delay in milliseconds
     */
    public void setTransitionYield(int transitionD) {
<span class="nc" id="L1685">        transitionDelay = transitionD;</span>
<span class="nc" id="L1686">    }</span>

    /**
     * Fires the native in place text editing logic, normally you wouldn't invoke this API directly and instead
     * use an API like {@link com.codename1.ui.TextArea#startEditingAsync()}, {@link com.codename1.ui.TextArea#startEditing()}
     * or {@link com.codename1.ui.Form#setEditOnShow(com.codename1.ui.TextArea)}.
     *
     * @param cmp        the {@link TextArea} component
     * @param maxSize    the maximum size from the text area
     * @param constraint the constraints of the text area
     * @param text       the string to edit
     */
    public void editString(Component cmp, int maxSize, int constraint, String text) {
<span class="nc" id="L1699">        editString(cmp, maxSize, constraint, text, 0);</span>
<span class="nc" id="L1700">    }</span>

    /**
     * Fires the native in place text editing logic, normally you wouldn't invoke this API directly and instead
     * use an API like {@link com.codename1.ui.TextArea#startEditingAsync()}, {@link com.codename1.ui.TextArea#startEditing()}
     * or {@link com.codename1.ui.Form#setEditOnShow(com.codename1.ui.TextArea)}.
     *
     * @param cmp               the {@link TextArea} component
     * @param maxSize           the maximum size from the text area
     * @param constraint        the constraints of the text area
     * @param text              the string to edit
     * @param initiatingKeycode the keycode used to initiate the edit.
     */
    public void editString(Component cmp, int maxSize, int constraint, String text, int initiatingKeycode) {
<span class="nc bnc" id="L1714" title="All 2 branches missed.">        if (isTextEditing(cmp)) {</span>
<span class="nc" id="L1715">            return;</span>
        }
<span class="nc" id="L1717">        cmp.requestFocus();</span>
<span class="nc bnc" id="L1718" title="All 2 branches missed.">        if (cmp instanceof TextArea) {</span>
<span class="nc" id="L1719">            ((TextArea) cmp).setSuppressActionEvent(false);</span>
        }
<span class="nc" id="L1721">        Form f = cmp.getComponentForm();</span>

        // this can happen in the spinner in the simulator where the key press should in theory start native
        // edit
<span class="nc bnc" id="L1725" title="All 2 branches missed.">        if (f == null) {</span>
<span class="nc" id="L1726">            return;</span>
        }
<span class="nc" id="L1728">        Component.setDisableSmoothScrolling(true);</span>
<span class="nc" id="L1729">        f.scrollComponentToVisible(cmp);</span>
<span class="nc" id="L1730">        Component.setDisableSmoothScrolling(false);</span>
<span class="nc" id="L1731">        keyRepeatCharged = false;</span>
<span class="nc" id="L1732">        longPressCharged = false;</span>
<span class="nc" id="L1733">        lastKeyPressed = 0;</span>
<span class="nc" id="L1734">        previousKeyPressed = 0;</span>
<span class="nc" id="L1735">        impl.editStringImpl(cmp, maxSize, constraint, text, initiatingKeycode);</span>
<span class="nc" id="L1736">    }</span>

    /**
     * Allows us to stop editString on the given text component
     *
     * @param cmp the text field/text area component
     */
    public void stopEditing(Component cmp) {
<span class="nc bnc" id="L1744" title="All 2 branches missed.">        if (isTextEditing(cmp)) {</span>
<span class="nc" id="L1745">            impl.stopTextEditing();</span>
        }
<span class="nc" id="L1747">    }</span>

    /**
     * Allows us to stop editString on the given text component or Form.
     * If {@literal cmp} is a {@link Form}, it will stop editing in any active
     * component on the form, and close the keyboard if it is opened.
     *
     * @param cmp      the text field/text area component
     * @param onFinish invoked when editing stopped
     */
    public void stopEditing(Component cmp, Runnable onFinish) {
<span class="nc bnc" id="L1758" title="All 2 branches missed.">        if (isTextEditing(cmp)) {</span>
<span class="nc" id="L1759">            impl.stopTextEditing(onFinish);</span>
        } else {
<span class="nc bnc" id="L1761" title="All 2 branches missed.">            if (onFinish != null) {</span>
<span class="nc" id="L1762">                onFinish.run();</span>
            }
        }
<span class="nc" id="L1765">    }</span>

    boolean isTextEditing(Component c) {
<span class="pc bpc" id="L1768" title="3 of 4 branches missed.">        if (c instanceof Form &amp;&amp; c == getCurrent()) {</span>
<span class="nc" id="L1769">            return impl.isEditingText();</span>
        }

<span class="fc" id="L1772">        return impl.isEditingText(c);</span>
    }

    boolean isNativeEditorVisible(Component c) {
<span class="fc" id="L1776">        return impl.isNativeEditorVisible(c);</span>
    }

    /**
     * Minimizes the current application if minimization is supported by the platform (may fail).
     * Returns false if minimization failed.
     *
     * @return false if minimization failed true if it succeeded or seems to be successful
     */
    public boolean minimizeApplication() {
<span class="nc" id="L1786">        return getImplementation().minimizeApplication();</span>
    }

    /**
     * Indicates whether an application is minimized
     *
     * @return true if the application is minimized
     */
    public boolean isMinimized() {
<span class="fc" id="L1795">        return getImplementation().isMinimized();</span>
    }

    /**
     * Restore the minimized application if minimization is supported by the platform
     */
    public void restoreMinimizedApplication() {
<span class="nc" id="L1802">        getImplementation().restoreMinimizedApplication();</span>
<span class="nc" id="L1803">    }</span>

    private void addSingleArgumentEvent(int type, int code) {
<span class="nc" id="L1806">        synchronized (lock) {</span>
<span class="nc bnc" id="L1807" title="All 2 branches missed.">            if (this.dropEvents) {</span>
<span class="nc" id="L1808">                return;</span>
            }
<span class="nc" id="L1810">            inputEventStack[inputEventStackPointer] = type;</span>
<span class="nc" id="L1811">            inputEventStackPointer++;</span>
<span class="nc" id="L1812">            inputEventStack[inputEventStackPointer] = code;</span>
<span class="nc" id="L1813">            inputEventStackPointer++;</span>
<span class="nc" id="L1814">            lock.notify();</span>
<span class="nc" id="L1815">        }</span>
<span class="nc" id="L1816">    }</span>

    /**
     * Checks if the control key is currently down.  Only relevant for desktop ports.
     *
     * @return
     */
    public boolean isControlKeyDown() {
<span class="nc" id="L1824">        return impl.isControlKeyDown();</span>
    }

    /**
     * Checks if the meta key is currently down.  Only relevant for desktop ports.
     *
     * @return
     */
    public boolean isMetaKeyDown() {
<span class="nc" id="L1833">        return impl.isMetaKeyDown();</span>
    }

    /**
     * Checks if the alt key is currently down.  Only relevant for desktop ports.
     *
     * @return
     */
    public boolean isAltKeyDown() {
<span class="nc" id="L1842">        return impl.isAltKeyDown();</span>
    }

    /**
     * Checks if the altgraph key is currently down.  Only relevant for desktop ports.
     *
     * @return
     */
    public boolean isAltGraphKeyDown() {
<span class="nc" id="L1851">        return impl.isAltGraphKeyDown();</span>
    }

    /**
     * Checks if the last mouse press was a right click.
     *
     * @return True if the last mouse press was a right click.
     * @since 7.0
     */
    public boolean isRightMouseButtonDown() {
<span class="nc" id="L1861">        return impl.isRightMouseButtonDown();</span>
    }

    /**
     * Checks if shift key is currently down.  Only relevant for desktop ports.
     *
     * @return
     */
    public boolean isShiftKeyDown() {
<span class="nc" id="L1870">        return impl.isShiftKeyDown();</span>
    }

    /**
     * Pushes a key press event with the given keycode into Codename One
     *
     * @param keyCode keycode of the key event
     */
    public void keyPressed(final int keyCode) {
<span class="nc bnc" id="L1879" title="All 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L1880">            return;</span>
        }
<span class="nc" id="L1882">        addSingleArgumentEvent(KEY_PRESSED, keyCode);</span>

<span class="nc bnc" id="L1884" title="All 8 branches missed.">        lastInteractionWasKeypad = lastInteractionWasKeypad || (keyCode != MenuBar.leftSK &amp;&amp; keyCode != MenuBar.clearSK &amp;&amp; keyCode != MenuBar.backSK);</span>

        // this solves a Sony Ericsson bug where on slider open/close someone &quot;brilliant&quot; chose
        // to send a keyPress with a -43/-44 keycode... Without ever sending a key release!
<span class="nc bnc" id="L1888" title="All 6 branches missed.">        keyRepeatCharged = (keyCode &gt;= 0 || getGameAction(keyCode) &gt; 0) || keyCode == impl.getClearKeyCode();</span>
<span class="nc" id="L1889">        longPressCharged = keyRepeatCharged;</span>
<span class="nc" id="L1890">        longKeyPressTime = System.currentTimeMillis();</span>
<span class="nc" id="L1891">        keyRepeatValue = keyCode;</span>
<span class="nc" id="L1892">        nextKeyRepeatEvent = System.currentTimeMillis() + keyRepeatInitialIntervalTime;</span>
<span class="nc" id="L1893">        previousKeyPressed = lastKeyPressed;</span>
<span class="nc" id="L1894">        lastKeyPressed = keyCode;</span>
<span class="nc" id="L1895">    }</span>

    /**
     * Pushes a key release event with the given keycode into Codename One
     *
     * @param keyCode keycode of the key event
     */
    public void keyReleased(final int keyCode) {
<span class="nc" id="L1903">        keyRepeatCharged = false;</span>
<span class="nc" id="L1904">        longPressCharged = false;</span>
<span class="nc bnc" id="L1905" title="All 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L1906">            return;</span>
        }
<span class="nc bnc" id="L1908" title="All 2 branches missed.">        if (!multiKeyMode) {</span>
            // this can happen when traversing from the native form to the current form
            // caused by a keypress
            // We need the previous key press for Codename One issue 108 which can occur when typing into
            // text field rapidly and pressing two buttons at once. Originally I had a patch
            // here specifically to the native edit but that patch doesn't work properly for
            // all native phone bugs (e.g. incoming phone call rejected and the key release is
            // sent to the java application).
<span class="nc bnc" id="L1916" title="All 2 branches missed.">            if (keyCode != lastKeyPressed) {</span>
<span class="nc bnc" id="L1917" title="All 2 branches missed.">                if (keyCode != previousKeyPressed) {</span>
<span class="nc" id="L1918">                    return;</span>
                } else {
<span class="nc" id="L1920">                    previousKeyPressed = 0;</span>
                }
            } else {
<span class="nc" id="L1923">                lastKeyPressed = 0;</span>
            }
        }
<span class="nc" id="L1926">        addSingleArgumentEvent(KEY_RELEASED, keyCode);</span>
<span class="nc" id="L1927">    }</span>

    void keyRepeatedInternal(final int keyCode) {
<span class="nc" id="L1930">    }</span>

    private void addPointerEvent(int type, int x, int y) {
<span class="nc" id="L1933">        synchronized (lock) {</span>
<span class="nc bnc" id="L1934" title="All 2 branches missed.">            if (this.dropEvents) {</span>
<span class="nc" id="L1935">                return;</span>
            }
<span class="nc" id="L1937">            inputEventStack[inputEventStackPointer] = type;</span>
<span class="nc" id="L1938">            inputEventStackPointer++;</span>
<span class="nc" id="L1939">            inputEventStack[inputEventStackPointer] = x;</span>
<span class="nc" id="L1940">            inputEventStackPointer++;</span>
<span class="nc" id="L1941">            inputEventStack[inputEventStackPointer] = y;</span>
<span class="nc" id="L1942">            inputEventStackPointer++;</span>
<span class="nc" id="L1943">            lock.notify();</span>
<span class="nc" id="L1944">        }</span>
<span class="nc" id="L1945">    }</span>

    private void addPointerEvent(int type, int[] x, int[] y) {
<span class="nc" id="L1948">        synchronized (lock) {</span>
<span class="nc bnc" id="L1949" title="All 2 branches missed.">            if (this.dropEvents) {</span>
<span class="nc" id="L1950">                return;</span>
            }
<span class="nc" id="L1952">            inputEventStack[inputEventStackPointer] = type;</span>
<span class="nc" id="L1953">            inputEventStackPointer++;</span>
<span class="nc" id="L1954">            inputEventStack[inputEventStackPointer] = x.length;</span>
<span class="nc" id="L1955">            inputEventStackPointer++;</span>
<span class="nc bnc" id="L1956" title="All 2 branches missed.">            for (int iter = 0; iter &lt; x.length; iter++) {</span>
<span class="nc" id="L1957">                inputEventStack[inputEventStackPointer] = x[iter];</span>
<span class="nc" id="L1958">                inputEventStackPointer++;</span>
            }
<span class="nc" id="L1960">            inputEventStack[inputEventStackPointer] = y.length;</span>
<span class="nc" id="L1961">            inputEventStackPointer++;</span>
<span class="nc bnc" id="L1962" title="All 2 branches missed.">            for (int iter = 0; iter &lt; y.length; iter++) {</span>
<span class="nc" id="L1963">                inputEventStack[inputEventStackPointer] = y[iter];</span>
<span class="nc" id="L1964">                inputEventStackPointer++;</span>
            }
<span class="nc" id="L1966">            lock.notify();</span>
<span class="nc" id="L1967">        }</span>
<span class="nc" id="L1968">    }</span>

    private void addPointerDragEventWithTimestamp(int x, int y) {
<span class="nc" id="L1971">        synchronized (lock) {</span>
<span class="nc bnc" id="L1972" title="All 2 branches missed.">            if (this.dropEvents) {</span>
<span class="nc" id="L1973">                return;</span>
            }
            try {
<span class="nc bnc" id="L1976" title="All 2 branches missed.">                if (lastDragOffset &gt; -1) {</span>
<span class="nc" id="L1977">                    inputEventStack[lastDragOffset] = x;</span>
<span class="nc" id="L1978">                    inputEventStack[lastDragOffset + 1] = y;</span>
<span class="nc" id="L1979">                    inputEventStack[lastDragOffset + 2] = (int) (System.currentTimeMillis() - displayInitTime);</span>
                } else {
<span class="nc" id="L1981">                    inputEventStack[inputEventStackPointer] = POINTER_DRAGGED;</span>
<span class="nc" id="L1982">                    inputEventStackPointer++;</span>
<span class="nc" id="L1983">                    lastDragOffset = inputEventStackPointer;</span>
<span class="nc" id="L1984">                    inputEventStack[inputEventStackPointer] = x;</span>
<span class="nc" id="L1985">                    inputEventStackPointer++;</span>
<span class="nc" id="L1986">                    inputEventStack[inputEventStackPointer] = y;</span>
<span class="nc" id="L1987">                    inputEventStackPointer++;</span>
<span class="nc" id="L1988">                    inputEventStack[inputEventStackPointer] = (int) (System.currentTimeMillis() - displayInitTime);</span>
<span class="nc" id="L1989">                    inputEventStackPointer++;</span>
                }
<span class="nc" id="L1991">            } catch (ArrayIndexOutOfBoundsException err) {</span>
<span class="nc" id="L1992">                Log.p(&quot;EDT performance is very slow triggering this exception!&quot;);</span>
<span class="nc" id="L1993">                Log.e(err);</span>
<span class="nc" id="L1994">            }</span>
<span class="nc" id="L1995">            lock.notify();</span>
<span class="nc" id="L1996">        }</span>
<span class="nc" id="L1997">    }</span>

    private void addPointerEventWithTimestamp(int type, int x, int y) {
<span class="nc" id="L2000">        synchronized (lock) {</span>
<span class="nc bnc" id="L2001" title="All 2 branches missed.">            if (this.dropEvents) {</span>
<span class="nc" id="L2002">                return;</span>
            }
            try {
<span class="nc" id="L2005">                inputEventStack[inputEventStackPointer] = type;</span>
<span class="nc" id="L2006">                inputEventStackPointer++;</span>
<span class="nc" id="L2007">                inputEventStack[inputEventStackPointer] = x;</span>
<span class="nc" id="L2008">                inputEventStackPointer++;</span>
<span class="nc" id="L2009">                inputEventStack[inputEventStackPointer] = y;</span>
<span class="nc" id="L2010">                inputEventStackPointer++;</span>
<span class="nc" id="L2011">                inputEventStack[inputEventStackPointer] = (int) (System.currentTimeMillis() - displayInitTime);</span>
<span class="nc" id="L2012">                inputEventStackPointer++;</span>
<span class="nc" id="L2013">            } catch (ArrayIndexOutOfBoundsException err) {</span>
<span class="nc" id="L2014">                Log.p(&quot;EDT performance is very slow triggering this exception!&quot;);</span>
<span class="nc" id="L2015">                Log.e(err);</span>
<span class="nc" id="L2016">            }</span>
<span class="nc" id="L2017">            lock.notify();</span>
<span class="nc" id="L2018">        }</span>
<span class="nc" id="L2019">    }</span>

    /**
     * Pushes a pointer drag event with the given coordinates into Codename One
     *
     * @param x the x position of the pointer
     * @param y the y position of the pointer
     */
    public void pointerDragged(final int[] x, final int[] y) {
<span class="nc bnc" id="L2028" title="All 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L2029">            return;</span>
        }
<span class="nc" id="L2031">        longPointerCharged = false;</span>
<span class="nc bnc" id="L2032" title="All 2 branches missed.">        if (x.length == 1) {</span>
<span class="nc" id="L2033">            addPointerDragEventWithTimestamp(x[0], y[0]);</span>
        } else {
<span class="nc" id="L2035">            addPointerEvent(POINTER_DRAGGED_MULTI, x, y);</span>
        }
<span class="nc" id="L2037">    }</span>

    /**
     * Pushes a pointer hover event with the given coordinates into Codename One
     *
     * @param x the x position of the pointer
     * @param y the y position of the pointer
     */
    public void pointerHover(final int[] x, final int[] y) {
<span class="nc bnc" id="L2046" title="All 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L2047">            return;</span>
        }
<span class="nc bnc" id="L2049" title="All 2 branches missed.">        if (x.length == 1) {</span>
<span class="nc" id="L2050">            addPointerEventWithTimestamp(POINTER_HOVER, x[0], y[0]);</span>
        } else {
<span class="nc" id="L2052">            addPointerEvent(POINTER_HOVER, x, y);</span>
        }
<span class="nc" id="L2054">    }</span>

    /**
     * Pushes a pointer hover release event with the given coordinates into Codename One
     *
     * @param x the x position of the pointer
     * @param y the y position of the pointer
     */
    public void pointerHoverPressed(final int[] x, final int[] y) {
<span class="nc bnc" id="L2063" title="All 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L2064">            return;</span>
        }
<span class="nc" id="L2066">        addPointerEvent(POINTER_HOVER_PRESSED, x[0], y[0]);</span>
<span class="nc" id="L2067">    }</span>

    /**
     * Pushes a pointer hover release event with the given coordinates into Codename One
     *
     * @param x the x position of the pointer
     * @param y the y position of the pointer
     */
    public void pointerHoverReleased(final int[] x, final int[] y) {
<span class="nc bnc" id="L2076" title="All 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L2077">            return;</span>
        }
<span class="nc" id="L2079">        addPointerEvent(POINTER_HOVER_RELEASED, x[0], y[0]);</span>
<span class="nc" id="L2080">    }</span>

    /**
     * Pushes a pointer press event with the given coordinates into Codename One
     *
     * @param x the x position of the pointer
     * @param y the y position of the pointer
     */
    public void pointerPressed(final int[] x, final int[] y) {
<span class="nc bnc" id="L2089" title="All 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L2090">            return;</span>
        }

<span class="nc" id="L2093">        lastInteractionWasKeypad = false;</span>
<span class="nc" id="L2094">        longPointerCharged = true;</span>
<span class="nc" id="L2095">        longKeyPressTime = System.currentTimeMillis();</span>
<span class="nc" id="L2096">        pointerX = x[0];</span>
<span class="nc" id="L2097">        pointerY = y[0];</span>
<span class="nc bnc" id="L2098" title="All 2 branches missed.">        if (x.length == 1) {</span>
<span class="nc" id="L2099">            addPointerEvent(POINTER_PRESSED, x[0], y[0]);</span>
        } else {
<span class="nc" id="L2101">            addPointerEvent(POINTER_PRESSED_MULTI, x, y);</span>
        }
<span class="nc" id="L2103">    }</span>

    /**
     * Pushes a pointer release event with the given coordinates into Codename One
     *
     * @param x the x position of the pointer
     * @param y the y position of the pointer
     */
    public void pointerReleased(final int[] x, final int[] y) {
<span class="nc" id="L2112">        longPointerCharged = false;</span>
<span class="nc bnc" id="L2113" title="All 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L2114">            return;</span>
        }
<span class="nc bnc" id="L2116" title="All 2 branches missed.">        if (x.length == 1) {</span>
<span class="nc" id="L2117">            addPointerEvent(POINTER_RELEASED, x[0], y[0]);</span>
        } else {
<span class="nc" id="L2119">            addPointerEvent(POINTER_RELEASED_MULTI, x, y);</span>
        }
<span class="nc" id="L2121">    }</span>

    private void addSizeChangeEvent(int type, int w, int h) {
<span class="nc" id="L2124">        synchronized (lock) {</span>
<span class="nc" id="L2125">            inputEventStack[inputEventStackPointer] = type;</span>
<span class="nc" id="L2126">            inputEventStackPointer++;</span>
<span class="nc" id="L2127">            inputEventStack[inputEventStackPointer] = w;</span>
<span class="nc" id="L2128">            inputEventStackPointer++;</span>
<span class="nc" id="L2129">            inputEventStack[inputEventStackPointer] = h;</span>
<span class="nc" id="L2130">            inputEventStackPointer++;</span>
<span class="nc" id="L2131">            lock.notify();</span>
<span class="nc" id="L2132">        }</span>
<span class="nc" id="L2133">    }</span>

    /**
     * Notifies Codename One of display size changes, this method is invoked by the implementation
     * class and is for internal use
     *
     * @param w the width of the drawing surface
     * @param h the height of the drawing surface
     */
    public void sizeChanged(int w, int h) {
<span class="nc" id="L2143">        Form current = impl.getCurrentForm();</span>
<span class="nc bnc" id="L2144" title="All 2 branches missed.">        if (current == null) {</span>
<span class="nc" id="L2145">            return;</span>
        }
<span class="nc bnc" id="L2147" title="All 4 branches missed.">        if (w == current.getWidth() &amp;&amp; h == current.getHeight()) {</span>
            // a workaround for a race condition on pixel 2 where size change events can happen really quickly
<span class="nc bnc" id="L2149" title="All 4 branches missed.">            if (lastSizeChangeEventWH == -1 || lastSizeChangeEventWH == w + h) {</span>
<span class="nc" id="L2150">                return;</span>
            }
        }

<span class="nc" id="L2154">        lastSizeChangeEventWH = w + h;</span>
<span class="nc" id="L2155">        addSizeChangeEvent(SIZE_CHANGED, w, h);</span>
<span class="nc" id="L2156">    }</span>

    private void addNotifyEvent(int type) {
<span class="nc" id="L2159">        synchronized (lock) {</span>
<span class="nc" id="L2160">            inputEventStack[inputEventStackPointer] = type;</span>
<span class="nc" id="L2161">            inputEventStackPointer++;</span>
<span class="nc" id="L2162">            lock.notify();</span>
<span class="nc" id="L2163">        }</span>
<span class="nc" id="L2164">    }</span>

    /**
     * Broadcasts hide notify into Codename One, this method is invoked by the Codename One implementation
     * to notify Codename One of hideNotify events
     */
    public void hideNotify() {
<span class="nc" id="L2171">        keyRepeatCharged = false;</span>
<span class="nc" id="L2172">        longPressCharged = false;</span>
<span class="nc" id="L2173">        longPointerCharged = false;</span>
<span class="nc" id="L2174">        pointerPressedAndNotReleasedOrDragged = false;</span>
<span class="nc" id="L2175">        addNotifyEvent(HIDE_NOTIFY);</span>
<span class="nc" id="L2176">    }</span>

    /**
     * Broadcasts show notify into Codename One, this method is invoked by the Codename One implementation
     * to notify Codename One of showNotify events
     */
    public void showNotify() {
<span class="nc" id="L2183">        addNotifyEvent(SHOW_NOTIFY);</span>
<span class="nc" id="L2184">    }</span>

    /**
     * Used by the flush functionality which doesn't care much about component
     * animations
     */
    boolean shouldEDTSleepNoFormAnimation() {
        boolean b;
<span class="nc" id="L2192">        synchronized (lock) {</span>
<span class="nc bnc" id="L2193" title="All 2 branches missed.">            b = inputEventStackPointer == 0 &amp;&amp;</span>
<span class="nc bnc" id="L2194" title="All 6 branches missed.">                    hasNoSerialCallsPending() &amp;&amp;</span>
                    (!keyRepeatCharged || !longPressCharged);
<span class="nc" id="L2196">        }</span>
<span class="nc" id="L2197">        return b;</span>
    }

    private void updateDragSpeedStatus(int x, int y, int timestamp) {
        //save dragging input to calculate the dragging speed later
<span class="nc" id="L2202">        dragPathX[dragPathOffset] = x;</span>
<span class="nc" id="L2203">        dragPathY[dragPathOffset] = y;</span>
<span class="nc" id="L2204">        dragPathTime[dragPathOffset] = displayInitTime + (long) timestamp;</span>
<span class="nc bnc" id="L2205" title="All 2 branches missed.">        if (dragPathLength &lt; PATHLENGTH) {</span>
<span class="nc" id="L2206">            dragPathLength++;</span>
        }
<span class="nc" id="L2208">        dragPathOffset++;</span>
<span class="nc bnc" id="L2209" title="All 2 branches missed.">        if (dragPathOffset &gt;= PATHLENGTH) {</span>
<span class="nc" id="L2210">            dragPathOffset = 0;</span>
        }
<span class="nc" id="L2212">    }</span>

    boolean isRecursivePointerRelease() {
<span class="nc" id="L2215">        return recursivePointerReleaseB;</span>
    }

    private int[] readArrayStackArgument(int offset) {
<span class="nc" id="L2219">        int[] a = new int[inputEventStackTmp[offset]];</span>
<span class="nc" id="L2220">        offset++;</span>
<span class="nc" id="L2221">        int alen = a.length;</span>
<span class="nc" id="L2222">        System.arraycopy(inputEventStackTmp, offset + 0, a, 0, alen);</span>
<span class="nc" id="L2223">        return a;</span>
    }

    /**
     * Invoked on the EDT to propagate the event
     */
    private int handleEvent(int offset, int[] inputEventStackTmp) {
<span class="nc" id="L2230">        Form f = getCurrentUpcomingForm(true);</span>

        // might happen when returning from a deinitialized version of Codename One
<span class="nc bnc" id="L2233" title="All 2 branches missed.">        if (f == null) {</span>
<span class="nc" id="L2234">            return offset;</span>
        }

        // no need to synchronize since we are reading only and modifying the stack frame offset
<span class="nc" id="L2238">        int type = inputEventStackTmp[offset];</span>
<span class="nc" id="L2239">        offset++;</span>

<span class="nc bnc" id="L2241" title="All 15 branches missed.">        switch (type) {</span>
            case KEY_PRESSED:
<span class="nc" id="L2243">                f.keyPressed(inputEventStackTmp[offset]);</span>
<span class="nc" id="L2244">                offset++;</span>
<span class="nc" id="L2245">                eventForm = f;</span>
<span class="nc" id="L2246">                break;</span>
            case KEY_RELEASED:
                // pointer release can cycle into invoke and block which will cause this method
                // to recurse if a pointer will be released while we are in an invoke and block state
                // this is the case in http://code.google.com/p/codenameone/issues/detail?id=265
<span class="nc" id="L2251">                Form xf = eventForm;</span>
<span class="nc" id="L2252">                eventForm = null;</span>

                //make sure the released event is sent to the same Form who got a
                //pressed event
<span class="nc bnc" id="L2256" title="All 4 branches missed.">                if (xf == f || multiKeyMode) {</span>
<span class="nc" id="L2257">                    f.keyReleased(inputEventStackTmp[offset]);</span>
<span class="nc" id="L2258">                    offset++;</span>
                }
                break;
            case POINTER_PRESSED:
<span class="nc bnc" id="L2262" title="All 2 branches missed.">                if (recursivePointerReleaseA) {</span>
<span class="nc" id="L2263">                    recursivePointerReleaseB = true;</span>
                }
<span class="nc" id="L2265">                dragOccured = false;</span>
<span class="nc" id="L2266">                dragPathLength = 0;</span>
<span class="nc" id="L2267">                pointerPressedAndNotReleasedOrDragged = true;</span>
<span class="nc" id="L2268">                xArray1[0] = inputEventStackTmp[offset];</span>
<span class="nc" id="L2269">                offset++;</span>
<span class="nc" id="L2270">                yArray1[0] = inputEventStackTmp[offset];</span>
<span class="nc" id="L2271">                offset++;</span>
<span class="nc" id="L2272">                f.pointerPressed(xArray1, yArray1);</span>
<span class="nc" id="L2273">                eventForm = f;</span>
<span class="nc" id="L2274">                break;</span>
            case POINTER_PRESSED_MULTI: {
<span class="nc bnc" id="L2276" title="All 2 branches missed.">                if (recursivePointerReleaseA) {</span>
<span class="nc" id="L2277">                    recursivePointerReleaseB = true;</span>
                }
<span class="nc" id="L2279">                dragOccured = false;</span>
<span class="nc" id="L2280">                dragPathLength = 0;</span>
<span class="nc" id="L2281">                pointerPressedAndNotReleasedOrDragged = true;</span>
<span class="nc" id="L2282">                int[] array1 = readArrayStackArgument(offset);</span>
<span class="nc" id="L2283">                offset += array1.length + 1;</span>
<span class="nc" id="L2284">                int[] array2 = readArrayStackArgument(offset);</span>
<span class="nc" id="L2285">                offset += array2.length + 1;</span>
<span class="nc" id="L2286">                f.pointerPressed(array1, array2);</span>
<span class="nc" id="L2287">                eventForm = f;</span>
<span class="nc" id="L2288">                break;</span>
            }
            case POINTER_RELEASED:
<span class="nc" id="L2291">                recursivePointerReleaseA = true;</span>
<span class="nc" id="L2292">                pointerPressedAndNotReleasedOrDragged = false;</span>

                // pointer release can cycle into invoke and block which will cause this method
                // to recurse if a pointer will be released while we are in an invoke and block state
                // this is the case in http://code.google.com/p/codenameone/issues/detail?id=265
<span class="nc" id="L2297">                Form x = eventForm;</span>
<span class="nc" id="L2298">                eventForm = null;</span>

                // make sure the released event is sent to the same Form that got a
                // pressed event
<span class="nc bnc" id="L2302" title="All 4 branches missed.">                if (x == f || f.shouldSendPointerReleaseToOtherForm()) {</span>
<span class="nc" id="L2303">                    xArray1[0] = inputEventStackTmp[offset];</span>
<span class="nc" id="L2304">                    offset++;</span>
<span class="nc" id="L2305">                    yArray1[0] = inputEventStackTmp[offset];</span>
<span class="nc" id="L2306">                    offset++;</span>
<span class="nc" id="L2307">                    f.pointerReleased(xArray1, yArray1);</span>
                }
<span class="nc" id="L2309">                recursivePointerReleaseA = false;</span>
<span class="nc" id="L2310">                recursivePointerReleaseB = false;</span>
<span class="nc" id="L2311">                break;</span>
            case POINTER_RELEASED_MULTI:
<span class="nc" id="L2313">                recursivePointerReleaseA = true;</span>
<span class="nc" id="L2314">                pointerPressedAndNotReleasedOrDragged = false;</span>

                // pointer release can cycle into invoke and block which will cause this method
                // to recurse if a pointer will be released while we are in an invoke and block state
                // this is the case in http://code.google.com/p/codenameone/issues/detail?id=265
<span class="nc" id="L2319">                Form xy = eventForm;</span>
<span class="nc" id="L2320">                eventForm = null;</span>

                // make sure the released event is sent to the same Form that got a
                // pressed event
<span class="nc bnc" id="L2324" title="All 6 branches missed.">                if (xy == f || (f != null &amp;&amp; f.shouldSendPointerReleaseToOtherForm())) {</span>
<span class="nc" id="L2325">                    int[] array1 = readArrayStackArgument(offset);</span>
<span class="nc" id="L2326">                    offset += array1.length + 1;</span>
<span class="nc" id="L2327">                    int[] array2 = readArrayStackArgument(offset);</span>
<span class="nc" id="L2328">                    offset += array2.length + 1;</span>
<span class="nc" id="L2329">                    f.pointerReleased(array1, array1);</span>
                }
<span class="nc" id="L2331">                recursivePointerReleaseA = false;</span>
<span class="nc" id="L2332">                recursivePointerReleaseB = false;</span>
<span class="nc" id="L2333">                break;</span>
            case POINTER_DRAGGED: {
<span class="nc" id="L2335">                dragOccured = true;</span>
<span class="nc" id="L2336">                int arg1 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2337">                offset++;</span>
<span class="nc" id="L2338">                int arg2 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2339">                offset++;</span>
<span class="nc" id="L2340">                int timestamp = inputEventStackTmp[offset];</span>
<span class="nc" id="L2341">                offset++;</span>
<span class="nc" id="L2342">                updateDragSpeedStatus(arg1, arg2, timestamp);</span>
<span class="nc" id="L2343">                pointerPressedAndNotReleasedOrDragged = false;</span>
<span class="nc" id="L2344">                xArray1[0] = arg1;</span>
<span class="nc" id="L2345">                yArray1[0] = arg2;</span>
<span class="nc" id="L2346">                f.pointerDragged(xArray1, yArray1);</span>
<span class="nc" id="L2347">                break;</span>
            }
            case POINTER_DRAGGED_MULTI: {
<span class="nc" id="L2350">                dragOccured = true;</span>
<span class="nc" id="L2351">                pointerPressedAndNotReleasedOrDragged = false;</span>
<span class="nc" id="L2352">                int[] array1 = readArrayStackArgument(offset);</span>
<span class="nc" id="L2353">                offset += array1.length + 1;</span>
<span class="nc" id="L2354">                int[] array2 = readArrayStackArgument(offset);</span>
<span class="nc" id="L2355">                offset += array2.length + 1;</span>
<span class="nc" id="L2356">                f.pointerDragged(array1, array2);</span>
<span class="nc" id="L2357">                break;</span>
            }
            case POINTER_HOVER: {
<span class="nc" id="L2360">                int arg1 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2361">                offset++;</span>
<span class="nc" id="L2362">                int arg2 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2363">                offset++;</span>
<span class="nc" id="L2364">                int timestamp = inputEventStackTmp[offset];</span>
<span class="nc" id="L2365">                offset++;</span>
<span class="nc" id="L2366">                updateDragSpeedStatus(arg1, arg2, timestamp);</span>
<span class="nc" id="L2367">                xArray1[0] = arg1;</span>
<span class="nc" id="L2368">                yArray1[0] = arg2;</span>
<span class="nc" id="L2369">                f.pointerHover(xArray1, yArray1);</span>
<span class="nc" id="L2370">                break;</span>
            }
            case POINTER_HOVER_RELEASED: {
<span class="nc" id="L2373">                int arg1 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2374">                offset++;</span>
<span class="nc" id="L2375">                int arg2 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2376">                offset++;</span>
<span class="nc" id="L2377">                xArray1[0] = arg1;</span>
<span class="nc" id="L2378">                yArray1[0] = arg2;</span>
<span class="nc" id="L2379">                f.pointerHoverReleased(xArray1, yArray1);</span>
<span class="nc" id="L2380">                break;</span>
            }
            case POINTER_HOVER_PRESSED: {
<span class="nc" id="L2383">                int arg1 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2384">                offset++;</span>
<span class="nc" id="L2385">                int arg2 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2386">                offset++;</span>
<span class="nc" id="L2387">                xArray1[0] = arg1;</span>
<span class="nc" id="L2388">                yArray1[0] = arg2;</span>
<span class="nc" id="L2389">                f.pointerHoverPressed(xArray1, yArray1);</span>
<span class="nc" id="L2390">                break;</span>
            }
            case SIZE_CHANGED:
<span class="nc" id="L2393">                int w = inputEventStackTmp[offset];</span>
<span class="nc" id="L2394">                offset++;</span>
<span class="nc" id="L2395">                int h = inputEventStackTmp[offset];</span>
<span class="nc" id="L2396">                offset++;</span>
<span class="nc" id="L2397">                f.sizeChangedInternal(w, h);</span>
<span class="nc" id="L2398">                break;</span>
            case HIDE_NOTIFY:
<span class="nc" id="L2400">                f.hideNotify();</span>
<span class="nc" id="L2401">                break;</span>
            case SHOW_NOTIFY:
<span class="nc" id="L2403">                f.showNotify();</span>
                break;
        }
<span class="nc" id="L2406">        return offset;</span>
    }

    /**
     * This method should be invoked by components that broadcast events on the pointerReleased callback.
     * This method will indicate if a drag occured since the pointer press event, notice that this method will not
     * behave as expected for multi-touch events.
     *
     * @return true if a drag has occured since the last pointer pressed
     */
    public boolean hasDragOccured() {
<span class="nc" id="L2417">        return dragOccured;</span>
    }

    private int[] pointerEvent(int off, int[] event) {
<span class="nc" id="L2421">        int[] peX = new int[(event.length - 1) / 2];</span>
<span class="nc" id="L2422">        int offset = 0;</span>
<span class="nc bnc" id="L2423" title="All 2 branches missed.">        for (int iter = off; iter &lt; (event.length - 1); iter += 2) {</span>
<span class="nc" id="L2424">            peX[offset] = event[iter];</span>
<span class="nc" id="L2425">            offset++;</span>
        }
<span class="nc" id="L2427">        return peX;</span>
    }

    /**
     * Returns true for a case where the EDT has nothing at all to do
     */
    boolean shouldEDTSleep() {
<span class="fc" id="L2434">        Form current = impl.getCurrentForm();</span>
<span class="pc bpc" id="L2435" title="1 of 6 branches missed.">        return ((current == null || (!current.hasAnimations())) &amp;&amp;</span>
<span class="pc bpc" id="L2436" title="3 of 4 branches missed.">                (animationQueue == null || animationQueue.size() == 0) &amp;&amp;</span>
                inputEventStackPointer == 0 &amp;&amp;
<span class="fc bfc" id="L2438" title="All 2 branches covered.">                (!impl.hasPendingPaints()) &amp;&amp;</span>
<span class="pc bpc" id="L2439" title="2 of 6 branches missed.">                hasNoSerialCallsPending() &amp;&amp; !keyRepeatCharged</span>
<span class="pc bpc" id="L2440" title="3 of 4 branches missed.">                &amp;&amp; !longPointerCharged) || (isMinimized() &amp;&amp; hasNoSerialCallsPending());</span>
    }

    Form getCurrentInternal() {
<span class="nc" id="L2444">        return impl.getCurrentForm();</span>
    }

    /**
     * Same as getCurrent with the added exception of looking into the future
     * transitions and returning the last current in the transition (the upcoming
     * value for current)
     *
     * @return the form currently displayed on the screen or null if no form is
     * currently displayed
     */
    Form getCurrentUpcoming() {
<span class="nc" id="L2456">        return getCurrentUpcomingForm(false);</span>
    }

    private Form getCurrentUpcomingForm(boolean includeMenus) {
<span class="nc" id="L2460">        Form upcoming = null;</span>

        // we are in the middle of a transition so we should extract the next form
<span class="nc bnc" id="L2463" title="All 2 branches missed.">        if (animationQueue != null) {</span>
<span class="nc" id="L2464">            int size = animationQueue.size();</span>
<span class="nc bnc" id="L2465" title="All 2 branches missed.">            for (int iter = 0; iter &lt; size; iter++) {</span>
<span class="nc" id="L2466">                Animation o = animationQueue.get(iter);</span>
<span class="nc bnc" id="L2467" title="All 2 branches missed.">                if (o instanceof Transition) {</span>
<span class="nc" id="L2468">                    upcoming = (Form) ((Transition) o).getDestination();</span>
                }
            }
        }
<span class="nc bnc" id="L2472" title="All 2 branches missed.">        if (upcoming == null) {</span>
<span class="nc bnc" id="L2473" title="All 2 branches missed.">            if (includeMenus) {</span>
<span class="nc" id="L2474">                Form f = impl.getCurrentForm();</span>
<span class="nc bnc" id="L2475" title="All 2 branches missed.">                if (f instanceof Dialog) {</span>
<span class="nc bnc" id="L2476" title="All 2 branches missed.">                    if (f.isDisposed()) {</span>
<span class="nc" id="L2477">                        return getCurrent();</span>
                    }
                }
<span class="nc" id="L2480">                return f;</span>
            } else {
<span class="nc" id="L2482">                return getCurrent();</span>
            }
        }
<span class="nc" id="L2485">        return upcoming;</span>
    }

    /**
     * Return the form currently displayed on the screen or null if no form is
     * currently displayed.
     *
     * @return the form currently displayed on the screen or null if no form is
     * currently displayed
     */
    public Form getCurrent() {
<span class="fc" id="L2496">        Form current = impl.getCurrentForm();</span>
<span class="pc bpc" id="L2497" title="2 of 4 branches missed.">        if (current != null &amp;&amp; current instanceof Dialog) {</span>
<span class="nc bnc" id="L2498" title="All 4 branches missed.">            if (current.isMenu() || current.isDisposed()) {</span>
<span class="nc" id="L2499">                Form p = current.getPreviousForm();</span>
<span class="nc bnc" id="L2500" title="All 2 branches missed.">                if (p != null) {</span>
<span class="nc" id="L2501">                    return p;</span>
                }

                // we are in the middle of a transition so we should extract the next form
<span class="nc bnc" id="L2505" title="All 2 branches missed.">                if (animationQueue != null) {</span>
<span class="nc" id="L2506">                    int size = animationQueue.size();</span>
<span class="nc bnc" id="L2507" title="All 2 branches missed.">                    for (int iter = 0; iter &lt; size; iter++) {</span>
<span class="nc" id="L2508">                        Animation o = animationQueue.get(iter);</span>
<span class="nc bnc" id="L2509" title="All 2 branches missed.">                        if (o instanceof Transition) {</span>
<span class="nc" id="L2510">                            return (Form) ((Transition) o).getDestination();</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L2516">        return current;</span>
    }

    /**
     * Return the number of alpha levels supported by the implementation.
     *
     * @return the number of alpha levels supported by the implementation
     * @deprecated this method isn't implemented in most modern devices
     */
    public int numAlphaLevels() {
<span class="nc" id="L2526">        return impl.numAlphaLevels();</span>
    }

    /**
     * Returns the number of colors applicable on the device, note that the API
     * does not support gray scale devices.
     *
     * @return the number of colors applicable on the device
     * @deprecated this method isn't implemented in most modern devices
     */
    public int numColors() {
<span class="nc" id="L2537">        return impl.numColors();</span>
    }

    /**
     * Return the width of the display
     *
     * @return the width of the display
     */
    public int getDisplayWidth() {
<span class="fc" id="L2546">        return impl.getDisplayWidth();</span>
    }

    /**
     * Return the height of the display
     *
     * @return the height of the display
     */
    public int getDisplayHeight() {
<span class="fc" id="L2555">        return impl.getDisplayHeight();</span>
    }

    /**
     * Causes the given component to repaint, used internally by Form
     *
     * @param cmp the given component to repaint
     */
    void repaint(final Animation cmp) {
<span class="fc" id="L2564">        impl.repaint(cmp);</span>
<span class="fc" id="L2565">    }</span>

    /**
     * Converts the dips count to pixels, dips are roughly 1mm in length. This is a very rough estimate and not
     * to be relied upon
     *
     * @param dipCount   the dips that we will convert to pixels
     * @param horizontal indicates pixels in the horizontal plane
     * @return value in pixels
     */
    public int convertToPixels(int dipCount, boolean horizontal) {
<span class="fc" id="L2576">        return impl.convertToPixels(dipCount, horizontal);</span>
    }

    /**
     * Converts from specified unit to pixels.
     *
     * @param value    The value to convert, expressed in unitType.
     * @param unitType The unit type.  One of {@link Style#UNIT_TYPE_DIPS}, {@link Style#UNIT_TYPE_PIXELS},
     *                 {@link Style#UNIT_TYPE_REM}, {@link Style#UNIT_TYPE_SCREEN_PERCENTAGE}, {@link Style#UNIT_TYPE_VH},
     *                 {@link Style#UNIT_TYPE_VW}, {@link Style#UNIT_TYPE_VMIN}, {@link Style#UNIT_TYPE_VMAX}
     * @return The value converted to pixels.
     * @since 8.0
     */
    public int convertToPixels(float value, byte unitType) {
<span class="fc" id="L2590">        return convertToPixels(value, unitType, true);</span>
    }

    /**
     * Converts from specified unit to pixels.
     *
     * @param value      The value to convert, expressed in unitType.
     * @param unitType   The unit type.  One of {@link Style#UNIT_TYPE_DIPS}, {@link Style#UNIT_TYPE_PIXELS},
     *                   {@link Style#UNIT_TYPE_REM}, {@link Style#UNIT_TYPE_SCREEN_PERCENTAGE}, {@link Style#UNIT_TYPE_VH},
     *                   {@link Style#UNIT_TYPE_VW}, {@link Style#UNIT_TYPE_VMIN}, {@link Style#UNIT_TYPE_VMAX}
     * @param horizontal Whether screen percentage units should be based on horitonzal or vertical percentage.
     * @return The value converted to pixels.
     * @since 8.0
     */
    public int convertToPixels(float value, byte unitType, boolean horizontal) {


<span class="fc bfc" id="L2607" title="All 8 branches covered.">        switch (unitType) {</span>
            case Style.UNIT_TYPE_REM:
<span class="fc" id="L2609">                return Math.round(value * Font.getDefaultFont().getHeight());</span>
            case Style.UNIT_TYPE_VH:
<span class="fc" id="L2611">                return Math.round(value / 100f * CN.getDisplayHeight());</span>
            case Style.UNIT_TYPE_VW:
<span class="fc" id="L2613">                return Math.round(value / 100f * CN.getDisplayWidth());</span>
            case Style.UNIT_TYPE_VMIN:
<span class="fc" id="L2615">                return Math.round(value / 100f * Math.min(CN.getDisplayWidth(), CN.getDisplayHeight()));</span>
            case Style.UNIT_TYPE_VMAX:
<span class="fc" id="L2617">                return Math.round(value / 100f * Math.max(CN.getDisplayWidth(), CN.getDisplayHeight()));</span>
            case Style.UNIT_TYPE_DIPS:
<span class="fc" id="L2619">                return Display.getInstance().convertToPixels(value);</span>
            case Style.UNIT_TYPE_SCREEN_PERCENTAGE:
<span class="fc bfc" id="L2621" title="All 2 branches covered.">                if (!horizontal) {</span>
<span class="fc" id="L2622">                    float h = Display.getInstance().getDisplayHeight();</span>
<span class="fc" id="L2623">                    h = h / 100.0f * value;</span>
<span class="fc" id="L2624">                    return (int) h;</span>
                } else {
<span class="fc" id="L2626">                    float w = Display.getInstance().getDisplayWidth();</span>
<span class="fc" id="L2627">                    w = w / 100.0f * value;</span>
<span class="fc" id="L2628">                    return (int) w;</span>
                }
            default:
<span class="fc" id="L2631">                return (int) value;</span>
        }

    }

    /**
     * Converts the dips count to pixels, dips are roughly 1mm in length. This is a very rough estimate and not
     * to be relied upon. This version of the method assumes square pixels which is pretty much the norm.
     *
     * @param dipCount the dips that we will convert to pixels
     * @return value in pixels
     */
    public int convertToPixels(float dipCount) {
<span class="fc" id="L2644">        return Math.round(impl.convertToPixels((int) (dipCount * 1000), true) / 1000.0f);</span>
    }

    /**
     * Checks to see if the platform supports a native image cache.
     *
     * @return True on platforms that support a native image cache.  Currently only Javascript.
     */
    boolean supportsNativeImageCache() {
<span class="nc" id="L2653">        return impl.supportsNativeImageCache();</span>
    }

    /**
     * Returns the game action code matching the given key combination
     *
     * @param keyCode key code received from the event
     * @return game action matching this keycode
     */
    public int getGameAction(int keyCode) {
<span class="nc" id="L2663">        return impl.getGameAction(keyCode);</span>
    }

    /**
     * Returns the keycode matching the given game action constant (the opposite of getGameAction).
     * On some devices getKeyCode returns numeric keypad values for game actions,
     * this breaks the code since we filter these values (to prevent navigation on '2').
     * We pick unused negative values for game keys and assign them to game keys for
     * getKeyCode so they will work with getGameAction.
     *
     * @param gameAction game action constant from this class
     * @return keycode matching this constant
     * @deprecated this method doesn't work properly across device and is mocked up here
     * mostly for the case of unit testing. Do not use it for anything other than that! Do
     * not rely on getKeyCode(GAME_*) == keyCodeFromKeyEvent, this will never actually happen!
     */
    public int getKeyCode(int gameAction) {
<span class="nc" id="L2680">        return impl.getKeyCode(gameAction);</span>
    }

    /**
     * Indicates whether the 3rd softbutton should be supported on this device
     *
     * @return true if a third softbutton should be used
     */
    public boolean isThirdSoftButton() {
<span class="fc" id="L2689">        return thirdSoftButton;</span>
    }

    /**
     * Indicates whether the 3rd softbutton should be supported on this device
     *
     * @param thirdSoftButton true if a third softbutton should be used
     */
    public void setThirdSoftButton(boolean thirdSoftButton) {
<span class="nc" id="L2698">        this.thirdSoftButton = thirdSoftButton;</span>
<span class="nc" id="L2699">    }</span>

    /**
     * Displays the virtual keyboard on devices that support manually poping up
     * the vitual keyboard
     *
     * @param show toggles the virtual keyboards visibility
     * @deprecated this method was only relevant for feature phones.
     * You should use {@link com.codename1.ui.TextArea#startEditingAsync()} or {@link com.codename1.ui.TextArea#stopEditing()}
     * to control text field editing/VKB visibility
     */
    public void setShowVirtualKeyboard(boolean show) {
<span class="pc bpc" id="L2711" title="1 of 2 branches missed.">        if (isTouchScreenDevice()) {</span>
<span class="fc" id="L2712">            VirtualKeyboardInterface vkb = getDefaultVirtualKeyboard();</span>
<span class="pc bpc" id="L2713" title="1 of 2 branches missed.">            if (vkb != null) {</span>
<span class="nc" id="L2714">                vkb.showKeyboard(show);</span>
            }
        }
<span class="fc" id="L2717">    }</span>

    /**
     * Indicates if the virtual keyboard is currently showing or not
     *
     * @return true if the virtual keyboard is showing
     * @deprecated this method was only relevant for feature phones.
     * You should use {@link com.codename1.ui.TextArea#isEditing()} instead.
     */
    public boolean isVirtualKeyboardShowing() {
<span class="nc bnc" id="L2727" title="All 2 branches missed.">        if (!isTouchScreenDevice()) {</span>
<span class="nc" id="L2728">            return false;</span>
        }
<span class="nc bnc" id="L2730" title="All 4 branches missed.">        return getDefaultVirtualKeyboard() != null &amp;&amp; getDefaultVirtualKeyboard().isVirtualKeyboardShowing();</span>
    }

    /**
     * Returns all platform supported virtual keyboards names
     *
     * @return all platform supported virtual keyboards names
     * @deprecated this method is only used in feature phones and has no modern equivalent
     */
    public String[] getSupportedVirtualKeyboard() {
<span class="nc" id="L2740">        String[] retVal = new String[virtualKeyboards.size()];</span>
<span class="nc" id="L2741">        int index = 0;</span>
<span class="nc bnc" id="L2742" title="All 2 branches missed.">        for (String k : virtualKeyboards.keySet()) {</span>
<span class="nc" id="L2743">            retVal[index++] = k;</span>
<span class="nc" id="L2744">        }</span>
<span class="nc" id="L2745">        return retVal;</span>
    }

    /**
     * Register a virtual keyboard
     *
     * @param vkb
     * @deprecated this method is only used in feature phones and has no modern equivalent
     */
    public void registerVirtualKeyboard(VirtualKeyboardInterface vkb) {
<span class="nc" id="L2755">        virtualKeyboards.put(vkb.getVirtualKeyboardName(), vkb);</span>
<span class="nc" id="L2756">    }</span>

    /**
     * Get the default virtual keyboard or null if the VirtualKeyboard is disabled
     *
     * @return the default vkb
     * @deprecated this method is only used in feature phones and has no modern equivalent
     */
    public VirtualKeyboardInterface getDefaultVirtualKeyboard() {
<span class="pc bpc" id="L2765" title="1 of 2 branches missed.">        if (selectedVirtualKeyboard == null) {</span>
<span class="fc" id="L2766">            return null;</span>
        }
<span class="nc" id="L2768">        return virtualKeyboards.get(selectedVirtualKeyboard);</span>
    }

    /**
     * Sets the default virtual keyboard to be used by the platform
     *
     * @param vkb a VirtualKeyboard to be used or null to disable the
     *            VirtualKeyboard
     * @deprecated this method is only used in feature phones and has no modern equivalent
     */
    public void setDefaultVirtualKeyboard(VirtualKeyboardInterface vkb) {
<span class="nc bnc" id="L2779" title="All 2 branches missed.">        if (vkb != null) {</span>
<span class="nc" id="L2780">            selectedVirtualKeyboard = vkb.getVirtualKeyboardName();</span>
<span class="nc bnc" id="L2781" title="All 2 branches missed.">            if (!virtualKeyboards.containsKey(selectedVirtualKeyboard)) {</span>
<span class="nc" id="L2782">                registerVirtualKeyboard(vkb);</span>
            }
        } else {
<span class="nc" id="L2785">            selectedVirtualKeyboard = null;</span>
        }
<span class="nc" id="L2787">    }</span>

    /**
     * Gets the VirtualKeyboardListener Objects of exists.
     *
     * @return a Listener Object or null if not exists
     * @deprecated Use {@link #removeVirtualKeyboardListener(com.codename1.ui.events.ActionListener) }
     */
    public ActionListener getVirtualKeyboardListener() {
<span class="nc" id="L2796">        return virtualKeyboardListener;</span>
    }

    /**
     * Sets a listener for VirtualKeyboard hide/show events.
     * The Listener will get an event once the keyboard is opened/closed with
     * a Boolean value that represents the state of the keyboard true for open
     * and false for closed getSource() on the ActionEvent will return the
     * Boolean value.
     *
     * @param l the listener
     * @deprecated Use {@link #addVirtualKeyboardListener(com.codename1.ui.events.ActionListener) }
     */
    public void setVirtualKeyboardListener(ActionListener l) {
<span class="nc bnc" id="L2810" title="All 2 branches missed.">        if (virtualKeyboardListener != null) {</span>
<span class="nc" id="L2811">            removeVirtualKeyboardListener(l);</span>
        }
<span class="nc" id="L2813">        virtualKeyboardListener = l;</span>
<span class="nc" id="L2814">        addVirtualKeyboardListener(l);</span>
<span class="nc" id="L2815">    }</span>

    /**
     * Adds a listener for VirtualKeyboard hide/show events.  ActionEvents will return a Boolean
     * value for {@link ActionEvent#getSource() }, with {@literal Boolean.TRUE} on show, and {@literal Boolean.FALSE}
     * on hide.
     * &lt;p&gt;Note: Keyboard events may not be 100% reliable as they use heuristics on most platforms to guess when the keyboard
     * is shown or hidden.&lt;/p&gt;
     *
     * @param l The listener.
     * @see #removeVirtualKeyboardListener(com.codename1.ui.events.ActionListener)
     * @since 6.0
     */
    public synchronized void addVirtualKeyboardListener(ActionListener l) {
<span class="nc bnc" id="L2829" title="All 2 branches missed.">        if (virtualKeyboardListeners == null) {</span>
<span class="nc" id="L2830">            virtualKeyboardListeners = new EventDispatcher();</span>
        }
<span class="nc" id="L2832">        virtualKeyboardListeners.addListener(l);</span>
<span class="nc" id="L2833">    }</span>

    /**
     * Removes a listener for VirtualKeyboard hide/show events.  ActionEvents will return a Boolean
     * value for {@link ActionEvent#getSource() }, with {@literal Boolean.TRUE} on show, and {@literal Boolean.FALSE}
     * on hide.
     * &lt;p&gt;Note: Keyboard events may not be 100% reliable as they use heuristics on most platforms to guess when the keyboard
     * is shown or hidden.&lt;/p&gt;
     *
     * @param l The listener.
     * @see #addVirtualKeyboardListener(com.codename1.ui.events.ActionListener)
     * @since 6.0
     */
    public synchronized void removeVirtualKeyboardListener(ActionListener l) {
<span class="nc bnc" id="L2847" title="All 2 branches missed.">        if (virtualKeyboardListeners != null) {</span>
<span class="nc" id="L2848">            virtualKeyboardListeners.removeListener(l);</span>
        }
<span class="nc" id="L2850">    }</span>

    /**
     * Fires a virtual keyboard show event.
     *
     * @param show
     * @since 6.0
     */
    public void fireVirtualKeyboardEvent(boolean show) {
<span class="nc bnc" id="L2859" title="All 2 branches missed.">        if (virtualKeyboardListeners != null) {</span>
<span class="nc" id="L2860">            virtualKeyboardListeners.fireActionEvent(new ActionEvent(show));</span>
        }
<span class="nc" id="L2862">    }</span>

    /**
     * Gets the invisible area under the Virtual Keyboard.
     *
     * @return Height of the VKB that overlaps the screen.
     * @since 6.0
     */
    public int getInvisibleAreaUnderVKB() {
<span class="nc" id="L2871">        return impl.getInvisibleAreaUnderVKB();</span>
    }

    /**
     * Returns the type of the input device one of:
     * KEYBOARD_TYPE_UNKNOWN, KEYBOARD_TYPE_NUMERIC, KEYBOARD_TYPE_QWERTY,
     * KEYBOARD_TYPE_VIRTUAL, KEYBOARD_TYPE_HALF_QWERTY
     *
     * @return KEYBOARD_TYPE_UNKNOWN
     */
    public int getKeyboardType() {
<span class="nc" id="L2882">        return impl.getKeyboardType();</span>
    }

    /**
     * Indicates whether the device supports native in place editing in which case
     * lightweight input logic shouldn't be used for input.
     *
     * @return false by default
     */
    public boolean isNativeInputSupported() {
<span class="fc" id="L2892">        return impl.isNativeInputSupported();</span>
    }

    /**
     * Indicates whether the device supports multi-touch events, this is only
     * relevant when touch events are supported
     *
     * @return false by default
     */
    public boolean isMultiTouch() {
<span class="nc" id="L2902">        return impl.isMultiTouch();</span>
    }

    /**
     * Indicates whether the device has a double layer screen thus allowing two
     * stages to touch events: click and hover. This is true for devices such
     * as the storm but can also be true for a PC with a mouse pointer floating
     * on top.
     * &lt;p&gt;A click touch screen will also send pointer hover events to the underlying
     * software and will only send the standard pointer events on click.
     *
     * @return false by default
     */
    public boolean isClickTouchScreen() {
<span class="nc" id="L2916">        return impl.isClickTouchScreen();</span>
    }

    /**
     * This method returns the dragging speed based on the latest dragged
     * events
     *
     * @param yAxis indicates what axis speed is required
     * @return the dragging speed
     */
    public float getDragSpeed(boolean yAxis) {
        float speed;
<span class="nc bnc" id="L2928" title="All 2 branches missed.">        if (yAxis) {</span>
<span class="nc" id="L2929">            speed = impl.getDragSpeed(dragPathY, dragPathTime, dragPathOffset, dragPathLength);</span>
        } else {
<span class="nc" id="L2931">            speed = impl.getDragSpeed(dragPathX, dragPathTime, dragPathOffset, dragPathLength);</span>
        }
<span class="nc" id="L2933">        return speed;</span>
    }

    /**
     * Indicates whether Codename One should consider the bidi RTL algorithm
     * when drawing text or navigating with the text field cursor.
     *
     * @return true if the bidi algorithm should be considered
     */
    public boolean isBidiAlgorithm() {
<span class="nc" id="L2943">        return impl.isBidiAlgorithm();</span>
    }

    /**
     * Indicates whether Codename One should consider the bidi RTL algorithm
     * when drawing text or navigating with the text field cursor.
     *
     * @param activate set to true to activate the bidi algorithm, false to
     *                 disable it
     */
    public void setBidiAlgorithm(boolean activate) {
<span class="nc" id="L2954">        impl.setBidiAlgorithm(activate);</span>
<span class="nc" id="L2955">    }</span>

    /**
     * Converts the given string from logical bidi layout to visual bidi layout so
     * it can be rendered properly on the screen. This method is only necessary
     * for devices/platforms that don't have &quot;built in&quot; bidi support such as
     * Sony Ericsson devices.
     * See &lt;a href=&quot;http://www.w3.org/International/articles/inline-bidi-markup/#visual&quot;&gt;this&lt;/a&gt;
     * for more on visual vs. logical ordering.
     *
     * @param s a &quot;logical&quot; string with RTL characters
     * @return a &quot;visual&quot; renderable string
     */
    public String convertBidiLogicalToVisual(String s) {
<span class="nc" id="L2969">        return impl.convertBidiLogicalToVisual(s);</span>
    }

    /**
     * Returns the index of the given char within the source string, the actual
     * index isn't necessarily the same when bidi is involved
     * See &lt;a href=&quot;http://www.w3.org/International/articles/inline-bidi-markup/#visual&quot;&gt;this&lt;/a&gt;
     * for more on visual vs. logical ordering.
     *
     * @param source the string in which we are looking for the position
     * @param index  the &quot;logical&quot; location of the cursor
     * @return the &quot;visual&quot; location of the cursor
     */
    public int getCharLocation(String source, int index) {
<span class="nc" id="L2983">        return impl.getCharLocation(source, index);</span>
    }

    /**
     * Returns true if the given character is an RTL character
     *
     * @param c character to test
     * @return true if the charcter is an RTL character
     */
    public boolean isRTL(char c) {
<span class="nc" id="L2993">        return impl.isRTL(c);</span>
    }

    /**
     * This method is essentially equivalent to cls.getResourceAsStream(String)
     * however some platforms might define unique ways in which to load resources
     * within the implementation.
     *
     * @param cls      class to load the resource from
     * @param resource relative/absolute URL based on the Java convention
     * @return input stream for the resource or null if not found
     */
    public InputStream getResourceAsStream(Class cls, String resource) {
<span class="fc" id="L3006">        return impl.getResourceAsStream(cls, resource);</span>
    }

    /**
     * An error handler will receive an action event with the source exception from the EDT
     * once an error handler is installed the default Codename One error dialog will no longer appear
     *
     * @param e listener receiving the errors
     */
    public void addEdtErrorHandler(ActionListener e) {
<span class="nc bnc" id="L3016" title="All 2 branches missed.">        if (errorHandler == null) {</span>
<span class="nc" id="L3017">            errorHandler = new EventDispatcher();</span>
        }
<span class="nc" id="L3019">        errorHandler.addListener(e);</span>
<span class="nc" id="L3020">    }</span>

    /**
     * An error handler will receive an action event with the source exception from the EDT
     * once an error handler is installed the default Codename One error dialog will no longer appear
     *
     * @param e listener receiving the errors
     */
    public void removeEdtErrorHandler(ActionListener e) {
<span class="nc bnc" id="L3029" title="All 2 branches missed.">        if (errorHandler != null) {</span>
<span class="nc" id="L3030">            errorHandler.removeListener(e);</span>
<span class="nc" id="L3031">            Collection v = errorHandler.getListenerCollection();</span>
<span class="nc bnc" id="L3032" title="All 4 branches missed.">            if (v == null || v.size() == 0) {</span>
<span class="nc" id="L3033">                errorHandler = null;</span>
            }
        }
<span class="nc" id="L3036">    }</span>

    /**
     * Allows a Codename One application to minimize without forcing it to the front whenever
     * a new dialog is poped up
     *
     * @return allowMinimizing value
     */
    public boolean isAllowMinimizing() {
<span class="nc" id="L3045">        return allowMinimizing;</span>
    }

    /**
     * Allows a Codename One application to minimize without forcing it to the front whenever
     * a new dialog is poped up
     *
     * @param allowMinimizing value
     */
    public void setAllowMinimizing(boolean allowMinimizing) {
<span class="nc" id="L3055">        this.allowMinimizing = allowMinimizing;</span>
<span class="nc" id="L3056">    }</span>

    /**
     * This is an internal state flag relevant only for pureTouch mode (otherwise it
     * will always be true). A pureTouch mode is stopped if a user switches to using
     * the trackball/navigation pad and this flag essentially toggles between those two modes.
     *
     * @return the shouldRenderSelection
     */
    public boolean shouldRenderSelection() {
<span class="pc bpc" id="L3066" title="5 of 6 branches missed.">        return !pureTouch || pointerPressedAndNotReleasedOrDragged || lastInteractionWasKeypad;</span>
    }

    /**
     * This is an internal state flag relevant only for pureTouch mode (otherwise it
     * will always be true). A pureTouch mode is stopped if a user switches to using
     * the trackball/navigation pad and this flag essentially toggles between those two modes.
     *
     * @param c the component to test against, this prevents a touch outside of the component that triggers a repaint from painting the component selection
     * @return the shouldRenderSelection
     */
    public boolean shouldRenderSelection(Component c) {
<span class="fc bfc" id="L3078" title="All 2 branches covered.">        if (c.isCellRenderer()) {</span>
<span class="fc" id="L3079">            return shouldRenderSelection();</span>
        }
<span class="pc bpc" id="L3081" title="9 of 10 branches missed.">        return !pureTouch || lastInteractionWasKeypad || (pointerPressedAndNotReleasedOrDragged &amp;&amp; c.contains(pointerX, pointerY)) || c.shouldRenderComponentSelection();</span>
    }

    /**
     * A pure touch device has no focus showing when the user is using the touch
     * interface. Selection only shows when the user actually touches the screen
     * or suddenly switches to using a keypad/trackball. This sort of interface
     * is common in Android devices
     *
     * @return the pureTouch flag
     */
    public boolean isPureTouch() {
<span class="fc" id="L3093">        return pureTouch;</span>
    }

    /**
     * A pure touch device has no focus showing when the user is using the touch
     * interface. Selection only shows when the user actually touches the screen
     * or suddenly switches to using a keypad/trackball. This sort of interface
     * is common in Android devices
     *
     * @param pureTouch the value for pureTouch
     */
    public void setPureTouch(boolean pureTouch) {
<span class="fc" id="L3105">        this.pureTouch = pureTouch;</span>
<span class="fc" id="L3106">    }</span>

    /**
     * Indicates whether Codename One commands should be mapped to the native menus
     *
     * @return the nativeCommands status
     * @deprecated use getCommandBehavior() == Display.COMMAND_BEHAVIOR_NATIVE
     */
    public boolean isNativeCommands() {
<span class="pc bpc" id="L3115" title="1 of 2 branches missed.">        return getCommandBehavior() == COMMAND_BEHAVIOR_NATIVE;</span>
    }

    /**
     * Indicates whether Codename One commands should be mapped to the native menus
     *
     * @param nativeCommands the flag to set
     * @deprecated use setCommandBehavior(Display.COMMAND_BEHAVIOR_NATIVE)
     */
    public void setNativeCommands(boolean nativeCommands) {
<span class="nc" id="L3125">        setCommandBehavior(COMMAND_BEHAVIOR_NATIVE);</span>
<span class="nc" id="L3126">    }</span>

    /**
     * Exits the application...
     */
    public void exitApplication() {
<span class="nc" id="L3132">        codenameOneExited = true;</span>
<span class="nc" id="L3133">        impl.exit();</span>
<span class="nc" id="L3134">    }</span>

    /**
     * Checks if this platform supports full-screen mode.  If full-screen mode is supported, you can use
     * the {@link #requestFullScreen() }, {@link #exitFullScreen() }, and {@link #isInFullScreenMode() } methods
     * to enter and exit full-screen - and query the current state.
     *
     * &lt;p&gt;Currently only desktop and Javascript builds support full-screen mode; And Javascript
     * only supports this on certain browsers.  See the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API&quot;&gt;MDN Fullscreen API docs&lt;/a&gt;
     * for a list of browsers that support full-screen.&lt;/p&gt;
     *
     * &lt;p&gt;When running in the simulator, full-screen is only supported for the desktop skin.&lt;/p&gt;
     *
     * @return {@literal true} if Full-screen mode is supported on this platform.
     * @see #requestFullScreen()
     * @see #exitFullScreen()
     * @see #isInFullScreenMode()
     * @since 6.0
     */
    public boolean isFullScreenSupported() {
<span class="nc" id="L3154">        return impl.isFullScreenSupported();</span>
    }

    /**
     * Try to enter full-screen mode if the platform supports it.
     *
     * &lt;p&gt;Currently only desktop and Javascript builds support full-screen mode; And Javascript
     * only supports this on certain browsers.  See the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API&quot;&gt;MDN Fullscreen API docs&lt;/a&gt;
     * for a list of browsers that support full-screen.&lt;/p&gt;
     *
     * &lt;p&gt;When running in the simulator, full-screen is only supported for the desktop skin.&lt;/p&gt;
     *
     * @return {@literal true} on success.  This will also return {@literal true} if the app is already running in full-screen mode.  It will return {@literal false}
     * if the app fails to enter full-screen mode.
     * @see #exitFullScreen()
     * @see #isInFullScreenMode()
     * @see #isFullScreenSupported()
     * @since 6.0
     */
    public boolean requestFullScreen() {
<span class="nc" id="L3174">        return impl.requestFullScreen();</span>
    }

    /**
     * Try to exit full-screen mode if the platform supports it.
     *
     * &lt;p&gt;Currently only desktop and Javascript builds support full-screen mode; And Javascript
     * only supports this on certain browsers.  See the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API&quot;&gt;MDN Fullscreen API docs&lt;/a&gt;
     * for a list of browsers that support full-screen.&lt;/p&gt;
     *
     * &lt;p&gt;When running in the simulator, full-screen is only supported for the desktop skin.&lt;/p&gt;
     *
     * @return {@literal true} on success.  This will also return {@literal true} if the app is already NOT in full-screen mode.  It will return {@literal false}
     * if the app fails to exit full-screen mode.
     * @see #requestFullScreen()
     * @see #isInFullScreenMode()
     * @see #isFullScreenSupported()
     * @since 6.0
     */
    public boolean exitFullScreen() {
<span class="nc" id="L3194">        return impl.exitFullScreen();</span>
    }

    /**
     * Checks if the app is currently running in full-screen mode.
     *
     * @return {@literal true} if the app is currently in full-screen mode.
     * @see #requestFullScreen()
     * @see #exitFullScreen()
     * @see #isFullScreenSupported()
     * @since 6.0
     */
    public boolean isInFullScreenMode() {
<span class="nc" id="L3207">        return impl.isInFullScreenMode();</span>
    }

    /**
     * Shows a native Form/Canvas or some other heavyweight native screen
     *
     * @param nativeFullScreenPeer the native screen peer
     */
    public void showNativeScreen(Object nativeFullScreenPeer) {
<span class="nc" id="L3216">        inNativeUI = true;</span>
<span class="nc" id="L3217">        impl.showNativeScreen(nativeFullScreenPeer);</span>
<span class="nc" id="L3218">    }</span>

    /**
     * Normally Codename One folds the VKB when switching forms this field allows us
     * to block that behavior.
     *
     * @return the autoFoldVKBOnFormSwitch
     */
    public boolean isAutoFoldVKBOnFormSwitch() {
<span class="nc" id="L3227">        return autoFoldVKBOnFormSwitch;</span>
    }

    /**
     * Normally Codename One folds the VKB when switching forms this field allows us
     * to block that behavior.
     *
     * @param autoFoldVKBOnFormSwitch the autoFoldVKBOnFormSwitch to set
     */
    public void setAutoFoldVKBOnFormSwitch(boolean autoFoldVKBOnFormSwitch) {
<span class="nc" id="L3237">        this.autoFoldVKBOnFormSwitch = autoFoldVKBOnFormSwitch;</span>
<span class="nc" id="L3238">    }</span>

    /**
     * Indicates the way commands should be added to a form as one of the ocmmand constants defined
     * in this class
     *
     * @return the commandBehavior
     * @deprecated we recommend migrating to the {@link Toolbar} API. When using the toolbar the command
     * behavior can't be manipulated
     */
    public int getCommandBehavior() {
<span class="fc" id="L3249">        return impl.getCommandBehavior();</span>
    }

    /**
     * Indicates the way commands should be added to a form as one of the ocmmand constants defined
     * in this class
     *
     * @param commandBehavior the commandBehavior to set
     * @deprecated we recommend migrating to the {@link Toolbar} API. When using the toolbar the command
     * behavior can't be manipulated
     */
    public void setCommandBehavior(int commandBehavior) {
<span class="pc bpc" id="L3261" title="1 of 2 branches missed.">        if (commandBehavior == Display.COMMAND_BEHAVIOR_SIDE_NAVIGATION) {</span>
<span class="nc" id="L3262">            String message = &quot;WARNING: Display.setCommandBehavior() is deprecated, Using it may result in unexpected behaviour. In particular, using COMMAND_BEHAVIOR_SIDE_NAVIGATION in conjunction with Toolbar.setOnTopSideMenu(true) may result in runtime errors.&quot;;</span>
<span class="nc" id="L3263">            Log.p(message, Log.WARNING);</span>
        }
<span class="fc" id="L3265">        impl.setCommandBehavior(commandBehavior);</span>
<span class="fc" id="L3266">    }</span>

    /**
     * Posts a message to the native platform.  Different platforms may handle messages posted this
     * way differently.
     * &lt;p&gt;The Javascript port will dispatch the message on the {@literal window} object
     * as a custom DOM event named 'cn1outbox', with the event data containing a 'detail' key with the
     * message, and a 'code' key with the code.&lt;/p&gt;
     *
     * @param message The message.
     * @since 7.0
     */
    public void postMessage(MessageEvent message) {
<span class="nc" id="L3279">        impl.postMessage(message);</span>
<span class="nc" id="L3280">    }</span>

    /**
     * Adds a listener to receive messages from the native platform.  This is one mechanism for the native
     * platform to communicate with the Codename one app.
     *
     * &lt;p&gt;In the JavaScript port, listeners will be notified when DOM events named 'cn1inbox' are received on the
     * window object.  The event data 'detail' key will be the source of the message, and the 'code' key will be the
     * source of the code.
     *
     * @param l The listener.
     * @since 7.0
     */
    public void addMessageListener(ActionListener&lt;MessageEvent&gt; l) {
<span class="nc bnc" id="L3294" title="All 2 branches missed.">        if (messageListeners == null) {</span>
<span class="nc" id="L3295">            messageListeners = new EventDispatcher();</span>
        }
<span class="nc" id="L3297">        messageListeners.addListener(l);</span>
<span class="nc" id="L3298">    }</span>

    /**
     * Removes a listener from receiving messages from the native platform.
     *
     * @param l The listener.
     * @since 7.0
     */
    public void removeMessageListener(ActionListener&lt;MessageEvent&gt; l) {
<span class="nc bnc" id="L3307" title="All 2 branches missed.">        if (messageListeners != null) {</span>
<span class="nc" id="L3308">            messageListeners.removeListener(l);</span>
        }
<span class="nc" id="L3310">    }</span>

    /**
     * Dispatches a message to all of the registered listeners.
     *
     * @param evt
     * @see #addMessageListener(com.codename1.ui.events.ActionListener)
     * @see #removeMessageListener(com.codename1.ui.events.ActionListener)
     * @since 7.0
     */
    public void dispatchMessage(MessageEvent evt) {
<span class="nc bnc" id="L3321" title="All 4 branches missed.">        if (messageListeners != null &amp;&amp; messageListeners.hasListeners()) {</span>
<span class="nc" id="L3322">            messageListeners.fireActionEvent(evt);</span>
        }
<span class="nc" id="L3324">    }</span>

    /**
     * Returns the property from the underlying platform deployment or the default
     * value if no deployment values are supported. This is equivalent to the
     * getAppProperty from the jad file.
     * &lt;p&gt;The implementation should be responsible for the following keys to return
     * reasonable valid values for the application:
     * &lt;ol&gt;
     * &lt;li&gt;AppName
     * &lt;li&gt;User-Agent
     * &lt;li&gt;AppVersion
     * &lt;li&gt;Platform - Similar to microedition.platform
     * &lt;li&gt;OS - returns what is the underlying platform e.g. - iOS, Android, RIM, SE...
     * &lt;li&gt;OSVer - OS version when available as a user readable string (not necessarily a number e.g: 3.2.1).
     *
     * &lt;/ol&gt;
     *
     * @param key          the key of the property
     * @param defaultValue a default return value
     * @return the value of the property
     */
    public String getProperty(String key, String defaultValue) {
<span class="fc bfc" id="L3347" title="All 2 branches covered.">        if (&quot;AppArg&quot;.equals(key)) {</span>
<span class="fc" id="L3348">            String out = impl.getAppArg();</span>
<span class="pc bpc" id="L3349" title="1 of 2 branches missed.">            return out == null ? defaultValue : out;</span>
        }
<span class="pc bpc" id="L3351" title="1 of 2 branches missed.">        if (&quot;Component.revalidateOnStyleChange&quot;.equals(key)) {</span>
<span class="nc bnc" id="L3352" title="All 2 branches missed.">            return Component.revalidateOnStyleChange ? &quot;true&quot; : &quot;false&quot;;</span>
        }
<span class="fc bfc" id="L3354" title="All 2 branches covered.">        if (localProperties != null) {</span>
<span class="fc" id="L3355">            String v = localProperties.get(key);</span>
<span class="fc bfc" id="L3356" title="All 2 branches covered.">            if (v != null) {</span>
<span class="fc" id="L3357">                return v;</span>
            }
        }
<span class="fc" id="L3360">        return impl.getProperty(key, defaultValue);</span>
    }

    /**
     * Sets a local property to the application, this method has no effect on the
     * implementation code and only allows the user to override the logic of getProperty
     * for internal application purposes.
     *
     * @param key   key the key of the property
     * @param value the value of the property
     */
    public void setProperty(String key, String value) {
<span class="fc bfc" id="L3372" title="All 2 branches covered.">        if (&quot;AppArg&quot;.equals(key)) {</span>
<span class="fc" id="L3373">            impl.setAppArg(value);</span>
<span class="fc" id="L3374">            return;</span>
        }
<span class="fc bfc" id="L3376" title="All 2 branches covered.">        if (&quot;blockOverdraw&quot;.equals(key)) {</span>
<span class="fc" id="L3377">            Container.blockOverdraw = true;</span>
<span class="fc" id="L3378">            return;</span>
        }
<span class="fc bfc" id="L3380" title="All 2 branches covered.">        if (&quot;blockCopyPaste&quot;.equals(key)) {</span>
<span class="fc" id="L3381">            impl.blockCopyPaste(&quot;true&quot;.equals(value));</span>
        }
<span class="fc bfc" id="L3383" title="All 2 branches covered.">        if (&quot;Component.revalidateOnStyleChange&quot;.equals(key)) {</span>
<span class="fc" id="L3384">            Component.revalidateOnStyleChange = &quot;true&quot;.equalsIgnoreCase(value);</span>
        }
<span class="pc bpc" id="L3386" title="1 of 2 branches missed.">        if (key.startsWith(&quot;platformHint.&quot;)) {</span>
<span class="nc" id="L3387">            impl.setPlatformHint(key, value);</span>
<span class="nc" id="L3388">            return;</span>
        }
<span class="fc bfc" id="L3390" title="All 2 branches covered.">        if (localProperties == null) {</span>
<span class="fc" id="L3391">            localProperties = new HashMap&lt;String, String&gt;();</span>
        }
<span class="pc bpc" id="L3393" title="1 of 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L3394">            localProperties.remove(key);</span>
        } else {
<span class="fc" id="L3396">            localProperties.put(key, value);</span>
        }
<span class="fc" id="L3398">    }</span>

    /**
     * &lt;p&gt;Returns true if executing this URL should work, returns false if it will not
     * and null if this is unknown.&lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/7aefb64909e75e10c396.js&quot;&gt;&lt;/script&gt;
     *
     * @param url the url that would be executed
     * @return true if executing this URL should work, returns false if it will not
     * and null if this is unknown
     */
    public Boolean canExecute(String url) {
<span class="nc" id="L3410">        return impl.canExecute(url);</span>
    }

    /**
     * &lt;p&gt;Executes the given URL on the native platform&lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/7aefb64909e75e10c396.js&quot;&gt;&lt;/script&gt;
     *
     * @param url the url to execute
     */
    public void execute(String url) {
<span class="nc" id="L3420">        impl.execute(url);</span>
<span class="nc" id="L3421">    }</span>

    /**
     * Executes the given URL on the native platform, this method is useful if
     * the platform has the ability to send an event to the app when the execution
     * has ended, currently this works only for Android platform to invoke other
     * intents.
     *
     * @param url      the url to execute
     * @param response a callback from the platform when this execution returned
     *                 to the application
     */
    public void execute(String url, ActionListener response) {
<span class="nc" id="L3434">        impl.execute(url, response);</span>
<span class="nc" id="L3435">    }</span>

    /**
     * Returns one of the density variables appropriate for this device, notice that
     * density doesn't always correspond to resolution and an implementation might
     * decide to change the density based on DPI constraints.
     *
     * @return one of the DENSITY constants of Display
     */
    public int getDeviceDensity() {
<span class="fc" id="L3445">        return impl.getDeviceDensity();</span>
    }

    /**
     * Returns the device density as a string.
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;DENSITY_VERY_LOW : &quot;very-low&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_LOW : &quot;low&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_MEDIUM : &quot;medium&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_HIGH : &quot;high&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_VERY_HIGH : &quot;very-high&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_HD : &quot;hd&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_560 : &quot;560&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_2HD : &quot;2hd&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_4K : &quot;4k&quot;;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return Device density as a string.
     * @see #getDeviceDensity()
     * @since 7.0
     */
    public String getDensityStr() {
<span class="nc bnc" id="L3469" title="All 10 branches missed.">        switch (getDeviceDensity()) {</span>
            case DENSITY_VERY_LOW:
<span class="nc" id="L3471">                return &quot;very-low&quot;;</span>
            case DENSITY_LOW:
<span class="nc" id="L3473">                return &quot;low&quot;;</span>
            case DENSITY_MEDIUM:
<span class="nc" id="L3475">                return &quot;medium&quot;;</span>
            case DENSITY_HIGH:
<span class="nc" id="L3477">                return &quot;high&quot;;</span>
            case DENSITY_VERY_HIGH:
<span class="nc" id="L3479">                return &quot;very-high&quot;;</span>
            case DENSITY_HD:
<span class="nc" id="L3481">                return &quot;hd&quot;;</span>
            case DENSITY_560:
<span class="nc" id="L3483">                return &quot;560&quot;;</span>
            case DENSITY_2HD:
<span class="nc" id="L3485">                return &quot;2hd&quot;;</span>
            case DENSITY_4K:
<span class="nc" id="L3487">                return &quot;4k&quot;;</span>
            default:
<span class="nc" id="L3489">                throw new IllegalStateException(&quot;Unknown density &quot; + getDeviceDensity());</span>
        }
    }

    /**
     * Plays a builtin device sound matching the given identifier, implementations
     * and themes can offer additional identifiers to the ones that are already built
     * in.
     *
     * @param soundIdentifier the sound identifier which can match one of the
     *                        common constants in this class or be a user/implementation defined sound
     * @deprecated this isn't supported on most platforms
     */
    public void playBuiltinSound(String soundIdentifier) {
<span class="fc" id="L3503">        impl.playBuiltinSound(soundIdentifier);</span>
<span class="fc" id="L3504">    }</span>

    /**
     * Gets the display safe area as a rectangle.
     *
     * @param rect Out parameter that will store the display safe area.
     * @return The display safe area.
     * @see Form#getSafeArea()
     * @since 7.0
     */
    public Rectangle getDisplaySafeArea(Rectangle rect) {
<span class="nc" id="L3515">        return impl.getDisplaySafeArea(rect);</span>
    }

    /**
     * Installs a replacement sound as the builtin sound responsible for the given
     * sound identifier (this will override the system sound if such a sound exists).
     *
     * @param soundIdentifier the sound string passed to playBuiltinSound
     * @param data            an input stream containing platform specific audio file, its usually safe
     *                        to assume that wav/mp3 would be supported.
     * @throws IOException if the stream throws an exception
     */
    public void installBuiltinSound(String soundIdentifier, InputStream data) throws IOException {
<span class="nc" id="L3528">        impl.installBuiltinSound(soundIdentifier, data);</span>
<span class="nc" id="L3529">    }</span>

    /**
     * Indicates whether a user installed or system sound is available
     *
     * @param soundIdentifier the sound string passed to playBuiltinSound
     * @return true if a sound of this given type is avilable
     * @deprecated this isn't supported on most platforms
     */
    public boolean isBuiltinSoundAvailable(String soundIdentifier) {
<span class="nc" id="L3539">        return impl.isBuiltinSoundAvailable(soundIdentifier);</span>
    }

    /**
     * Allows muting/unmuting the builtin sounds easily
     *
     * @return true if the sound is *not* muted
     */
    public boolean isBuiltinSoundsEnabled() {
<span class="fc" id="L3548">        return impl.isBuiltinSoundsEnabled();</span>
    }

    /**
     * Allows muting/unmuting the builtin sounds easily
     *
     * @param enabled indicates whether the sound is muted
     */
    public void setBuiltinSoundsEnabled(boolean enabled) {
<span class="nc" id="L3557">        impl.setBuiltinSoundsEnabled(enabled);</span>
<span class="nc" id="L3558">    }</span>

    /**
     * Creates a sound in the given URI which is partially platform specific.
     * Notice that an audio is &quot;auto destroyed&quot; on completion and cannot be played
     * twice!
     *
     * @param uri          the platform specific location for the sound
     * @param onCompletion invoked when the audio file finishes playing, may be null
     * @return a handle that can be used to control the playback of the audio
     * @throws java.io.IOException if the URI access fails
     */
    public Media createMedia(String uri, boolean isVideo, Runnable onCompletion) throws IOException {
<span class="fc" id="L3571">        return impl.createMedia(uri, isVideo, onCompletion);</span>
    }

    /**
     * Creates media asynchronously.
     *
     * @param uri          the platform specific location for the sound
     * @param onCompletion invoked when the audio file finishes playing, may be null
     * @return a handle that can be used to control the playback of the audio
     * @since 7.0
     */
    public AsyncResource&lt;Media&gt; createMediaAsync(String uri, boolean video, Runnable onCompletion) {
<span class="fc" id="L3583">        return impl.createMediaAsync(uri, video, onCompletion);</span>
    }

    /**
     * Adds a callback to a Media element that will be called when the media finishes playing.
     *
     * @param media        The media to add the callback to.
     * @param onCompletion The callback that will run on the EDT when the playback completes.
     * @see #removeCompletionHandler(com.codename1.media.Media, java.lang.Runnable)
     */
    public void addCompletionHandler(Media media, Runnable onCompletion) {
<span class="fc" id="L3594">        impl.addCompletionHandler(media, onCompletion);</span>
<span class="fc" id="L3595">    }</span>

    /**
     * Removes onComplete callback from Media element.
     *
     * @param media        The media element.
     * @param onCompletion The callback.
     * @see #addCompletionHandler(com.codename1.media.Media, java.lang.Runnable)
     */
    public void removeCompletionHandler(Media media, Runnable onCompletion) {
<span class="fc" id="L3605">        impl.removeCompletionHandler(media, onCompletion);</span>
<span class="fc" id="L3606">    }</span>

    /**
     * Create the sound in the given stream
     * Notice that an audio is &quot;auto destroyed&quot; on completion and cannot be played
     * twice!
     *
     * @param stream       the stream containing the media data
     * @param mimeType     the type of the data in the stream
     * @param onCompletion invoked when the audio file finishes playing, may be null
     * @return a handle that can be used to control the playback of the audio
     * @throws java.io.IOException if the URI access fails
     */
    public Media createMedia(InputStream stream, String mimeType, Runnable onCompletion) throws IOException {
<span class="fc" id="L3620">        return impl.createMedia(stream, mimeType, onCompletion);</span>
    }

    public AsyncResource&lt;Media&gt; createMediaAsync(InputStream stream, String mimeType, Runnable onCompletion) {
<span class="fc" id="L3624">        return impl.createMediaAsync(stream, mimeType, onCompletion);</span>

    }

    /**
     * Creates a soft/weak reference to an object that allows it to be collected
     * yet caches it. This method is in the porting layer since CLDC only includes
     * weak references while some platforms include nothing at all and some include
     * the superior soft references.
     *
     * @param o object to cache
     * @return a caching object or null  if caching isn't supported
     */
    public Object createSoftWeakRef(Object o) {
<span class="fc" id="L3638">        return impl.createSoftWeakRef(o);</span>
    }

    /**
     * Extracts the hard reference from the soft/weak reference given
     *
     * @param o the reference returned by createSoftWeakRef
     * @return the original object submitted or null
     */
    public Object extractHardRef(Object o) {
<span class="fc" id="L3648">        return impl.extractHardRef(o);</span>
    }

    /**
     * Indicates if the implemenetation has a native underlying theme
     *
     * @return true if the implementation has a native theme available
     */
    public boolean hasNativeTheme() {
<span class="nc" id="L3657">        return impl.hasNativeTheme();</span>
    }

    /**
     * Installs the native theme, this is only applicable if hasNativeTheme() returned true. Notice that this method
     * might replace the DefaultLookAndFeel instance and the default transitions.
     */
    public void installNativeTheme() {
<span class="nc" id="L3665">        impl.installNativeTheme();</span>
<span class="nc" id="L3666">    }</span>

    /**
     * Performs a clipboard copy operation, if the native clipboard is supported by the implementation it would be used
     *
     * @param obj object to copy, while this can be any arbitrary object it is recommended that only Strings or Codename One
     *            image objects be used to copy
     */
    public void copyToClipboard(Object obj) {
<span class="nc" id="L3675">        impl.copyToClipboard(obj);</span>
<span class="nc" id="L3676">    }</span>

    /**
     * Returns the current content of the clipboard
     *
     * @return can be any object or null see copyToClipboard
     */
    public Object getPasteDataFromClipboard() {
<span class="nc" id="L3684">        return impl.getPasteDataFromClipboard();</span>
    }

    /**
     * Returns true if the device is currently in portrait mode
     *
     * @return true if the device is in portrait mode
     */
    public boolean isPortrait() {
<span class="fc" id="L3693">        return impl.isPortrait();</span>
    }

    /**
     * Returns true if the device allows forcing the orientation via code, feature phones do not allow this
     * although some include a jad property allowing for this feature
     *
     * &lt;p&gt;Since version 6.0, orientation lock is supported in Javascript builds in some browsers.  For a full
     * list of browsers the support locking orientation, see the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation&quot;&gt;MDN Lock Orientation docs&lt;/a&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; In Javascript builds, orientation lock is only supported if the app is running in full-screen mode.  If the app is not
     * currently in full-screen mode, then {@link #canForceOrientation() } will return {@literal false} and {@link #lockOrientation(boolean) } will do nothing.&lt;/p&gt;
     *
     * @return true if lockOrientation  would work
     * @see #lockOrientation(boolean)
     * @see #unlockOrientation()
     */
    public boolean canForceOrientation() {
<span class="nc" id="L3711">        return impl.canForceOrientation();</span>
    }

    /**
     * On devices that return true for canForceOrientation() this method can lock the device orientation
     * either to portrait or landscape mode
     *
     * &lt;p&gt;Since version 6.0, orientation lock is supported in Javascript builds in some browsers.  For a full
     * list of browsers the support locking orientation, see the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation&quot;&gt;MDN Lock Orientation docs&lt;/a&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; In Javascript builds, orientation lock is only supported if the app is running in full-screen mode.  If the app is not
     * currently in full-screen mode, then {@link #canForceOrientation() } will return {@literal false} and {@link #lockOrientation(boolean) } will do nothing.&lt;/p&gt;
     *
     * @param portrait true to lock to portrait mode, false to lock to landscape mode
     * @see #unlockOrientation()
     * @see #canForceOrientation()
     */
    public void lockOrientation(boolean portrait) {
<span class="nc" id="L3729">        impl.lockOrientation(portrait);</span>
<span class="nc" id="L3730">    }</span>

    /**
     * This is the reverse method for lock orientation allowing orientation lock to be disabled
     *
     * &lt;p&gt;Since version 6.0, orientation lock is supported in Javascript builds in some browsers.  For a full
     * list of browsers the support locking orientation, see the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation&quot;&gt;MDN Lock Orientation docs&lt;/a&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; In Javascript builds, orientation lock is only supported if the app is running in full-screen mode.  If the app is not
     * currently in full-screen mode, then {@link #canForceOrientation() } will return {@literal false} and {@link #lockOrientation(boolean) } will do nothing.&lt;/p&gt;
     *
     * @see #lockOrientation(boolean)
     * @see #canForceOrientation()
     */
    public void unlockOrientation() {
<span class="nc" id="L3745">        impl.unlockOrientation();</span>
<span class="nc" id="L3746">    }</span>

    /**
     * Indicates whether the device is a tablet, notice that this is often a guess
     *
     * @return true if the device is assumed to be a tablet
     */
    public boolean isTablet() {
<span class="nc" id="L3754">        return impl.isTablet();</span>
    }

    /**
     * Returns true if this is a desktop application
     *
     * @return true if this is a desktop application
     */
    public boolean isDesktop() {
<span class="nc" id="L3763">        return impl.isDesktop();</span>
    }

    /**
     * Returns true if the device has dialing capabilities
     *
     * @return false if it cannot dial
     */
    public boolean canDial() {
<span class="nc" id="L3772">        return impl.canDial();</span>
    }

    /**
     * On most platforms it is quite fast to draw on a mutable image and then render that
     * image, however some platforms have much slower mutable images in comparison to just
     * drawing on the screen. These platforms should return false here and Codename One will try
     * to use less mutable image related optimizations in transitions and other operations.
     *
     * @return true if mutable images are fast on this platform
     */
    public boolean areMutableImagesFast() {
<span class="fc" id="L3784">        return impl.areMutableImagesFast();</span>
    }

    /**
     * This method returns the platform Location Manager used for geofencing. This allows tracking the
     * user location in the background. Usage:
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/b0fa5280bde905a8f0cd.js&quot;&gt;&lt;/script&gt;
     * &lt;noscript&gt;&lt;pre&gt;{@code public class GeofenceListenerImpl implements GeofenceListener {
     * public void onExit(String id) {
     * System.out.println(&quot;Exited &quot;+id);
     * }
     *
     * public void onEntered(String id) {
     * System.out.println(&quot;Entered &quot;+id);
     * }
     * }
     * Form hi = new Form(&quot;Hi World&quot;);
     * hi.addComponent(new Label(&quot;Hi World&quot;));
     *
     * Location loc = new Location();
     * loc.setLatitude(51.5033630);
     * loc.setLongitude(-0.1276250);
     *
     * Geofence gf = new Geofence(&quot;test&quot;, loc, 100, 100000);
     *
     * LocationManager.getLocationManager().addGeoFencing(GeofenceListenerImpl.class, gf);
     *
     * hi.show();}&lt;/pre&gt;&lt;/noscript&gt;
     *
     * @return LocationManager Object
     */
    public LocationManager getLocationManager() {
<span class="fc" id="L3817">        return impl.getLocationManager();</span>
    }

    /**
     * This method tries to invoke the device native camera to capture images.
     * The method returns immediately and the response will be sent asynchronously
     * to the given ActionListener Object
     * The image is saved as a jpeg to a file on the device.
     * &lt;p&gt;
     * use this in the actionPerformed to retrieve the file path
     * String path = (String) evt.getSource();
     * &lt;p&gt;
     * if evt returns null the image capture was cancelled by the user.
     *
     * @param response a callback Object to retrieve the file path
     * @throws RuntimeException if this feature failed or unsupported on the platform
     */
    public void capturePhoto(ActionListener response) {
<span class="nc" id="L3835">        impl.capturePhoto(response);</span>
<span class="nc" id="L3836">    }</span>

    /**
     * This method tries to invoke the device native hardware to capture audio.
     * The method returns immediately and the response will be sent asynchronously
     * to the given ActionListener Object
     * The audio is saved to a file on the device.
     * &lt;p&gt;
     * use this in the actionPerformed to retrieve the file path
     * String path = (String) evt.getSource();
     *
     * @param response a callback Object to retrieve the file path
     * @throws RuntimeException if this feature failed or unsupported on the platform
     */
    public void captureAudio(ActionListener response) {
<span class="nc" id="L3851">        impl.captureAudio(response);</span>
<span class="nc" id="L3852">    }</span>

    /**
     * This method tries to invoke the device native hardware to capture audio.
     * The method returns immediately and the response will be sent asynchronously
     * to the given ActionListener Object
     * The audio is saved to a file on the device.
     * &lt;p&gt;
     * use this in the actionPerformed to retrieve the file path
     * String path = (String) evt.getSource();
     *
     * @param recordingOptions Audio recording options.
     * @param response         a callback Object to retrieve the file path
     * @throws RuntimeException if this feature failed or unsupported on the platform
     * @since 7.0
     */
    public void captureAudio(MediaRecorderBuilder recordingOptions, ActionListener response) {
<span class="nc" id="L3869">        impl.captureAudio(recordingOptions, response);</span>
<span class="nc" id="L3870">    }</span>

    /**
     * This method tries to invoke the device native camera to capture video.
     * The method returns immediately and the response will be sent asynchronously
     * to the given ActionListener Object
     * The video is saved to a file on the device.
     * &lt;p&gt;
     * use this in the actionPerformed to retrieve the file path
     * String path = (String) evt.getSource();
     *
     * @param response a callback Object to retrieve the file path
     * @throws RuntimeException if this feature failed or unsupported on the platform
     */
    public void captureVideo(ActionListener response) {
<span class="nc" id="L3885">        impl.captureVideo(response);</span>
<span class="nc" id="L3886">    }</span>

    /**
     * Same as {@link #captureVideo(com.codename1.ui.events.ActionListener) }, except that it
     * attempts to impose constraints on the capture.  Constraints include width, height,
     * and max length.  Not all platforms support capture constraints.  Use the {@link VideoCaptureConstraints#isSupported()}
     * to see if a constraint is supported.  If constraints are not supported at all, then this method
     * will fall back to calling {@link #captureVideo(com.codename1.ui.events.ActionListener) }.
     *
     * @param constraints Capture constraints to use.
     * @param response    a callback Object to retrieve the file path
     * @see com.codename1.capture.Capture#captureVideo(com.codename1.capture.VideoCaptureConstraints, com.codename1.ui.events.ActionListener)
     * @since 7.0
     */
    public void captureVideo(VideoCaptureConstraints constraints, ActionListener response) {
<span class="nc" id="L3901">        impl.captureVideo(constraints, response);</span>
<span class="nc" id="L3902">    }</span>

    /**
     * Opens the device image gallery
     * The method returns immediately and the response will be sent asynchronously
     * to the given ActionListener Object
     * &lt;p&gt;
     * use this in the actionPerformed to retrieve the file path
     * String path = (String) evt.getSource();
     *
     * @param response a callback Object to retrieve the file path
     * @throws RuntimeException if this feature failed or unsupported on the platform
     * @deprecated see openGallery instead
     */
    public void openImageGallery(ActionListener response) {
<span class="fc bfc" id="L3917" title="All 2 branches covered.">        if (pluginSupport.firePluginEvent(new OpenGalleryEvent(response, Display.GALLERY_IMAGE)).isConsumed()) {</span>
<span class="fc" id="L3918">            return;</span>
        }
<span class="fc" id="L3920">        impl.openImageGallery(response);</span>
<span class="fc" id="L3921">    }</span>

    /**
     * &lt;p&gt;Opens the device gallery to pick an image or a video.&lt;br&gt;
     * The method returns immediately and the response is sent asynchronously
     * to the given ActionListener Object as the source value of the event (as a String)&lt;/p&gt;
     *
     * &lt;p&gt;E.g. within the callback action performed call you can use this code: {@code String path = (String) evt.getSource();}.&lt;br&gt;
     * A more detailed sample of picking a video file can be seen here:
     * &lt;/p&gt;
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/fb73f5d47443052f8956.js&quot;&gt;&lt;/script&gt;
     * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/components-mediaplayer.png&quot; alt=&quot;Media player sample&quot; /&gt;
     *
     * &lt;p&gt;Version 5.0 and higher support multi-selection (i.e. the types {@link #GALLERY_IMAGE_MULTI}, {@link #GALLERY_VIDEO_MULTI}, and {@link #GALLERY_ALL_MULTI}).  When using one of the multiselection
     * types, the {@literal source} of the ActionEvent will be a {@code String[]}, containing the paths of the selected elements, or {@literal null} if the user cancelled the dialog.&lt;/p&gt;
     *
     * &lt;h4&gt;Platform support&lt;/h4&gt;
     * &lt;p&gt;Currently (version 5.0 and higher), all platforms support the types {@link #GALLERY_IMAGE}, {@link #GALLERY_VIDEO}, {@link #GALLERY_ALL}, {@link #GALLERY_IMAGE_MULTI}, {@link #GALLERY_VIDEO_MULTI}, {@link #GALLERY_ALL_MULTI}.  On iOS,
     * multi-selection requires a deployment target of iOS 8.0 or higher, so it is disabled by default.   You can enable multi-selection on iOS, by adding the {@literal ios.enableGalleryMultiselect=true} build hint.  This
     * build hint will be added automatically for you if you run your app in the simulator, and it calls {@literal openGallery()} with one of the multiselect gallery types.&lt;/p&gt;
     *
     * @param response a callback Object to retrieve the file path For multiselection types ({@link #GALLERY_IMAGE_MULTI}, {@link #GALLERY_VIDEO_MULTI}, and {@link #GALLERY_ALL_MULTI}), the {@literal source}
     *                 of the ActionEvent sent this callback will be a {@literal String[]}.  For other types, it will be a {@literal String}.  If the dialog was cancelled, it will be {@literal null}.
     * @param type     one of the following {@link #GALLERY_IMAGE}, {@link #GALLERY_VIDEO}, {@link #GALLERY_ALL}, {@link #GALLERY_IMAGE_MULTI}, {@link #GALLERY_VIDEO_MULTI}, {@link #GALLERY_ALL_MULTI}.
     * @throws RuntimeException if this feature failed or unsupported on the platform.  Use {@link #isGalleryTypeSupported(int) } to check if the type is supported before calling this method.
     * @see #isGalleryTypeSupported(int) To see if a type is supported on the current platform.
     */
    public void openGallery(ActionListener response, int type) {
<span class="fc bfc" id="L3950" title="All 2 branches covered.">        if (pluginSupport.firePluginEvent(new OpenGalleryEvent(response, type)).isConsumed()) {</span>
<span class="fc" id="L3951">            return;</span>
        }

<span class="fc" id="L3954">        impl.openGallery(response, type);</span>
<span class="fc" id="L3955">    }</span>

    /**
     * Checks to see if the given gallery type is supported on the current platform.
     *
     * @param type one of the following {@link #GALLERY_IMAGE}, {@link #GALLERY_VIDEO}, {@link #GALLERY_ALL}, {@link #GALLERY_IMAGE_MULTI}, {@link #GALLERY_VIDEO_MULTI}, {@link #GALLERY_ALL_MULTI}.
     * @return True if the type is supported
     * @see #openGallery(com.codename1.ui.events.ActionListener, int)
     */
    public boolean isGalleryTypeSupported(int type) {
<span class="fc" id="L3965">        IsGalleryTypeSupportedEvent evt = new IsGalleryTypeSupportedEvent(type);</span>
<span class="fc bfc" id="L3966" title="All 2 branches covered.">        if (pluginSupport.firePluginEvent(evt).isConsumed()) {</span>
<span class="fc" id="L3967">            return evt.getPluginEventResponse();</span>
        }
<span class="fc" id="L3969">        return impl.isGalleryTypeSupported(type);</span>
    }

    /**
     * Returns a 2-3 letter code representing the platform name for the platform override
     *
     * @return the name of the platform e.g. ios, rim, win, and, me, HTML5
     */
    public String getPlatformName() {
<span class="fc" id="L3978">        return impl.getPlatformName();</span>
    }

    /**
     * Returns the suffixes for ovr files that should be used when loading a layered resource file on this platform
     *
     * @return a string array with the proper order of resource override layers
     */
    public String[] getPlatformOverrides() {
<span class="nc" id="L3987">        return impl.getPlatformOverrides();</span>
    }

    /**
     * &lt;p&gt;Send an email using the platform mail client.&lt;br&gt;
     * The code below demonstrates sending a simple message with attachments using the devices
     * native email client:
     * &lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/3db47a2ff8b35cae6410.js&quot;&gt;&lt;/script&gt;
     *
     * @param recipients array of e-mail addresses
     * @param subject    e-mail subject
     * @param msg        the Message to send
     */
    public void sendMessage(String[] recipients, String subject, Message msg) {
<span class="nc" id="L4002">        impl.sendMessage(recipients, subject, msg);</span>
<span class="nc" id="L4003">    }</span>

    /**
     * Opens the device Dialer application with the given phone number
     *
     * @param phoneNumber
     */
    public void dial(String phoneNumber) {
<span class="nc" id="L4011">        impl.dial(phoneNumber);</span>
<span class="nc" id="L4012">    }</span>

    /**
     * &lt;p&gt;Indicates the level of SMS support in the platform as one of:
     * {@link #SMS_NOT_SUPPORTED} (for desktop, tablet etc.),
     * {@link #SMS_SEAMLESS} (no UI interaction), {@link #SMS_INTERACTIVE} (with compose UI),
     * {@link #SMS_BOTH}.&lt;br&gt;
     * The sample below demonstrates the use case for this property:
     * &lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/da23d33b1a9e105efffd.js&quot;&gt;&lt;/script&gt;
     *
     * @return one of the SMS_* values
     */
    public int getSMSSupport() {
<span class="nc" id="L4026">        return impl.getSMSSupport();</span>
    }

    /**
     * Sends a SMS message to the given phone number
     *
     * @param phoneNumber to send the sms
     * @param message     the content of the sms
     */
    public void sendSMS(String phoneNumber, String message) throws IOException {
<span class="nc" id="L4036">        impl.sendSMS(phoneNumber, message, false);</span>
<span class="nc" id="L4037">    }</span>

    /**
     * &lt;p&gt;Sends a SMS message to the given phone number, the code below demonstrates the logic
     * of detecting platform behavior for sending SMS.&lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/da23d33b1a9e105efffd.js&quot;&gt;&lt;/script&gt;
     *
     * @param phoneNumber to send the sms
     * @param message     the content of the sms
     * @param interactive indicates the SMS should show a UI or should not show a UI if applicable see getSMSSupport
     * @see #getSMSSupport()
     */
    public void sendSMS(String phoneNumber, String message, boolean interactive) throws IOException {
<span class="nc" id="L4050">        impl.sendSMS(phoneNumber, message, interactive);</span>
<span class="nc" id="L4051">    }</span>

    /**
     * Place a notification on the device status bar (if device has this
     * functionality).
     * Clicking the notification might re-start the Application.
     *
     * @param tickerText   the ticker text of the Notification
     * @param contentTitle the title of the Notification
     * @param contentBody  the content of the Notification
     * @param vibrate      enable/disable notification alert
     * @param flashLights  enable/disable notification flashing
     * @deprecated there is a new version of this method with a slightly improved
     * signature
     */
    public void notifyStatusBar(String tickerText, String contentTitle,
                                String contentBody, boolean vibrate, boolean flashLights) {
<span class="nc" id="L4068">        notifyStatusBar(tickerText, contentTitle, contentBody, vibrate, flashLights, null);</span>
<span class="nc" id="L4069">    }</span>

    /**
     * Indicates whether the notify status bar method will present a notification to the user
     *
     * @return true if the notify status bar method will present a notification to the user
     */
    public boolean isNotificationSupported() {
<span class="nc" id="L4077">        return impl.isNotificationSupported();</span>
    }

    /**
     * Place a notification on the device status bar (if device has this
     * functionality).
     * Clicking the notification might re-start the Application.
     *
     * @param tickerText   the ticker text of the Notification
     * @param contentTitle the title of the Notification
     * @param contentBody  the content of the Notification
     * @param vibrate      enable/disable notification alert
     * @param flashLights  enable/disable notification flashing
     * @param args         additional arguments to the notification
     * @return a platform native object that allows modifying notification state
     * @deprecated use scheduleLocalNotification instead
     */
    public Object notifyStatusBar(String tickerText, String contentTitle,
                                  String contentBody, boolean vibrate, boolean flashLights, Hashtable args) {
<span class="nc" id="L4096">        return impl.notifyStatusBar(tickerText, contentTitle, contentBody, vibrate, flashLights, args);</span>
    }

    /**
     * Removes the notification previously posted with the notify status bar method
     *
     * @param o the object returned from the notifyStatusBar method
     */
    public void dismissNotification(Object o) {
<span class="nc" id="L4105">        impl.dismissNotification(o);</span>
<span class="nc" id="L4106">    }</span>

    /**
     * Returns true if the underlying OS supports numeric badges on icons. Notice this is only available on iOS
     * and only when push notification is enabled
     *
     * @return true if the underlying OS supports numeric badges
     */
    public boolean isBadgingSupported() {
<span class="nc" id="L4115">        return impl.isBadgingSupported();</span>
    }

    /**
     * Sets the number that appears on the application icon in iOS
     *
     * @param number number to show on the icon
     */
    public void setBadgeNumber(int number) {
<span class="nc" id="L4124">        impl.setBadgeNumber(number);</span>
<span class="nc" id="L4125">    }</span>

    /**
     * Returns true if the underlying OS supports opening the native navigation
     * application
     *
     * @return true if the underlying OS supports launch of native navigation app
     */
    public boolean isOpenNativeNavigationAppSupported() {
<span class="nc" id="L4134">        return impl.isOpenNativeNavigationAppSupported();</span>
    }

    /**
     * Opens the native navigation app in the given coordinate.
     *
     * @param latitude
     * @param longitude
     */
    public void openNativeNavigationApp(double latitude, double longitude) {
<span class="nc" id="L4144">        impl.openNativeNavigationApp(latitude, longitude);</span>
<span class="nc" id="L4145">    }</span>

    /**
     * Opens the native navigation app with the given search location
     *
     * @param location the location to search for in the native navigation map
     */
    public void openNativeNavigationApp(String location) {
<span class="nc" id="L4153">        impl.openNativeNavigationApp(location);</span>
<span class="nc" id="L4154">    }</span>

    /**
     * Gets all contacts from the address book of the device
     *
     * @param withNumbers if true returns only contacts that has a number
     * @return array of contacts unique ids
     */
    public String[] getAllContacts(boolean withNumbers) {
<span class="nc" id="L4163">        return impl.getAllContacts(withNumbers);</span>
    }

    /**
     * &lt;p&gt;Notice: this method might be very slow and should be invoked on a separate thread!
     * It might have platform specific optimizations over getAllContacts followed by looping
     * over individual contacts but that isn't guaranteed. See isGetAllContactsFast for
     * information.&lt;br&gt;
     * The sample below demonstrates listing all the contacts within the device with their photos&lt;/p&gt;
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/15f39e1eef77f6059aff.js&quot;&gt;&lt;/script&gt;
     * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/contacts-with-photos.png&quot; alt=&quot;Contacts with the default photos on the simulator, on device these will use actual user photos when available&quot; /&gt;
     *
     * @param withNumbers      if true returns only contacts that has a number
     * @param includesFullName if true try to fetch the full name of the Contact(not just display name)
     * @param includesPicture  if true try to fetch the Contact Picture if exists
     * @param includesNumbers  if true try to fetch all Contact numbers
     * @param includesEmail    if true try to fetch all Contact Emails
     * @param includeAddress   if true try to fetch all Contact Addresses
     * @return array of the contacts
     */
    public Contact[] getAllContacts(boolean withNumbers, boolean includesFullName, boolean includesPicture, boolean includesNumbers, boolean includesEmail, boolean includeAddress) {
<span class="nc" id="L4185">        return impl.getAllContacts(withNumbers, includesFullName, includesPicture, includesNumbers, includesEmail, includeAddress);</span>
    }

    /**
     * Indicates if the getAllContacts is platform optimized, notice that the method
     * might still take seconds or more to run so you should still use a separate thread!
     *
     * @return true if getAllContacts will perform faster that just getting each contact
     */
    public boolean isGetAllContactsFast() {
<span class="nc" id="L4195">        return impl.isGetAllContactsFast();</span>
    }

    /**
     * Gets IDs of all contacts that are linked to a given contact.  Some platforms, like iOS, allow for multiple distinct contact records to be &quot;linked&quot; to indicate that they refer to the same person.
     *
     * @param c The contact whose &quot;linked&quot; contacts are to be retrieved.
     * @return IDs of linked contacts.
     */
    public String[] getLinkedContactIds(Contact c) {
<span class="nc" id="L4205">        return impl.getLinkedContactIds(c);</span>
    }

    /**
     * Get a Contact according to it's contact id.
     *
     * @param id unique id of the Contact
     * @return a Contact Object
     */
    public Contact getContactById(String id) {
<span class="nc" id="L4215">        return impl.getContactById(id);</span>
    }

    /**
     * Gets all of the contacts that are linked to this contact.  Some platforms, like iOS, allow for multiple distinct contact records to be &quot;linked&quot; to indicate that they refer to the same person.
     * @param c The contact whose &quot;linked&quot; contacts are to be retrieved.
     * @return Array of Contacts.  Should never be null, but may be a zero-sized array.
     * @see ContactsManager#getLinkedContacts(com.codename1.contacts.Contact)
     */
    //public Contact[] getLinkedContacts(Contact c) {
    //    return impl.getLinkedContacts(c);
    //}

    /**
     * &lt;p&gt;This method returns a Contact by the contact id and fills it's data
     * according to the given flags.&lt;br&gt;
     * The sample below demonstrates listing all the contacts within the device with their photos&lt;/p&gt;
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/15f39e1eef77f6059aff.js&quot;&gt;&lt;/script&gt;
     * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/contacts-with-photos.png&quot; alt=&quot;Contacts with the default photos on the simulator, on device these will use actual user photos when available&quot; /&gt;
     *
     * @param id               of the Contact
     * @param includesFullName if true try to fetch the full name of the Contact(not just display name)
     * @param includesPicture  if true try to fetch the Contact Picture if exists
     * @param includesNumbers  if true try to fetch all Contact numbers
     * @param includesEmail    if true try to fetch all Contact Emails
     * @param includeAddress   if true try to fetch all Contact Addresses
     * @return a Contact Object
     */
    public Contact getContactById(String id, boolean includesFullName,
                                  boolean includesPicture, boolean includesNumbers, boolean includesEmail,
                                  boolean includeAddress) {
<span class="nc" id="L4247">        return impl.getContactById(id, includesFullName, includesPicture,</span>
                includesNumbers, includesEmail, includeAddress);
    }

    /**
     * Some platforms allow the user to block contacts access on a per application basis this method
     * returns true if the user denied permission to access contacts. This can allow you to customize the error
     * message presented to the user.
     *
     * @return true if contacts access is allowed or globally available, false otherwise
     */
    public boolean isContactsPermissionGranted() {
<span class="nc" id="L4259">        return impl.isContactsPermissionGranted();</span>
    }

    /**
     * Create a contact to the device contacts book
     *
     * @param firstName   the Contact firstName
     * @param familyName  the Contact familyName
     * @param officePhone the Contact work phone or null
     * @param homePhone   the Contact home phone or null
     * @param cellPhone   the Contact mobile phone or null
     * @param email       the Contact email or null
     * @return the contact id if creation succeeded or null  if failed
     */
    public String createContact(String firstName, String familyName, String officePhone, String homePhone, String cellPhone, String email) {
<span class="nc" id="L4274">        return impl.createContact(firstName, familyName, officePhone, homePhone, cellPhone, email);</span>
    }

    /**
     * removed a contact from the device contacts book
     *
     * @param id the contact id to remove
     * @return true if deletion succeeded false otherwise
     */
    public boolean deleteContact(String id) {
<span class="nc" id="L4284">        return impl.deleteContact(id);</span>
    }

    /**
     * Indicates if the native video player includes its own play/pause etc. controls so the movie player
     * component doesn't need to include them
     *
     * @return true if the movie player component doesn't need to include such controls
     */
    public boolean isNativeVideoPlayerControlsIncluded() {
<span class="nc" id="L4294">        return impl.isNativeVideoPlayerControlsIncluded();</span>
    }

    /**
     * Indicates if the underlying platform supports sharing capabilities
     *
     * @return true if the underlying platform handles share.
     */
    public boolean isNativeShareSupported() {
<span class="nc" id="L4303">        return impl.isNativeShareSupported();</span>
    }

    /**
     * Share the required information using the platform sharing services.
     * a Sharing service can be: mail, sms, facebook, twitter,...
     * This method is implemented if isNativeShareSupported() returned true for
     * a specific platform.
     *
     * &lt;p&gt;Since 6.0, there is native sharing support in the Javascript port using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share&quot;&gt;navigator.share&lt;/a&gt;
     * API.  Currently (2019) this is only supported on Chrome for Android, and will only work if the app is accessed over https:.&lt;/p&gt;
     *
     * @param toShare String to share.
     * @deprecated use the method share that accepts an image and mime type
     */
    public void share(String toShare) {
<span class="nc" id="L4319">        share(toShare, null, null);</span>
<span class="nc" id="L4320">    }</span>

    /**
     * Share the required information using the platform sharing services.
     * a Sharing service can be: mail, sms, facebook, twitter,...
     * This method is implemented if isNativeShareSupported() returned true for
     * a specific platform.
     *
     * &lt;p&gt;Since 6.0, there is native sharing support in the Javascript port using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share&quot;&gt;navigator.share&lt;/a&gt;
     * API.  Currently (2019) this is only supported on Chrome for Android, and will only work if the app is accessed over https:.&lt;/p&gt;
     *
     * @param text     String to share.
     * @param image    file path to the image or null
     * @param mimeType type of the image or null if no image to share
     */
    public void share(String text, String image, String mimeType) {
<span class="nc" id="L4336">        share(text, image, mimeType, null);</span>

<span class="nc" id="L4338">    }</span>

    /**
     * Share the required information using the platform sharing services.
     * a Sharing service can be: mail, sms, facebook, twitter,...
     * This method is implemented if isNativeShareSupported() returned true for
     * a specific platform.
     *
     * &lt;p&gt;Since 6.0, there is native sharing support in the Javascript port using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share&quot;&gt;navigator.share&lt;/a&gt;
     * API.  Currently (2019) this is only supported on Chrome for Android, and will only work if the app is accessed over https:.&lt;/p&gt;
     *
     * &lt;p&gt;Since 8.0, you can share files using using the file path in the text parameter.  The file must exist in file system storage, and
     * you must define the appropriate mimeType in the mimeType parameter.  E.g. {@code share(&quot;file:/.../myfile.pdf&quot;, null, &quot;application.pdf&quot;) }&lt;/p&gt;
     *
     * @param textOrPath String to share, or path to file to share.
     * @param image      file path to the image or null
     * @param mimeType   type of the image or file.  null if just sharing text
     * @param sourceRect The source rectangle of the button that originated the share request.  This is used on
     *                   some platforms to provide a hint as to where the share dialog overlay should pop up.  Particularly,
     *                   on the iPad with iOS 8 and higher.
     */
    public void share(String textOrPath, String image, String mimeType, Rectangle sourceRect) {
<span class="nc" id="L4360">        impl.share(textOrPath, image, mimeType, sourceRect);</span>
<span class="nc" id="L4361">    }</span>

    /**
     * &lt;p&gt;The localization manager allows adapting values for display in different locales thru parsing and formatting
     * capabilities (similar to JavaSE's DateFormat/NumberFormat). It also includes language/locale/currency
     * related API's similar to Locale/currency API's from JavaSE.&lt;br&gt;
     * The sample code below just lists the various capabilities of the API:&lt;/p&gt;
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/6d93edd5e6b69e7c088a.js&quot;&gt;&lt;/script&gt;
     * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/l10n-manager.png&quot; alt=&quot;Localization formatting/parsing and information&quot; /&gt;
     *
     * @return an instance of the localization manager
     */
    public L10NManager getLocalizationManager() {
<span class="fc" id="L4375">        return impl.getLocalizationManager();</span>
    }

    /**
     * User register to receive push notification
     *
     * @param id         the id for the user
     * @param noFallback some devices don't support an efficient push API and will resort to polling
     *                   to provide push like functionality. If this flag is set to true no polling will occur and
     *                   the error PushCallback.REGISTRATION_ERROR_SERVICE_NOT_AVAILABLE will be sent to the push interface.
     * @deprecated use {@link #registerPush()} the Android push id should be set with the build hint {@code gcm.sender_id} which will work for Chrome JavaScript builds too
     */
    public void registerPush(String id, boolean noFallback) {
<span class="nc" id="L4388">        Hashtable h = new Hashtable();</span>
<span class="nc" id="L4389">        h.put(&quot;googlePlay&quot;, id);</span>
<span class="nc" id="L4390">        registerPush(h, noFallback);</span>
<span class="nc" id="L4391">    }</span>

    /**
     * Register to receive push notification, invoke this method once (ever) to receive push
     * notifications.
     *
     * @param metaData   meta data for push, this is relevant on some platforms such as google where
     *                   a push id is necessary,
     * @param noFallback some devices don't support an efficient push API and will resort to polling
     *                   to provide push like functionality. If this flag is set to true no polling will occur and
     *                   the error PushCallback.REGISTRATION_ERROR_SERVICE_NOT_AVAILABLE will be sent to the push interface.
     * @deprecated use {@link #registerPush()} the Android push id should be set with the build hint {@code gcm.sender_id} which will work for Chrome JavaScript builds too
     */
    public void registerPush(Hashtable metaData, boolean noFallback) {
<span class="nc bnc" id="L4405" title="All 2 branches missed.">        if (Preferences.get(&quot;push_id&quot;, (long) -1) == -1) {</span>
<span class="nc" id="L4406">            impl.registerPush(metaData, noFallback);</span>
        }
<span class="nc" id="L4408">    }</span>

    /**
     * Register to receive push notification, invoke this method once (ever) to receive push
     * notifications.
     */
    public void registerPush() {
<span class="nc" id="L4415">        impl.registerPush(new Hashtable(), false);</span>
<span class="nc" id="L4416">    }</span>

    /**
     * Stop receiving push notifications to this client application
     */
    public void deregisterPush() {
<span class="nc" id="L4422">        impl.deregisterPush();</span>
<span class="nc" id="L4423">    }</span>

    /**
     * Creates a Media recorder Object which will record from the device mic to
     * a file in the given path.
     * The output format will be amr-nb if supported by the platform.
     *
     * @param path a file path to where to store the recording, if the file does
     *             not exists it will be created.
     * @deprecated
     */
    public Media createMediaRecorder(String path) throws IOException {
<span class="nc" id="L4435">        return createMediaRecorder(path, getAvailableRecordingMimeTypes()[0]);</span>
    }

    /**
     * @param builder A MediaRecorderBuilder
     * @return a MediaRecorder
     * @throws IOException
     * @see MediaRecorderBuilder#build()
     * @since 7.0
     * @deprecated use MediaRecorderBuilder#build()
     */
    public Media createMediaRecorder(MediaRecorderBuilder builder) throws IOException {
<span class="fc" id="L4447">        return impl.createMediaRecorder(builder);</span>
    }

    /**
     * Creates a Media recorder Object which will record from the device mic to
     * a file in the given path.
     *
     * @param path     a file path to where to store the recording, if the file does
     *                 not exists it will be created.
     * @param mimeType the output mime type that is supported see
     *                 getAvailableRecordingMimeTypes()
     */
    public Media createMediaRecorder(String path, String mimeType) throws IOException {
<span class="fc" id="L4460">        return impl.createMediaRecorder(path, mimeType);</span>
    }

    /**
     * Returns the image IO instance that allows scaling image files.
     *
     * @return the image IO instance or null if image IO isn't supported for the given platform
     */
    public ImageIO getImageIO() {
<span class="fc" id="L4469">        return impl.getImageIO();</span>
    }

    /**
     * Gets the recording mime type for the returned Media from the
     * createMediaRecorder method
     *
     * @return the recording mime type
     * @deprecated see getAvailableRecordingMimeTypes() instead
     */
    public String getMediaRecorderingMimeType() {
<span class="nc" id="L4480">        return impl.getAvailableRecordingMimeTypes()[0];</span>
    }

    /**
     * Opens a database or create one if not exists.  On platforms where {@link #isDatabaseCustomPathSupported() }
     * this method can optionally accept a file path.
     *
     * @param databaseName the name of the database
     * @return Database Object or null if not supported on the platform
     * @throws IOException if database cannot be created
     */
    public Database openOrCreate(String databaseName) throws IOException {
<span class="nc" id="L4492">        return impl.openOrCreateDB(databaseName);</span>
    }

    public boolean isDatabaseCustomPathSupported() {
<span class="nc" id="L4496">        return impl.isDatabaseCustomPathSupported();</span>
    }

    /**
     * Deletes database
     *
     * @param databaseName the name of the database
     * @throws IOException if database cannot be deleted
     */
    public void delete(String databaseName) throws IOException {
<span class="nc" id="L4506">        impl.deleteDB(databaseName);</span>
<span class="nc" id="L4507">    }</span>

    /**
     * Indicates weather a database exists
     *
     * @param databaseName the name of the database
     * @return true if database exists
     */
    public boolean exists(String databaseName) {
<span class="nc" id="L4516">        return impl.existsDB(databaseName);</span>
    }

    /**
     * Returns the file path of the Database if support for database exists
     * on the platform.
     *
     * @param databaseName the name of the database with out / or path
     *                     elements e.g. {@code mydatabase.db}
     * @return the file path of the database or null if database isn't supported
     */
    public String getDatabasePath(String databaseName) {
<span class="nc" id="L4528">        return impl.getDatabasePath(databaseName);</span>
    }

    /**
     * Sets the frequency for polling the server in case of polling based push notification
     *
     * @param freq the frequency in milliseconds
     */
    public void setPollingFrequency(int freq) {
<span class="nc" id="L4537">        impl.setPollingFrequency(freq);</span>
<span class="nc" id="L4538">    }</span>

    /**
     * Start a Codename One thread that supports crash protection and similar Codename One features.
     *
     * @param r    runnable to run, &lt;b&gt;NOTICE&lt;/b&gt; the thread MUST be explicitly started!
     * @param name the name for the thread
     * @return a thread instance which must be explicitly started!
     */
    public Thread createThread(Runnable r, String name) {
<span class="nc" id="L4548">        return new CodenameOneThread(r, name);</span>
    }

    /**
     * Start a Codename One thread that supports crash protection and similar Codename One features.
     *
     * @param r    runnable to run, &lt;b&gt;NOTICE&lt;/b&gt; the thread MUST be explicitly started!
     * @param name the name for the thread
     * @return a thread instance which must be explicitly started!
     * @deprecated confusing name use {@link #createThread(java.lang.Runnable, java.lang.String)} instead
     */
    public Thread startThread(Runnable r, String name) {
<span class="fc" id="L4560">        return new CodenameOneThread(r, name);</span>
    }

    /**
     * Indicates if the title of the Form is native title(in android ICS devices
     * if the command behavior is native the ActionBar is used to display the title
     * and the menu)
     *
     * @return true if platform would like to show the Form title
     */
    public boolean isNativeTitle() {
<span class="fc" id="L4571">        return impl.isNativeTitle();</span>
    }

    /**
     * if the title is native(e.g the android action bar), notify the native title
     * that is needs to be refreshed
     */
    public void refreshNativeTitle() {
<span class="nc" id="L4579">        impl.refreshNativeTitle();</span>
<span class="nc" id="L4580">    }</span>

    /**
     * The crash reporter gets invoked when an uncaught exception is intercepted
     *
     * @return the crashReporter
     */
    public CrashReport getCrashReporter() {
<span class="nc" id="L4588">        return crashReporter;</span>
    }

    /**
     * The crash reporter gets invoked when an uncaught exception is intercepted
     *
     * @param crashReporter the crashReporter to set
     */
    public void setCrashReporter(CrashReport crashReporter) {
<span class="nc" id="L4597">        this.crashReporter = crashReporter;</span>
<span class="nc" id="L4598">    }</span>

    /**
     * Returns the UDID for devices that support it
     *
     * @return the UDID or null
     */
    public String getUdid() {
<span class="nc" id="L4606">        return impl.getUdid();</span>
    }

    /**
     * Returns the MSISDN for devices that expose it
     *
     * @return the msisdn or null
     */
    public String getMsisdn() {
<span class="nc" id="L4615">        return impl.getMsisdn();</span>
    }

    /**
     * Returns the native OS purchase implementation if applicable, if unavailable this
     * method will try to fallback to a custom purchase implementation and failing that
     * will return null
     *
     * @return instance of the purchase class or null
     */
    public Purchase getInAppPurchase() {
<span class="fc" id="L4626">        return impl.getInAppPurchase();</span>
    }

    /**
     * @deprecated use the version that accepts no arguments, the physical goods purchase is always
     * manual payment if applicable
     */
    public Purchase getInAppPurchase(boolean d) {
<span class="nc" id="L4634">        return getInAppPurchase();</span>
    }

    /**
     * Returns the native implementation of the code scanner or null
     *
     * @return code scanner instance
     * @deprecated Use the cn1-codescanner cn1lib.
     */
    public CodeScanner getCodeScanner() {
<span class="nc bnc" id="L4644" title="All 2 branches missed.">        if (!hasCamera()) {</span>
<span class="nc" id="L4645">            return null;</span>
        }
<span class="nc" id="L4647">        return impl.getCodeScanner();</span>
    }

    /**
     * Gets the available recording MimeTypes
     */
    public String[] getAvailableRecordingMimeTypes() {
<span class="fc" id="L4654">        return impl.getAvailableRecordingMimeTypes();</span>
    }

    /**
     * Checks if the device supports disabling the screen display from dimming, allowing
     * the developer to keep the screen display on.
     */
    public boolean isScreenSaverDisableSupported() {
<span class="nc" id="L4662">        return impl.isScreenLockSupported();</span>
    }

    /**
     * Checks is the scroll-wheel mouse is currently scrolling.  The scroll-wheel simulates pointer presses and drags
     * so there are cases when you are processing pointer events when you may want to know if it was driggered by
     * a scroll wheel.
     *
     * @return True if the scroll-wheel is responsible for current pointer events.
     * @since 8.0
     */
    public boolean isScrollWheeling() {
<span class="nc" id="L4674">        return impl.isScrollWheeling();</span>
    }

    /**
     * If isScreenSaverDisableSupported() returns true calling this method will
     * lock the screen display on
     *
     * @param e when set to true the screen saver will work as usual and when set to false the screen
     *          will not turn off automatically
     */
    public void setScreenSaverEnabled(boolean e) {
<span class="nc bnc" id="L4685" title="All 2 branches missed.">        if (e) {</span>
<span class="nc" id="L4686">            impl.unlockScreen();</span>
        } else {
<span class="nc" id="L4688">            impl.lockScreen();</span>
        }
<span class="nc" id="L4690">    }</span>

    /**
     * Returns true if the device has camera false otherwise.
     */
    public boolean hasCamera() {
<span class="nc" id="L4696">        return impl.hasCamera();</span>
    }

    /**
     * Indicates whether the native picker dialog is supported for the given type
     * which can include one of PICKER_TYPE_DATE_AND_TIME, PICKER_TYPE_TIME, PICKER_TYPE_DATE
     *
     * @param pickerType the picker type constant
     * @return true if the native platform supports this picker type
     */
    public boolean isNativePickerTypeSupported(int pickerType) {
<span class="nc" id="L4707">        return impl.isNativePickerTypeSupported(pickerType);</span>
    }

    /**
     * Shows a native modal dialog allowing us to perform the picking for the given type
     * which can include one of PICKER_TYPE_DATE_AND_TIME, PICKER_TYPE_TIME, PICKER_TYPE_DATE
     *
     * @param type         the picker type constant
     * @param source       the source component (optional) the native dialog will be placed in relation to this
     *                     component if applicable
     * @param currentValue the currently selected value
     * @param data         additional meta data specific to the picker type when applicable
     * @return the value from the picker or null if the operation was canceled.
     */
    public Object showNativePicker(int type, Component source, Object currentValue, Object data) {
<span class="nc" id="L4722">        return impl.showNativePicker(type, source, currentValue, data);</span>
    }

    /**
     * When set to true Codename One allows multiple hardware keys to be pressed at once,
     * this isn't on by default since it can trigger some complexities with UI navigation to/from
     * native code
     *
     * @return the multiKeyMode
     */
    public boolean isMultiKeyMode() {
<span class="nc" id="L4733">        return multiKeyMode;</span>
    }

    /**
     * When set to true Codename One allows multiple hardware keys to be pressed at once,
     * this isn't on by default since it can trigger some complexities with UI navigation to/from
     * native code
     *
     * @param multiKeyMode the multiKeyMode to set
     */
    public void setMultiKeyMode(boolean multiKeyMode) {
<span class="nc" id="L4744">        this.multiKeyMode = multiKeyMode;</span>
<span class="nc" id="L4745">    }</span>

    /**
     * Long pointer press is invoked after the given interval, this allows making long press events shorter/longer
     *
     * @return time in milliseconds
     */
    public int getLongPointerPressInterval() {
<span class="nc" id="L4753">        return longPressInterval;</span>
    }

    /**
     * Long pointer press is invoked after the given interval, this allows making long press events shorter/longer
     *
     * @param v time in milliseconds
     */
    public void setLongPointerPressInterval(int v) {
<span class="nc" id="L4762">        longPressInterval = v;</span>
<span class="nc" id="L4763">    }</span>

    /**
     * &lt;p&gt;Schedules a local notification that will occur after the given time elapsed.&lt;br&gt;
     * The sample below combines this with the geofence API to show a local notification
     * when entering a radius with the app in the background:&lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/shannah/a5592313da97e085822120af16518874.js&quot;&gt;&lt;/script&gt;
     *
     * @param n         The notification to schedule.
     * @param firstTime time in milliseconds when to schedule the notification
     * @param repeat    repeat one of the following: REPEAT_NONE, REPEAT_FIFTEEN_MINUTES,
     *                  REPEAT_HALF_HOUR, REPEAT_HOUR, REPEAT_DAY, REPEAT_WEEK
     */
    public void scheduleLocalNotification(LocalNotification n, long firstTime, int repeat) {
<span class="nc bnc" id="L4777" title="All 4 branches missed.">        if (n.getId() == null || n.getId().length() == 0) {</span>
<span class="nc" id="L4778">            throw new IllegalArgumentException(&quot;Notification ID must be set&quot;);</span>
        }
<span class="nc bnc" id="L4780" title="All 2 branches missed.">        if (firstTime &lt; System.currentTimeMillis()) {</span>
<span class="nc" id="L4781">            throw new IllegalArgumentException(&quot;Cannot schedule a notification to a past time&quot;);</span>
        }
<span class="nc bnc" id="L4783" title="All 6 branches missed.">        if (n.getAlertSound() != null &amp;&amp; n.getAlertSound().length() &gt; 0 &amp;&amp; !n.getAlertSound().startsWith(&quot;/notification_sound&quot;)) {</span>
<span class="nc" id="L4784">            throw new IllegalArgumentException(&quot;Alert sound file name must start with the 'notification_sound' prefix&quot;);</span>
        }
<span class="nc" id="L4786">        impl.scheduleLocalNotification(n, firstTime, repeat);</span>
<span class="nc" id="L4787">    }</span>

    /**
     * Cancels a local notification by ID.
     *
     * @param notificationId
     * @see com.codename1.notifications.LocalNotification
     */
    public void cancelLocalNotification(String notificationId) {
<span class="nc" id="L4796">        impl.cancelLocalNotification(notificationId);</span>
<span class="nc" id="L4797">    }</span>

    /**
     * Sets the preferred time interval between background fetches.  This is only a
     * preferred interval and is not guaranteed.  Some platforms, like iOS, maintain sovereign
     * control over when and if background fetches will be allowed. This number is used
     * only as a guideline.
     *
     * &lt;p&gt;&lt;strong&gt;This method must be called in order to activate background fetch.&lt;/strong&gt;&gt;&lt;/p&gt;
     * &lt;p&gt;Note: If the platform doesn't support background fetch (i.e. {@link #isBackgroundFetchSupported() } returns {@code false},
     * then this method does nothing.&lt;/p&gt;
     *
     * @param seconds The time interval in seconds.
     * @see #isBackgroundFetchSupported()
     * @see #getPreferredBackgroundFetchInterval(int) ()
     * @see com.codename1.background.BackgroundFetch
     */
    public void setPreferredBackgroundFetchInterval(int seconds) {
<span class="nc" id="L4815">        impl.setPreferredBackgroundFetchInterval(seconds);</span>
<span class="nc" id="L4816">    }</span>

    /**
     * Gets the preferred time (in seconds) between background fetches.
     *
     * @return The time interval in seconds.
     * @see #isBackgroundFetchSupported()
     * @see #setPreferredBackgroundFetchInterval(int)
     * @see com.codename1.background.BackgroundFetch
     */
    public int getPreferredBackgroundFetchInterval(int seconds) {
<span class="nc" id="L4827">        return impl.getPreferredBackgroundFetchInterval();</span>
    }

    /**
     * Checks to see if the current platform supports background fetch.
     *
     * @return True if the current platform supports background fetch.
     * @see #setPreferredBackgroundFetchInterval(int)
     * @see #getPreferredBackgroundFetchInterval(int) ()
     * @see com.codename1.background.BackgroundFetch
     */
    public boolean isBackgroundFetchSupported() {
<span class="nc" id="L4839">        return impl.isBackgroundFetchSupported();</span>
    }

    /**
     * Allows detecting development mode so debugging code and special cases can be used to simplify flow
     *
     * @return true if we are running in the simulator, false otherwise
     */
    public boolean isSimulator() {
<span class="fc" id="L4848">        return impl.isSimulator();</span>
    }

    /**
     * Creates an audio media that can be played in the background.
     *
     * @param uri the uri of the media can start with jar://, file://, http://
     *            (can also use rtsp:// if supported on the platform)
     * @return Media a Media Object that can be used to control the playback
     * of the media or null if background playing is not supported on the platform
     * @throws IOException if creation of media from the given URI has failed
     */
    public Media createBackgroundMedia(String uri) throws IOException {
<span class="fc" id="L4861">        return impl.createBackgroundMedia(uri);</span>
    }

    /**
     * Creates an audio media that can be played in the background.  This call is
     * asynchronous, so that it will return perhaps before the media object is ready.
     *
     * @param uri the uri of the media can start with jar://, file://, http://
     *            (can also use rtsp:// if supported on the platform)
     * @return Media a Media Object that can be used to control the playback
     * of the media or null if background playing is not supported on the platform
     */
    public AsyncResource&lt;Media&gt; createBackgroundMediaAsync(String uri) {
<span class="fc" id="L4874">        return impl.createBackgroundMediaAsync(uri);</span>
    }

    /**
     * Create a blur image from the given image.
     * The algorithm is gaussian blur - https://en.wikipedia.org/wiki/Gaussian_blur
     *
     * @param image  the image to blur
     * @param radius the radius to be used in the algorithm
     */
    public Image gaussianBlurImage(Image image, float radius) {
<span class="nc" id="L4885">        return impl.gaussianBlurImage(image, radius);</span>
    }

    /**
     * Returns true if gaussian blur is supported on this platform
     *
     * @return true if gaussian blur is supported.
     */
    public boolean isGaussianBlurSupported() {
<span class="nc" id="L4894">        return impl.isGaussianBlurSupported();</span>
    }

    /**
     * Refreshes the native list of contacts on devices that require this see {@link com.codename1.contacts.ContactsManager#refresh()}
     */
    public void refreshContacts() {
<span class="nc" id="L4901">        impl.refreshContacts();</span>
<span class="nc" id="L4902">    }</span>

    /**
     * Returns true if this device is jailbroken or rooted, false if not or unknown. Notice that this method isn't
     * accurate and can't detect all jailbreak/rooting cases
     *
     * @return true if this device is jailbroken or rooted, false if not or unknown.
     */
    public boolean isJailbrokenDevice() {
<span class="nc" id="L4911">        return impl.isJailbrokenDevice();</span>
    }

    /**
     * Returns the build hints for the simulator, this will only work in the debug environment and it's
     * designed to allow extensions/API's to verify user settings/build hints exist
     *
     * @return map of the build hints that isn't modified without the codename1.arg. prefix
     */
    public Map&lt;String, String&gt; getProjectBuildHints() {
<span class="nc" id="L4921">        return impl.getProjectBuildHints();</span>
    }

    /**
     * Sets a build hint into the settings while overwriting any previous value. This will only work in the
     * debug environment and it's designed to allow extensions/API's to verify user settings/build hints exist.
     * Important: this will throw an exception outside of the simulator!
     *
     * @param key   the build hint without the codename1.arg. prefix
     * @param value the value for the hint
     */
    public void setProjectBuildHint(String key, String value) {
<span class="nc" id="L4933">        impl.setProjectBuildHint(key, value);</span>
<span class="nc" id="L4934">    }</span>

    /**
     * Checks to see if you can prompt the user to install the app on their homescreen.
     * This is only relevant for the Javascript port with PWAs.  This is not a &quot;static&quot; property, as it
     * only returns true if the app is in a state that allows you to prompt the user.  E.g. if you have
     * previously prompted the user and they have declined, then this will return false.
     *
     * &lt;p&gt;Best practice is to use {@link #onCanInstallOnHomescreen(java.lang.Runnable) } to be notified
     * when you are allowed to prompt the user for installation.  Then call {@link #promptInstallOnHomescreen() }
     * inside that method - or sometime after.&lt;/p&gt;
     *
     * &lt;h3&gt;Example&lt;/h3&gt;
     * &lt;pre&gt;{@code
     * onCanInstallOnHomescreen(()-&gt;{
     *      if (canInstallOnHomescreen()) {
     *           if (promptInstallOnHomescreen()) {
     *               // User accepted installation
     *           } else {
     *               // user rejected installation
     *           }
     *      }
     * });
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * https://developers.google.com/web/fundamentals/app-install-banners/
     *
     * @return True if you are able to prompt the user to install the app on their homescreen.
     * @see #promptInstallOnHomescreen()
     * @see #onCanInstallOnHomescreen(java.lang.Runnable)
     */
    public boolean canInstallOnHomescreen() {
<span class="nc" id="L4966">        return impl.canInstallOnHomescreen();</span>
    }

    /**
     * Prompts the user to install this app on their homescreen.  This is only relevant in the
     * javascript port.
     *
     * @return The result of the user prompt.  {@literal true} if the user accepts the installation,
     * {@literal false} if they reject it.
     * @see #canInstallOnHomescreen()
     * @see #onCanInstallOnHomescreen(java.lang.Runnable)
     */
    public boolean promptInstallOnHomescreen() {
<span class="nc" id="L4979">        return impl.promptInstallOnHomescreen();</span>
    }

    /**
     * A callback fired when you are allowed to prompt the user to install the app on their homescreen.
     * Only relevant in the javascript port.
     *
     * @param r Runnable that will be run when/if you are permitted to prompt the user to install
     *          the app on their homescreen.
     */
    public void onCanInstallOnHomescreen(Runnable r) {
<span class="nc" id="L4990">        impl.onCanInstallOnHomescreen(r);</span>
<span class="nc" id="L4991">    }</span>

    /**
     * Captures a screenshot of the screen.
     *
     * @return An image of the screen, or null if it failed.
     * @since 7.0
     */
    public Image captureScreen() {
<span class="nc" id="L5000">        return impl.captureScreen();</span>
    }

    /**
     * Convenience method to schedule a task to run on the EDT after {@literal timeout}ms.
     *
     * @param timeout The timeout in milliseconds.
     * @param r       The task to run.
     * @return The Timer object that can be used to cancel the task.
     * @see #setInterval(int, java.lang.Runnable)
     * @since 7.0
     */
    public Timer setTimeout(int timeout, @Async.Schedule final Runnable r) {

<span class="nc" id="L5014">        Timer t = new Timer();</span>
<span class="nc" id="L5015">        t.schedule(new TimerTask() {</span>
            public void run() {
<span class="nc" id="L5017">                executeTimeoutRunnable(r);</span>
<span class="nc" id="L5018">            }</span>
        }, timeout);
<span class="nc" id="L5020">        return t;</span>
    }

    private void executeTimeoutRunnable(@Async.Execute Runnable r) {
<span class="nc" id="L5024">        CN.callSerially(r);</span>
<span class="nc" id="L5025">    }</span>

    /**
     * Convenience method to schedule a task to run on the EDT after {@literal period}ms
     * repeating every {@literal period}ms.
     *
     * @param period The delay and repeat in milliseconds.
     * @param r      The runnable to run on the EDT.
     * @return The timer object which can be used to cancel the task.
     * @see #setTimeout(int, java.lang.Runnable)
     * @since 7.0
     */
    public Timer setInterval(int period, @Async.Schedule final Runnable r) {
<span class="nc" id="L5038">        Timer t = new Timer();</span>
<span class="nc" id="L5039">        t.schedule(new TimerTask() {</span>
            public void run() {
<span class="nc" id="L5041">                executeTimeoutRunnable(r);</span>
<span class="nc" id="L5042">            }</span>
        }, period, period);


<span class="nc" id="L5046">        return t;</span>
    }

    /**
     * Gets a reference to an application-wide shared Javascript context that can be used for running
     * Javascript commands.  When running in the Javascript port, this Javascript context will be the
     * same context in which the application itself is running, so it gives you the ability to interact
     * with the browser and DOM directly using the familiar {@link BrowserComponent} API.
     *
     * &lt;p&gt;When running on other platforms, this shared context will be an off-screen browser component.&lt;/p&gt;
     *
     * &lt;p&gt;Sample code allowing user to execute arbitrary Javascript code inside the shared context:&lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/shannah/60040d9b3cc520b28bc1fef5e31afd31.js&quot;&gt;&lt;/script&gt;
     *
     * @return A shared BrowserComponent
     * @since 7.0
     */
    public BrowserComponent getSharedJavascriptContext() {
<span class="nc" id="L5064">        return impl.getSharedJavscriptContext();</span>
    }

<span class="nc" id="L5067">    private class EdtException extends RuntimeException {</span>
        private Throwable cause;
        private EdtException parent;

        public synchronized Throwable getCause() {
<span class="nc" id="L5072">            return cause;</span>
        }

        public void setCause(Throwable t) {
<span class="nc" id="L5076">            this.cause = t;</span>
<span class="nc" id="L5077">        }</span>

        private void throwRoot(Throwable cause) {
<span class="nc" id="L5080">            HashSet&lt;Throwable&gt; circuitCheck = new HashSet&lt;Throwable&gt;();</span>
<span class="nc" id="L5081">            circuitCheck.add(cause);</span>
<span class="nc" id="L5082">            EdtException root = this;</span>
<span class="nc bnc" id="L5083" title="All 2 branches missed.">            if (root != cause) {</span>
<span class="nc" id="L5084">                root.setCause(cause);</span>
<span class="nc" id="L5085">                circuitCheck.add(root);</span>
            } else {
<span class="nc" id="L5087">                root = (EdtException) cause;</span>
            }
<span class="nc bnc" id="L5089" title="All 2 branches missed.">            while (root.parent != null) {</span>
<span class="nc bnc" id="L5090" title="All 2 branches missed.">                if (circuitCheck.contains(root.parent)) {</span>
<span class="nc" id="L5091">                    break;</span>
                }
<span class="nc" id="L5093">                root.parent.setCause(root);</span>
<span class="nc" id="L5094">                circuitCheck.add(root.parent);</span>
<span class="nc" id="L5095">                root = root.parent;</span>
            }
<span class="nc" id="L5097">            throw root;</span>
        }

    }

    /**
     * A wrapper around Runnable that records the stack trace so that
     * if an exception occurs, it is easier to track it back to the original
     * source.
     */
    private class DebugRunnable implements Runnable {
        private final Runnable internal;
        private final EdtException exceptionWrapper;
        private DebugRunnable parentContext;
        private int depth;
        private int totalDepth;

<span class="nc" id="L5114">        DebugRunnable(Runnable internal) {</span>
<span class="nc" id="L5115">            this.internal = internal;</span>
<span class="nc" id="L5116">            this.parentContext = currentEdtContext;</span>
<span class="nc bnc" id="L5117" title="All 2 branches missed.">            if (parentContext != null) {</span>
<span class="nc" id="L5118">                depth = parentContext.depth + 1;</span>
<span class="nc" id="L5119">                totalDepth = parentContext.totalDepth + 1;</span>
            }

<span class="nc bnc" id="L5122" title="All 2 branches missed.">            if (isEnableAsyncStackTraces()) {</span>
<span class="nc" id="L5123">                exceptionWrapper = new EdtException();</span>

<span class="nc bnc" id="L5125" title="All 2 branches missed.">                if (parentContext != null) {</span>
<span class="nc bnc" id="L5126" title="All 2 branches missed.">                    if (depth &lt; MAX_ASYNC_EXCEPTION_DEPTH) {</span>
<span class="nc" id="L5127">                        exceptionWrapper.parent = parentContext.exceptionWrapper;</span>
<span class="nc" id="L5128">                        parentContext = null;</span>
                    } else {
<span class="nc" id="L5130">                        depth = 0;</span>
                    }
                }
            } else {
<span class="nc" id="L5134">                exceptionWrapper = null;</span>
<span class="nc" id="L5135">                parentContext = null;</span>
            }
<span class="nc" id="L5137">        }</span>


        public void run() {
<span class="nc bnc" id="L5141" title="All 2 branches missed.">            if (exceptionWrapper != null) {</span>
                try {
<span class="nc" id="L5143">                    currentEdtContext = this;</span>
<span class="nc" id="L5144">                    internal.run();</span>
<span class="nc" id="L5145">                } catch (RuntimeException t) {</span>
<span class="nc" id="L5146">                    exceptionWrapper.throwRoot(t);</span>
<span class="nc" id="L5147">                }</span>
            } else {
<span class="nc" id="L5149">                internal.run();</span>
            }
<span class="nc" id="L5151">        }</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>