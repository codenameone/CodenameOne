<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeofenceManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.location</a> &gt; <span class="el_source">GeofenceManager.java</span></div><h1>GeofenceManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, Codename One and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Codename One designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Codename One through http://www.codenameone.com/ if you
 * need additional information or have any questions.
 */
package com.codename1.location;

import com.codename1.io.Log;
import com.codename1.io.Storage;
import com.codename1.ui.Display;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * A utility class to simplify Geofencing in Codename One.  Using this class to manage
 * an app's Geofences works around the 20-region limit on iOS and 100-region limit on Android, so that
 * your app can monitor an unlimited number of Geofences simulataneously.
 *
 * &lt;h3&gt;How it Works&lt;/h3&gt;
 * &lt;p&gt;GeofenceManager maintains a &quot;bubble&quot; region around the current device location.  You may register
 * as many regions as you like to be monitored with GeofenceManager, but it will only register the regions
 * that intersect the current &quot;bubble&quot; region.  When you exit the bubble region, the GeofenceManager will clear all of the
 * previously registered regions, create a new bubble, and then register only those regions that intersect this
 * new bubble.&lt;/p&gt;
 *
 * &lt;p&gt;GeofenceManager uses {@link Storage} to maintain its own active list of regions.&lt;/p&gt;
 *
 * &lt;h3&gt;Limitations&lt;/h3&gt;
 * &lt;p&gt;GeofenceManager will only register 19 regions at a time, so if more than 19 regions intersect the current &quot;bubble&quot;
 * region, some of them won't make the cut.  You can set the radius of the &quot;bubble&quot; region using {@link #setBubbleRadius(int) }
 * to increase or decrease the &quot;bubble&quot; region area, so that no regions are left behind.&lt;/p&gt;
 *
 * &lt;p&gt;Although you can set any positive radius value you like, a typical Android or iOS device has a minimum effective
 * radius of about 100m.&lt;/p&gt;
 *
 * &lt;p&gt;Note: If your app uses GeofenceManager, you shouldn't also add your own Geofences manually using {@link LocationManager#addGeoFencing(java.lang.Class, com.codename1.location.Geofence) }
 * as your manual regions may conflict.&lt;/p&gt;
 *
 * &lt;h3&gt;Usage&lt;/h3&gt;
 * &lt;p&gt;
 * {@code
 * GeofenceManager mgr = GeofenceManager.getInstance();
 * mgr.setListenerClass(MyGeofenceListener.class);
 * mgr.add(geofence1, geofence2, geofence3);
 * mgr.update(10000);
 * }
 * &lt;p&gt;
 * And the MyGeofenceListener class should be an instance of Geofence.
 *
 * &lt;h3&gt;Reloading Geofences Upon Exiting Bubble&lt;/h3&gt;
 *
 * &lt;p&gt;While there is no absolute limit on the number of regions that you can register in GeofenceManager
 * simulataneously, since it is actually storing the list of Geofences in Storage, there is a practical limit.  E.g.
 * It probably wouldn't perform well if you stored several thousand at a time.  If you want to monitor large quantifies
 * of regions (thousands, or millions), you can simply respond to the {@link GeofenceListener#onExit(java.lang.String) } event
 * for the &quot;bubble&quot; region, and &quot;reload&quot; the GeofenceManager with new regions related to the device's current location.
 * You might load the new locations from a web-service, for example.  Use the {@link #isBubble(java.lang.String)} method
 * to check if the {@literal id} parameter is for the bubble region, and act accordintly.&lt;/p&gt;
 *
 * @author shannah
 */
public class GeofenceManager implements Iterable&lt;Geofence&gt; {
    //private GeoStreamerAsyncDataSource dataSource;
    private static final String STORAGE_KEY = &quot;$AsyncGeoStreamer.geofences$&quot;;
    private static final String ACTIVE_FENCES_KEY = &quot;$AsyncGeoStreamer.activegeofences$&quot;;
    private static final String CURRENT_ACTIVE_KEY = &quot;$AsyncGeoStreamer.currentActive&quot;;
    private static final String EXPIRATIONS_KEY = &quot;$AsyncGeoStreamer.expirations&quot;;
    private static final String LISTENER_CLASS_KEY = &quot;$AsyncGeoStreamer.listenerClass&quot;;
    private static final String BUBBLE_GEOFENCE_ID = &quot;$AsyncGeoStreamer.bubble&quot;;
    /**
     * Default timeout for getting location.
     */
    private static final int defaultTimeout = 10000;
<span class="fc" id="L97">    private static int MAX_ACTIVE_GEOFENCES = 19;</span>
    private static GeofenceManager instance;
    // Reference to the last bubble set.
    Geofence lastBubble;
    /**
     * The radius of the bubble region (in metres)
     */
<span class="fc" id="L104">    private int bubbleRadius = 1000;</span>
    /**
     * The bubble region expiraton time (duration).  Default -1 means no expiration.
     */
<span class="fc" id="L108">    private long bubbleExpiration = -1L;</span>
    /**
     * The Class that should be instantiated to handle Geofence events.
     */
    private Class&lt;GeofenceListener&gt; listenerClass;
    /**
     * Maintains list of currently registered geofence IDs.  Only the ones
     * that are actually currently registered with the OS.
     */
    private List&lt;String&gt; activeKeys;
    private Map&lt;String, Long&gt; expiryTimes;
    /**
     * Map of all currently registered fences.
     */
    private Map&lt;String, Geofence&gt; fences;
    private Map&lt;String, Geofence&gt; activeFences;

<span class="fc" id="L125">    private GeofenceManager() {</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        if (&quot;and&quot;.equals(Display.getInstance().getPlatformName())) {</span>
<span class="nc" id="L127">            MAX_ACTIVE_GEOFENCES = 99;</span>
        }
        // On simulator we need to force refresh because the
        // actual geofence timers aren't persisted
<span class="fc" id="L131">        update(defaultTimeout, true);</span>
<span class="fc" id="L132">    }</span>

    /**
     * Obtains reference to the singleton GeofenceManager
     *
     * @return
     */
    public static GeofenceManager getInstance() {
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (instance == null) {</span>
<span class="fc" id="L141">            instance = new GeofenceManager();</span>
        }
<span class="fc" id="L143">        return instance;</span>
    }

    private synchronized Map&lt;String, Long&gt; getExpiryTimes(boolean reload) {
<span class="pc bpc" id="L147" title="1 of 4 branches missed.">        if (reload || expiryTimes == null) {</span>
            try {
<span class="fc" id="L149">                expiryTimes = (Map) Storage.getInstance().readObject(EXPIRATIONS_KEY);</span>
<span class="nc" id="L150">            } catch (Throwable t) {</span>
<span class="fc" id="L151">            }</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">            if (expiryTimes == null) {</span>
<span class="fc" id="L153">                expiryTimes = new HashMap&lt;String, Long&gt;();</span>
            }

        }
<span class="fc" id="L157">        return expiryTimes;</span>
    }

    private synchronized void updateExpiryTimes(Geofence... geofences) {
<span class="fc" id="L161">        Map&lt;String, Long&gt; times = getExpiryTimes(false);</span>
<span class="fc" id="L162">        long now = System.currentTimeMillis();</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">        for (Geofence g : geofences) {</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">            if (g.getExpiration() &lt;= 0) {</span>
<span class="fc" id="L165">                times.put(g.getId(), -1L);</span>
            } else {
<span class="nc" id="L167">                times.put(g.getId(), now + g.getExpiration());</span>
            }
        }
<span class="fc" id="L170">        Storage.getInstance().writeObject(EXPIRATIONS_KEY, times);</span>

<span class="fc" id="L172">    }</span>

    private synchronized void purgeExpired() {
<span class="fc" id="L175">        long now = System.currentTimeMillis();</span>
<span class="fc" id="L176">        Map&lt;String, Long&gt; times = getExpiryTimes(false);</span>
<span class="fc" id="L177">        Map&lt;String, Geofence&gt; fences = getFences(false);</span>
<span class="fc" id="L178">        List&lt;String&gt; activeKeys = getActiveKeys(false);</span>
<span class="fc" id="L179">        Map&lt;String, Geofence&gt; activeFences = getActiveFences(false);</span>
<span class="fc" id="L180">        boolean saveFences = false;</span>
<span class="fc" id="L181">        boolean saveActive = false;</span>
<span class="fc" id="L182">        boolean saveActiveFences = false;</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        for (Map.Entry&lt;String, Long&gt; time : times.entrySet()) {</span>
<span class="pc bpc" id="L184" title="3 of 4 branches missed.">            if (time.getValue() &gt; 0L &amp;&amp; time.getValue() &lt; now) {</span>
<span class="nc" id="L185">                times.remove(time.getKey());</span>
<span class="nc bnc" id="L186" title="All 4 branches missed.">                if (!saveFences &amp;&amp; fences.containsKey(time.getKey())) {</span>
<span class="nc" id="L187">                    saveFences = true;</span>
                }
<span class="nc" id="L189">                fences.remove(time.getKey());</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">                while (activeKeys.remove(time.getKey())) {</span>
<span class="nc" id="L191">                    saveActive = true;</span>
                }
<span class="nc bnc" id="L193" title="All 2 branches missed.">                if (activeFences.containsKey(time.getKey())) {</span>
<span class="nc" id="L194">                    activeFences.remove(time.getKey());</span>
<span class="nc" id="L195">                    saveActiveFences = true;</span>
                }


            }
<span class="fc" id="L200">        }</span>

<span class="fc" id="L202">        Storage.getInstance().writeObject(EXPIRATIONS_KEY, times);</span>
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if (saveFences) {</span>
<span class="nc" id="L204">            saveFences();</span>
        }
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        if (saveActive) {</span>
<span class="nc" id="L207">            saveActiveKeys();</span>
        }
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        if (saveActiveFences) {</span>
<span class="nc" id="L210">            saveActiveFences();</span>
        }
<span class="fc" id="L212">    }</span>

    /**
     * Gets the radius of the &quot;bubble&quot; region, in metres.
     *
     * @return the bubbleRadius
     */
    public int getBubbleRadius() {
<span class="fc" id="L220">        return bubbleRadius;</span>
    }

    /**
     * Sets the radius of the &quot;bubble&quot; regin, in metres.  Default value is {@literal 1000}.
     *
     * @param bubbleRadius the bubbleRadius to set
     */
    public void setBubbleRadius(int bubbleRadius) {
<span class="nc" id="L229">        this.bubbleRadius = bubbleRadius;</span>
<span class="nc" id="L230">    }</span>

    /**
     * Gets the expiration duration (in milliseconds) of the bubble region.
     *
     * @return the bubbleExpiration
     */
    public long getBubbleExpiration() {
<span class="fc" id="L238">        return bubbleExpiration;</span>
    }

    /**
     * Sets the expiration duration (in milliseconds) of the bubble region.  Default is {@literal -1}
     * meaning &quot;No expiration&quot;.
     *
     * @param bubbleExpiration the bubbleExpiration to set
     */
    public void setBubbleExpiration(long bubbleExpiration) {
<span class="nc" id="L248">        this.bubbleExpiration = bubbleExpiration;</span>
<span class="nc" id="L249">    }</span>

    /**
     * Checks if the given ID is for the &quot;bubble&quot; region.
     *
     * @param id An ID to check.
     * @return True if {@literal id} is for the &quot;bubble&quot; region.
     */
    public boolean isBubble(String id) {
<span class="fc" id="L258">        return BUBBLE_GEOFENCE_ID.equals(id);</span>
    }

    /**
     * Gets the currently registered Listener class.
     *
     * @return
     */
    public synchronized Class&lt;? extends GeofenceListener&gt; getListenerClass() {
<span class="fc bfc" id="L267" title="All 2 branches covered.">        if (listenerClass == null) {</span>
<span class="fc" id="L268">            String className = (String) Storage.getInstance().readObject(LISTENER_CLASS_KEY);</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">            if (className != null) {</span>
                try {
<span class="nc" id="L271">                    listenerClass = (Class) Class.forName(className);</span>
<span class="nc" id="L272">                } catch (Throwable t) {</span>
<span class="nc" id="L273">                    Log.e(t);</span>
<span class="nc" id="L274">                }</span>
            }
        }
<span class="fc" id="L277">        return listenerClass;</span>
    }

    /**
     * Sets the GeofenceListener class that should receive Geofence events.
     *
     * @param c
     */
    public synchronized void setListenerClass(Class&lt;? extends GeofenceListener&gt; c) {
<span class="fc" id="L286">        listenerClass = (Class) c;</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (c == null) {</span>
<span class="fc" id="L288">            Storage.getInstance().deleteStorageFile(LISTENER_CLASS_KEY);</span>
        } else {
<span class="fc" id="L290">            Storage.getInstance().writeObject(LISTENER_CLASS_KEY, c.getName());</span>
        }
<span class="fc" id="L292">    }</span>

    /**
     * @return
     */
    private GeofenceListener getListener() {
<span class="nc" id="L298">        Class&lt;? extends GeofenceListener&gt; c = getListenerClass();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (c != null) {</span>
            try {
<span class="nc" id="L301">                return (GeofenceListener) c.newInstance();</span>
<span class="nc" id="L302">            } catch (Throwable t) {</span>
<span class="nc" id="L303">                Log.e(t);</span>
            }
        }
<span class="nc" id="L306">        return null;</span>
    }

    /**
     * Adds a set of regions to be monitored by GeofenceManager.
     *
     * @param geofence
     */
    public synchronized void add(Geofence... geofence) {
<span class="fc" id="L315">        Map&lt;String, Geofence&gt; fences = getFences(false);</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">        for (Geofence f : geofence) {</span>
<span class="fc" id="L317">            fences.put(f.getId(), f);</span>
        }
<span class="fc" id="L319">        saveFences();</span>
<span class="fc" id="L320">        updateExpiryTimes(geofence);</span>
<span class="fc" id="L321">    }</span>


    /**
     * Adds a set of regions to be monitored by GeofenceManager.
     *
     * @param geofences
     */
    public synchronized void add(Collection&lt;Geofence&gt; geofences) {
<span class="nc" id="L330">        add(geofences.toArray(new Geofence[geofences.size()]));</span>
<span class="nc" id="L331">    }</span>

    private synchronized List&lt;String&gt; getActiveKeys(boolean reload) {
<span class="pc bpc" id="L334" title="1 of 4 branches missed.">        if (reload || activeKeys == null) {</span>
<span class="fc" id="L335">            activeKeys = (List&lt;String&gt;) Storage.getInstance().readObject(CURRENT_ACTIVE_KEY);</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">            if (activeKeys == null) {</span>
<span class="fc" id="L337">                activeKeys = new ArrayList&lt;String&gt;();</span>
            }
        }
<span class="fc" id="L340">        return activeKeys;</span>
    }

    public synchronized boolean isCurrentlyActive(String id) {
<span class="fc" id="L344">        return getActiveKeys(false).contains(id);</span>
    }

    private synchronized void saveActiveKeys() {
<span class="fc" id="L348">        Storage.getInstance().writeObject(CURRENT_ACTIVE_KEY, getActiveKeys(false));</span>
<span class="fc" id="L349">    }</span>


    /**
     * Removes a set of regions (by ID) so that they will no longer be monitored.
     *
     * @param ids
     */
    public synchronized void remove(String... ids) {
<span class="fc" id="L358">        Map&lt;String, Geofence&gt; fences = getFences(false);</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">        for (String i : ids) {</span>
<span class="fc" id="L360">            fences.remove(i);</span>
        }
<span class="fc" id="L362">        saveFences();</span>
<span class="fc" id="L363">    }</span>

    public synchronized void remove(Collection&lt;String&gt; ids) {
<span class="nc" id="L366">        remove(ids.toArray(new String[ids.size()]));</span>
<span class="nc" id="L367">    }</span>

    /**
     * Removes all current regions.
     */
    public synchronized void clear() {
<span class="fc" id="L373">        Map&lt;String, Geofence&gt; fences = getFences(false);</span>
<span class="fc" id="L374">        fences.clear();</span>
<span class="fc" id="L375">        saveFences();</span>
<span class="fc" id="L376">    }</span>

    /**
     * Checks the number of regions that are currently being monitored.
     *
     * @return
     */
    public synchronized int size() {
<span class="fc" id="L384">        return getFences(false).size();</span>
    }

    /**
     * Returns the Geofences as a Map.
     *
     * @return
     */
    public synchronized Map&lt;String, Geofence&gt; asMap() {
<span class="fc" id="L393">        return getFences(false);</span>
    }

    /**
     * Returns the Geofences as a list.
     *
     * @return
     */
    public synchronized List&lt;Geofence&gt; asList() {
<span class="fc" id="L402">        return new ArrayList(getFences(false).values());</span>
    }

    /**
     * Returns all Geofences sorted by distance from the current location.
     *
     * @return
     */
    public synchronized List&lt;Geofence&gt; asSortedList() {
<span class="fc" id="L411">        List&lt;Geofence&gt; l = asList();</span>
<span class="fc" id="L412">        Location curr = LocationManager.getLocationManager().getLastKnownLocation();</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">        if (curr != null) {</span>
<span class="fc" id="L414">            Collections.sort(l, Geofence.createDistanceComparator(curr));</span>
        }
<span class="fc" id="L416">        return l;</span>
    }

    /**
     * Reloads geofences from storage.
     */
    public synchronized void refresh() {
<span class="nc" id="L423">        getFences(true);</span>
<span class="nc" id="L424">    }</span>

    private Geofence fromMap(Map&lt;String, Object&gt; m) {
<span class="nc" id="L427">        double lng = (Double) m.get(&quot;lng&quot;);</span>
<span class="nc" id="L428">        double lat = (Double) m.get(&quot;lat&quot;);</span>
<span class="nc" id="L429">        String id = (String) m.get(&quot;id&quot;);</span>
<span class="nc" id="L430">        int radius = (Integer) m.get(&quot;radius&quot;);</span>
<span class="nc" id="L431">        Long expiration = (Long) m.get(&quot;expiration&quot;);</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (expiration == null) {</span>
<span class="nc" id="L433">            expiration = -1L;</span>
        }
<span class="nc" id="L435">        Location l = new Location();</span>
<span class="nc" id="L436">        l.setLatitude(lat);</span>
<span class="nc" id="L437">        l.setLongitude(lng);</span>
<span class="nc" id="L438">        return new Geofence(id, l, radius, expiration);</span>
    }

    private Map&lt;String, Object&gt; toMap(Geofence g) {
<span class="fc" id="L442">        double lng = g.getLoc().getLongitude();</span>
<span class="fc" id="L443">        double lat = g.getLoc().getLatitude();</span>
<span class="fc" id="L444">        int radius = g.getRadius();</span>
<span class="fc" id="L445">        String id = g.getId();</span>
<span class="fc" id="L446">        HashMap&lt;String, Object&gt; out = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L447">        out.put(&quot;lng&quot;, lng);</span>
<span class="fc" id="L448">        out.put(&quot;lat&quot;, lat);</span>
<span class="fc" id="L449">        out.put(&quot;radius&quot;, radius);</span>
<span class="fc" id="L450">        out.put(&quot;id&quot;, id);</span>
<span class="fc" id="L451">        out.put(&quot;expiration&quot;, g.getExpiration());</span>
<span class="fc" id="L452">        return out;</span>
    }

    private synchronized Map&lt;String, Geofence&gt; getActiveFences(boolean reload) {
<span class="pc bpc" id="L456" title="1 of 4 branches missed.">        if (reload || activeFences == null) {</span>
<span class="fc" id="L457">            activeFences = new HashMap&lt;String, Geofence&gt;();</span>
<span class="fc" id="L458">            Map&lt;String, Map&gt; tmp = (Map) Storage.getInstance().readObject(ACTIVE_FENCES_KEY);</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">            if (tmp != null) {</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">                for (Map.Entry&lt;String, Map&gt; e : tmp.entrySet()) {</span>
<span class="nc" id="L461">                    activeFences.put(e.getKey(), fromMap(e.getValue()));</span>
<span class="nc" id="L462">                }</span>
            }
        }
<span class="fc" id="L465">        return activeFences;</span>
    }

    private synchronized void saveActiveFences() {
<span class="fc bfc" id="L469" title="All 2 branches covered.">        if (activeFences != null) {</span>
<span class="fc" id="L470">            Map&lt;String, Map&gt; out = new HashMap&lt;String, Map&gt;();</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">            for (Map.Entry&lt;String, Geofence&gt; f : activeFences.entrySet()) {</span>
<span class="fc" id="L472">                out.put(f.getValue().getId(), toMap(f.getValue()));</span>
<span class="fc" id="L473">            }</span>
<span class="fc" id="L474">            Storage.getInstance().writeObject(ACTIVE_FENCES_KEY, out);</span>
        }
<span class="fc" id="L476">    }</span>


    private synchronized Map&lt;String, Geofence&gt; getFences(boolean reload) {
<span class="pc bpc" id="L480" title="1 of 4 branches missed.">        if (reload || fences == null) {</span>
<span class="fc" id="L481">            fences = new HashMap&lt;String, Geofence&gt;();</span>
<span class="fc" id="L482">            Map&lt;String, Map&gt; tmp = (Map) Storage.getInstance().readObject(STORAGE_KEY);</span>
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">            if (tmp != null) {</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                for (Map.Entry&lt;String, Map&gt; e : tmp.entrySet()) {</span>
<span class="nc" id="L485">                    fences.put(e.getKey(), fromMap(e.getValue()));</span>
<span class="nc" id="L486">                }</span>
            }
        }
<span class="fc" id="L489">        return fences;</span>
    }

    private synchronized void saveFences() {
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">        if (fences != null) {</span>
<span class="fc" id="L494">            Map&lt;String, Map&gt; out = new HashMap&lt;String, Map&gt;();</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">            for (Map.Entry&lt;String, Geofence&gt; f : fences.entrySet()) {</span>
<span class="fc" id="L496">                out.put(f.getValue().getId(), toMap(f.getValue()));</span>
<span class="fc" id="L497">            }</span>
<span class="fc" id="L498">            Storage.getInstance().writeObject(STORAGE_KEY, out);</span>
        }
<span class="fc" id="L500">    }</span>

    private boolean isWithinRadius(Location l1, Location l2, int radius) {
<span class="fc bfc" id="L503" title="All 2 branches covered.">        return l1.getDistanceTo(l2) &lt;= radius;</span>
    }

    /**
     * Updates the active Geofences that are being monitored on the OS.  This should be called
     * after making changes to the set of Geofences you wish to monitor.
     *
     * @param timeout Timeout (in milliseconds)
     */
    public synchronized void update(int timeout) {
<span class="fc" id="L513">        update(timeout, false);</span>
<span class="fc" id="L514">    }</span>

    /**
     * Updates the active Geofences that are being monitored on the OS.  This should be called
     * after making changes to the set of Geofences you wish to monitor.
     *
     * @param timeout      Timeout (in milliseconds)
     * @param forceRefresh If true, then this will force removal and re-addition of all geofences.
     */
    public synchronized void update(int timeout, boolean forceRefresh) {
<span class="fc" id="L524">        Location here = LocationManager.getLocationManager().getCurrentLocationSync(timeout);</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">        if (here == null) {</span>
<span class="fc" id="L526">            LocationManager.getLocationManager().setBackgroundLocationListener(Listener.class);</span>
<span class="fc" id="L527">            return;</span>
        }
<span class="fc" id="L529">        LocationManager.getLocationManager().setBackgroundLocationListener(null);</span>
<span class="fc" id="L530">        List&lt;String&gt; activeIds = new ArrayList&lt;String&gt;(getActiveKeys(false));</span>
<span class="fc" id="L531">        List&lt;String&gt; activeKeys = getActiveKeys(false);</span>
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">        for (String id : activeIds) {</span>
<span class="nc" id="L533">            Geofence g = getFences(false).get(id);</span>
<span class="nc bnc" id="L534" title="All 4 branches missed.">            if (!forceRefresh &amp;&amp; g != null) {</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">                if (!isWithinRadius(g.getLoc(), here, getBubbleRadius() + g.getRadius())) {</span>
<span class="nc" id="L536">                    LocationManager.getLocationManager().removeGeoFencing(id);</span>
<span class="nc" id="L537">                    removeAll(activeKeys, id);</span>
<span class="nc" id="L538">                    activeFences.remove(id);</span>
                }
            } else {
<span class="nc" id="L541">                LocationManager.getLocationManager().removeGeoFencing(id);</span>
<span class="nc" id="L542">                removeAll(activeKeys, id);</span>
<span class="nc" id="L543">                activeFences.remove(id);</span>

            }

<span class="nc" id="L547">        }</span>

<span class="fc bfc" id="L549" title="All 2 branches covered.">        for (Geofence g : asSortedList()) {</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">            if (isWithinRadius(g.getLoc(), here, getBubbleRadius() + g.getRadius())) {</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">                if (activeKeys.size() &gt;= MAX_ACTIVE_GEOFENCES) {</span>
                    // only allowed 20 at a time
<span class="nc" id="L553">                    break;</span>
                }
<span class="fc" id="L555">                Geofence ag = getActiveFences(false).get(g.getId());</span>
<span class="pc bpc" id="L556" title="4 of 6 branches missed.">                if (forceRefresh || !activeKeys.contains(g.getId()) || !g.equals(ag)) {</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">                    if (!activeKeys.contains(g.getId())) {</span>
<span class="fc" id="L558">                        activeKeys.add(g.getId());</span>

                    }
<span class="fc" id="L561">                    activeFences.put(g.getId(), g);</span>
<span class="fc" id="L562">                    LocationManager.getLocationManager().addGeoFencing(Listener.class, g);</span>


                }
            }
<span class="fc" id="L567">        }</span>
<span class="fc" id="L568">        saveActiveKeys();</span>
<span class="fc" id="L569">        saveActiveFences();</span>
<span class="fc" id="L570">        Location hereCopy = new Location();</span>
<span class="fc" id="L571">        hereCopy.setLatitude(here.getLatitude());</span>
<span class="fc" id="L572">        hereCopy.setLongitude(here.getLongitude());</span>
<span class="fc" id="L573">        Geofence bubble = new Geofence(BUBBLE_GEOFENCE_ID, hereCopy, getBubbleRadius(), getBubbleExpiration());</span>
<span class="pc bpc" id="L574" title="1 of 4 branches missed.">        if (lastBubble == null || lastBubble.getLoc().getDistanceTo(bubble.getLoc()) &gt; Math.min(100, bubbleRadius + 1)) {</span>
<span class="fc" id="L575">            lastBubble = bubble;</span>
<span class="fc" id="L576">            LocationManager.getLocationManager().addGeoFencing(Listener.class, bubble);</span>
        }
<span class="fc" id="L578">        purgeExpired();</span>
<span class="fc" id="L579">    }</span>

    private void onExit(String id) {
<span class="nc" id="L582">        GeofenceListener l = getListener();</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (l != null) {</span>
<span class="nc" id="L584">            l.onExit(id);</span>
        }
<span class="nc bnc" id="L586" title="All 2 branches missed.">        if (BUBBLE_GEOFENCE_ID.equals(id)) {</span>
            // We are exiting our bubble
<span class="nc" id="L588">            update(defaultTimeout);</span>

        }
<span class="nc" id="L591">    }</span>

    private void removeAll(List l, Object o) {
<span class="nc bnc" id="L594" title="All 2 branches missed.">        while (l.remove(o)) ;</span>
<span class="nc" id="L595">    }</span>

    private void onEntered(String id) {
<span class="nc" id="L598">        GeofenceListener l = getListener();</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (l != null) {</span>
<span class="nc" id="L600">            l.onEntered(id);</span>
        }
<span class="nc" id="L602">    }</span>

    /**
     * Iterates over all geofences that are being monitored.
     *
     * @return
     */
    @Override
    public Iterator&lt;Geofence&gt; iterator() {
<span class="nc" id="L611">        return getFences(false).values().iterator();</span>
    }

    private void locationUpdated(Location location) {
<span class="nc" id="L615">        update(defaultTimeout);</span>
<span class="nc" id="L616">    }</span>

    /**
     * The Listener class that is registered to receive Geofence events.  This is
     * used internally by {@link GeofenceManager}.  It is only public because
     * {@link GeofenceListener} classes must be public.
     *
     * @deprecated For internal use only.
     */
<span class="nc" id="L625">    public static class Listener implements GeofenceListener, LocationListener {</span>

        @Override
        public void onExit(String id) {
<span class="nc" id="L629">            GeofenceManager.getInstance().onExit(id);</span>
<span class="nc" id="L630">        }</span>

        @Override
        public void onEntered(String id) {
<span class="nc" id="L634">            GeofenceManager.getInstance().onEntered(id);</span>
<span class="nc" id="L635">        }</span>

        @Override
        public void locationUpdated(Location location) {
<span class="nc" id="L639">            GeofenceManager.getInstance().locationUpdated(location);</span>
<span class="nc" id="L640">        }</span>

        @Override
        public void providerStateChanged(int newState) {
            //GeofenceManager.getInstance().providerStateChanged(newState);
<span class="nc" id="L645">        }</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>