<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Tree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.io.gzip</a> &gt; <span class="el_source">Tree.java</span></div><h1>Tree.java</h1><pre class="source lang-java linenums">/* -*-mode:java; c-basic-offset:2; -*- */
/*
Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright 
     notice, this list of conditions and the following disclaimer in 
     the documentation and/or other materials provided with the distribution.

  3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This program is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */

package com.codename1.io.gzip;

<span class="fc" id="L37">final class Tree {</span>
    // Bit length codes must not exceed MAX_BL_BITS bits
    static final int MAX_BL_BITS = 7;
    // end of block literal code
    static final int END_BLOCK = 256;
    // repeat previous bit length 3-6 times (2 bits of repeat count)
    static final int REP_3_6 = 16;
    // repeat a zero length 3-10 times  (3 bits of repeat count)
    static final int REPZ_3_10 = 17;
    // repeat a zero length 11-138 times  (7 bits of repeat count)
    static final int REPZ_11_138 = 18;
    // extra bits for each length code
<span class="fc" id="L49">    static final int[] extra_lbits = {</span>
            0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0
    };
    // extra bits for each distance code
<span class="fc" id="L53">    static final int[] extra_dbits = {</span>
            0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13
    };
    // extra bits for each bit length code
<span class="fc" id="L57">    static final int[] extra_blbits = {</span>
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7
    };
<span class="fc" id="L60">    static final byte[] bl_order = {</span>
            16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
    static final int Buf_size = 8 * 2;
    // see definition of array dist_code below
    static final int DIST_CODE_LEN = 512;
<span class="fc" id="L65">    static final byte[] _dist_code = {</span>
            0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8,
            8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10,
            10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
            11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
            12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
            13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
            13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
            14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
            14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
            14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
            15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
            15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
            15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17,
            18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
            23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
            26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
            26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
            27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
            27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
            28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
            28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
            28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
            29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
            29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
            29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
    };
<span class="fc" id="L93">    static final byte[] _length_code = {</span>
            0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12,
            13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
            17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
            19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
            21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
            22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
            23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
            25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
            26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
            26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
            27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
    };
<span class="fc" id="L108">    static final int[] base_length = {</span>
            0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
            64, 80, 96, 112, 128, 160, 192, 224, 0
    };
<span class="fc" id="L112">    static final int[] base_dist = {</span>
            0, 1, 2, 3, 4, 6, 8, 12, 16, 24,
            32, 48, 64, 96, 128, 192, 256, 384, 512, 768,
            1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576
    };
    static final private int MAX_BITS = 15;


    // The lengths of the bit length codes are sent in order of decreasing
    // probability, to avoid transmitting the lengths for unused bit
    // length codes.
    static final private int BL_CODES = 19;
    static final private int D_CODES = 30;
    static final private int LITERALS = 256;
    static final private int LENGTH_CODES = 29;
    static final private int L_CODES = (LITERALS + 1 + LENGTH_CODES);
    static final private int HEAP_SIZE = (2 * L_CODES + 1);
    short[] dyn_tree;      // the dynamic tree
    int max_code;      // largest code with non zero frequency
    StaticTree stat_desc;  // the corresponding static tree

    // Mapping from a distance to a distance code. dist is the distance - 1 and
    // must not have side effects. _dist_code[256] and _dist_code[257] are never
    // used.
    static int d_code(int dist) {
<span class="nc bnc" id="L137" title="All 2 branches missed.">        return ((dist) &lt; 256 ? _dist_code[dist] : _dist_code[256 + ((dist) &gt;&gt;&gt; 7)]);</span>
    }

    // Generate the codes for a given tree and bit counts (which need not be
    // optimal).
    // IN assertion: the array bl_count contains the bit length statistics for
    // the given tree and the field len is set for all tree elements.
    // OUT assertion: the field code is set for all tree elements of non
    //     zero code length.
    private static void gen_codes(
            short[] tree, // the tree to decorate
            int max_code, // largest code with non zero frequency
            short[] bl_count, // number of codes at each bit length
            short[] next_code) {
<span class="fc" id="L151">        short code = 0;            // running code value</span>
        int bits;                  // bit index
        int n;                     // code index

        // The distribution counts are first used to generate the code values
        // without bit reversal.
<span class="fc" id="L157">        next_code[0] = 0;</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">        for (bits = 1; bits &lt;= MAX_BITS; bits++) {</span>
<span class="fc" id="L159">            next_code[bits] = code = (short) ((code + bl_count[bits - 1]) &lt;&lt; 1);</span>
        }

        // Check that the bit counts in bl_count are consistent. The last code
        // must be all ones.
        //Assert (code + bl_count[MAX_BITS]-1 == (1&lt;&lt;MAX_BITS)-1,
        //        &quot;inconsistent bit counts&quot;);
        //Tracev((stderr,&quot;\ngen_codes: max_code %d &quot;, max_code));

<span class="fc bfc" id="L168" title="All 2 branches covered.">        for (n = 0; n &lt;= max_code; n++) {</span>
<span class="fc" id="L169">            int len = tree[n * 2 + 1];</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">            if (len == 0) continue;</span>
            // Now reverse the bits
<span class="fc" id="L172">            tree[n * 2] = (short) (bi_reverse(next_code[len]++, len));</span>
        }
<span class="fc" id="L174">    }</span>

    // Reverse the first len bits of a code, using straightforward code (a faster
    // method would use a table)
    // IN assertion: 1 &lt;= len &lt;= 15
    private static int bi_reverse(
            int code, // the value to invert
            int len   // its bit length
    ) {
<span class="fc" id="L183">        int res = 0;</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L185">            res |= code &amp; 1;</span>
<span class="fc" id="L186">            code &gt;&gt;&gt;= 1;</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">            if (i + 1 &lt; len) {</span>
<span class="fc" id="L188">                res &lt;&lt;= 1;</span>
            }
        }
<span class="fc" id="L191">        return res;</span>
    }

    // Compute the optimal bit lengths for a tree and update the total bit length
    // for the current block.
    // IN assertion: the fields freq and dad are set, heap[heap_max] and
    //    above are the tree nodes sorted by increasing frequency.
    // OUT assertions: the field len is set to the optimal bit length, the
    //     array bl_count contains the frequencies for each bit length.
    //     The length opt_len is updated; static_len is also updated if stree is
    //     not null.
    void gen_bitlen(Deflate s) {
<span class="fc" id="L203">        short[] tree = dyn_tree;</span>
<span class="fc" id="L204">        short[] stree = stat_desc.static_tree;</span>
<span class="fc" id="L205">        int[] extra = stat_desc.extra_bits;</span>
<span class="fc" id="L206">        int base = stat_desc.extra_base;</span>
<span class="fc" id="L207">        int max_length = stat_desc.max_length;</span>
        int h;              // heap index
        int n, m;           // iterate over the tree elements
        int bits;           // bit length
        int xbits;          // extra bits
        short f;            // frequency
<span class="fc" id="L213">        int overflow = 0;   // number of elements with bit length too large</span>

<span class="fc bfc" id="L215" title="All 2 branches covered.">        for (bits = 0; bits &lt;= MAX_BITS; bits++) s.bl_count[bits] = 0;</span>

        // In a first pass, compute the optimal bit lengths (which may
        // overflow in the case of the bit length tree).
<span class="fc" id="L219">        tree[s.heap[s.heap_max] * 2 + 1] = 0; // root of the heap</span>

<span class="fc bfc" id="L221" title="All 2 branches covered.">        for (h = s.heap_max + 1; h &lt; HEAP_SIZE; h++) {</span>
<span class="fc" id="L222">            n = s.heap[h];</span>
<span class="fc" id="L223">            bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">            if (bits &gt; max_length) {</span>
<span class="nc" id="L225">                bits = max_length;</span>
<span class="nc" id="L226">                overflow++;</span>
            }
<span class="fc" id="L228">            tree[n * 2 + 1] = (short) bits;</span>
            // We overwrite tree[n*2+1] which is no longer needed

<span class="fc bfc" id="L231" title="All 2 branches covered.">            if (n &gt; max_code) continue;  // not a leaf node</span>

<span class="fc" id="L233">            s.bl_count[bits]++;</span>
<span class="fc" id="L234">            xbits = 0;</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">            if (n &gt;= base) xbits = extra[n - base];</span>
<span class="fc" id="L236">            f = tree[n * 2];</span>
<span class="fc" id="L237">            s.opt_len += f * (bits + xbits);</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">            if (stree != null) s.static_len += f * (stree[n * 2 + 1] + xbits);</span>
        }
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (overflow == 0) return;</span>

        // This happens for example on obj2 and pic of the Calgary corpus
        // Find the first bit length which could increase:
        do {
<span class="nc" id="L245">            bits = max_length - 1;</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            while (s.bl_count[bits] == 0) bits--;</span>
<span class="nc" id="L247">            s.bl_count[bits]--;      // move one leaf down the tree</span>
<span class="nc" id="L248">            s.bl_count[bits + 1] += 2;   // move one overflow item as its brother</span>
<span class="nc" id="L249">            s.bl_count[max_length]--;</span>
            // The brother of the overflow item also moves one step up,
            // but this does not affect bl_count[max_length]
<span class="nc" id="L252">            overflow -= 2;</span>
        }
<span class="nc bnc" id="L254" title="All 2 branches missed.">        while (overflow &gt; 0);</span>

<span class="nc bnc" id="L256" title="All 2 branches missed.">        for (bits = max_length; bits != 0; bits--) {</span>
<span class="nc" id="L257">            n = s.bl_count[bits];</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">            while (n != 0) {</span>
<span class="nc" id="L259">                m = s.heap[--h];</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">                if (m &gt; max_code) continue;</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">                if (tree[m * 2 + 1] != bits) {</span>
<span class="nc" id="L262">                    s.opt_len += ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2];</span>
<span class="nc" id="L263">                    tree[m * 2 + 1] = (short) bits;</span>
                }
<span class="nc" id="L265">                n--;</span>
            }
        }
<span class="nc" id="L268">    }</span>

    // Construct one Huffman tree and assigns the code bit strings and lengths.
    // Update the total bit length for the current block.
    // IN assertion: the field freq is set for all tree elements.
    // OUT assertions: the fields len and code are set to the optimal bit length
    //     and corresponding code. The length opt_len is updated; static_len is
    //     also updated if stree is not null. The field max_code is set.
    void build_tree(Deflate s) {
<span class="fc" id="L277">        short[] tree = dyn_tree;</span>
<span class="fc" id="L278">        short[] stree = stat_desc.static_tree;</span>
<span class="fc" id="L279">        int elems = stat_desc.elems;</span>
        int n, m;          // iterate over heap elements
<span class="fc" id="L281">        int max_code = -1;   // largest code with non zero frequency</span>
        int node;          // new node being created

        // Construct the initial heap, with least frequent element in
        // heap[1]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
        // heap[0] is not used.
<span class="fc" id="L287">        s.heap_len = 0;</span>
<span class="fc" id="L288">        s.heap_max = HEAP_SIZE;</span>

<span class="fc bfc" id="L290" title="All 2 branches covered.">        for (n = 0; n &lt; elems; n++) {</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">            if (tree[n * 2] != 0) {</span>
<span class="fc" id="L292">                s.heap[++s.heap_len] = max_code = n;</span>
<span class="fc" id="L293">                s.depth[n] = 0;</span>
            } else {
<span class="fc" id="L295">                tree[n * 2 + 1] = 0;</span>
            }
        }

        // The pkzip format requires that at least one distance code exists,
        // and that at least one bit should be sent even if there is only one
        // possible code. So to avoid special checks later on we force at least
        // two codes of non zero frequency.
<span class="fc bfc" id="L303" title="All 2 branches covered.">        while (s.heap_len &lt; 2) {</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">            node = s.heap[++s.heap_len] = (max_code &lt; 2 ? ++max_code : 0);</span>
<span class="fc" id="L305">            tree[node * 2] = 1;</span>
<span class="fc" id="L306">            s.depth[node] = 0;</span>
<span class="fc" id="L307">            s.opt_len--;</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">            if (stree != null) s.static_len -= stree[node * 2 + 1];</span>
            // node is 0 or 1 so it does not have extra bits
        }
<span class="fc" id="L311">        this.max_code = max_code;</span>

        // The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
        // establish sub-heaps of increasing lengths:

<span class="fc bfc" id="L316" title="All 2 branches covered.">        for (n = s.heap_len / 2; n &gt;= 1; n--)</span>
<span class="fc" id="L317">            s.pqdownheap(tree, n);</span>

        // Construct the Huffman tree by repeatedly combining the least two
        // frequent nodes.

<span class="fc" id="L322">        node = elems;                 // next internal node of the tree</span>
        do {
            // n = node of least frequency
<span class="fc" id="L325">            n = s.heap[1];</span>
<span class="fc" id="L326">            s.heap[1] = s.heap[s.heap_len--];</span>
<span class="fc" id="L327">            s.pqdownheap(tree, 1);</span>
<span class="fc" id="L328">            m = s.heap[1];                // m = node of next least frequency</span>

<span class="fc" id="L330">            s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency</span>
<span class="fc" id="L331">            s.heap[--s.heap_max] = m;</span>

            // Create a new node father of n and m
<span class="fc" id="L334">            tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);</span>
<span class="fc" id="L335">            s.depth[node] = (byte) (Math.max(s.depth[n], s.depth[m]) + 1);</span>
<span class="fc" id="L336">            tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;</span>

            // and insert the new node in the heap
<span class="fc" id="L339">            s.heap[1] = node++;</span>
<span class="fc" id="L340">            s.pqdownheap(tree, 1);</span>
        }
<span class="fc bfc" id="L342" title="All 2 branches covered.">        while (s.heap_len &gt;= 2);</span>

<span class="fc" id="L344">        s.heap[--s.heap_max] = s.heap[1];</span>

        // At this point, the fields freq and dad are set. We can now
        // generate the bit lengths.

<span class="fc" id="L349">        gen_bitlen(s);</span>

        // The field len is now set, we can generate the bit codes
<span class="fc" id="L352">        gen_codes(tree, max_code, s.bl_count, s.next_code);</span>
<span class="fc" id="L353">    }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>