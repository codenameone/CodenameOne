<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlipTransition.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.ui.animations</a> &gt; <span class="el_source">FlipTransition.java</span></div><h1>FlipTransition.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, Codename One and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Codename One designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Codename One through http://www.codenameone.com/ if you
 * need additional information or have any questions.
 */
package com.codename1.ui.animations;

import com.codename1.ui.Component;
import com.codename1.ui.Display;
import com.codename1.ui.Form;
import com.codename1.ui.Graphics;
import com.codename1.ui.Image;
import com.codename1.ui.Transform;
import com.codename1.util.MathUtil;

/**
 * &lt;p&gt;A Transitions that flips between 2 components/forms using perspective transform where available.&lt;br&gt;
 * Notice that this looks rather different on devices as perspective transform is available there but isn't
 * on the simulator.
 * &lt;/p&gt;
 * &lt;script src=&quot;https://gist.github.com/codenameone/47602e679f61712693bd.js&quot;&gt;&lt;/script&gt;
 * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/transition-flip.jpg&quot; alt=&quot;Flip&quot; /&gt;
 *
 * @author Chen, Steve
 */
public class FlipTransition extends Transition {

    private static final int STATE_MOVE_AWAY = 1;
    private static final int STATE_FLIP = 2;
    private static final int STATE_MOVE_CLOSER = 3;

    // Assume supported optimistically
    // will be switched off in paint.
<span class="pc" id="L51">    private boolean perspectiveSupported = true;</span>

    private Image sourceBuffer;
    private Image destBuffer;

    // 0 is front, 1.0 is back
<span class="pc" id="L57">    private float flipState = 0f;</span>

    // 0 is at closest point (fills original bounds).
    // 1 is at farthest point (all of flip will be visible).
<span class="pc" id="L61">    private float zState = 0f;</span>
<span class="pc" id="L62">    private int transitionState = STATE_MOVE_AWAY;</span>

    private Motion motion;
<span class="pc" id="L65">    private final boolean firstFinished = false;</span>
<span class="pc" id="L66">    private final boolean started = false;</span>

<span class="pc" id="L68">    private int bgColor = -1;</span>

    private float zNear;
    private float zFar;

<span class="pc" id="L73">    private int duration = 200;</span>

    private Transform tmpTransform;
    private Transform perspectiveT;
    private Transform currTransform;

    /**
     * Creates  a Flip Transition
     */
<span class="fc" id="L82">    public FlipTransition() {</span>
<span class="fc" id="L83">    }</span>

    /**
     * Creates  a Flip Transition
     *
     * @param bgColor the color to paint in the background when the transition
     *                paints, use -1 to not paint a background color
     */
<span class="nc" id="L91">    public FlipTransition(int bgColor) {</span>
<span class="nc" id="L92">        this.bgColor = bgColor;</span>
<span class="nc" id="L93">    }</span>

    /**
     * Creates  a Flip Transition
     *
     * @param bgColor  the color to paint in the background when the transition
     *                 paints, use -1 to not paint a background color
     * @param duration the duration of the transition
     */
<span class="fc" id="L102">    public FlipTransition(int bgColor, int duration) {</span>
<span class="fc" id="L103">        this.bgColor = bgColor;</span>
<span class="fc" id="L104">        this.duration = duration;</span>
<span class="fc" id="L105">    }</span>

    @Override
    public void initTransition() {
<span class="fc" id="L109">        flipState = 0f;</span>
<span class="fc" id="L110">        transitionState = STATE_MOVE_AWAY;</span>
<span class="fc" id="L111">        zNear = 1600;</span>
<span class="fc" id="L112">        zFar = zNear + 3000;</span>

<span class="fc" id="L114">        Component source = getSource();</span>
<span class="fc" id="L115">        Component destination = getDestination();</span>
<span class="fc" id="L116">        int w = source.getWidth();</span>
<span class="fc" id="L117">        int h = source.getHeight();</span>

        // a transition might occur with illegal source or destination values (common with 
        // improper replace() calls, this may still be valid and shouldn't fail
<span class="pc bpc" id="L121" title="2 of 4 branches missed.">        if (w &lt;= 0 || h &lt;= 0) {</span>
<span class="nc" id="L122">            return;</span>
        }
<span class="fc" id="L124">        sourceBuffer = createMutableImage(source.getWidth(), source.getHeight());</span>
<span class="fc" id="L125">        paint(sourceBuffer.getGraphics(), source, -source.getAbsoluteX(), -source.getAbsoluteY());</span>

<span class="fc" id="L127">        destBuffer = createMutableImage(destination.getWidth(), destination.getHeight());</span>
<span class="fc" id="L128">        paint(destBuffer.getGraphics(), destination, -destination.getAbsoluteX(), -destination.getAbsoluteY());</span>


<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        if (source instanceof Form) {</span>
<span class="fc" id="L132">            setBgColor(0);</span>
        }

<span class="fc" id="L135">        motion = Motion.createLinearMotion(0, 100, duration);</span>
<span class="fc" id="L136">        motion.start();</span>

<span class="fc" id="L138">    }</span>

    @Override
    public boolean animate() {
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        if (motion == null) {</span>
<span class="nc" id="L143">            return false;</span>
        }
<span class="fc" id="L145">        int val = motion.getValue();</span>
<span class="pc bpc" id="L146" title="1 of 4 branches missed.">        switch (transitionState) {</span>
            case STATE_MOVE_AWAY: {
<span class="fc" id="L148">                zState = ((float) val) / 100f;</span>
<span class="pc bpc" id="L149" title="3 of 4 branches missed.">                if (motion.isFinished() || !perspectiveSupported) {</span>
<span class="fc" id="L150">                    transitionState = STATE_FLIP;</span>
<span class="fc" id="L151">                    motion = Motion.createLinearMotion(0, 180, duration);</span>
<span class="fc" id="L152">                    motion.start();</span>
                }
<span class="fc" id="L154">                return true;</span>
            }

            case STATE_FLIP: {
<span class="fc" id="L158">                double valInRadians = Math.PI / 180f * (double) val;</span>
<span class="fc" id="L159">                double projectedPos = Math.cos(valInRadians);</span>

<span class="fc" id="L161">                flipState = (float) ((-projectedPos) / 2.0 + 0.5);</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">                if (motion.isFinished()) {</span>
<span class="fc" id="L163">                    transitionState = STATE_MOVE_CLOSER;</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">                    if (perspectiveSupported) {</span>
<span class="fc" id="L165">                        motion = Motion.createLinearMotion(100, 0, duration);</span>
<span class="fc" id="L166">                        motion.start();</span>
                    } else {
<span class="nc" id="L168">                        return false;</span>
                    }
                }
<span class="fc" id="L171">                return true;</span>
            }

            case STATE_MOVE_CLOSER: {
<span class="fc" id="L175">                zState = ((float) val) / 100f;</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">                return !motion.isFinished();</span>

            }
            default:
<span class="nc" id="L180">                throw new RuntimeException(&quot;Invalid transition state&quot;);</span>


        }

    }

    private void makePerspectiveTransform(Transform t) {
<span class="nc" id="L188">        float displayH = Display.getInstance().getDisplayHeight();</span>
<span class="nc" id="L189">        float displayW = Display.getInstance().getDisplayWidth();</span>
        //double midX = (float)x+(float)w/2.0;
        //double midY = (float)y+(float)h/2.0;
<span class="nc" id="L192">        double fovy = 0.25;</span>

<span class="nc" id="L194">        t.setPerspective((float) fovy, displayW / displayH, zNear, zFar);</span>
<span class="nc" id="L195">    }</span>


    @Override
    public void paint(Graphics g) {
        // this can happen if a transition is cut short
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (destBuffer == null) {</span>
<span class="nc" id="L202">            return;</span>
        }
<span class="nc" id="L204">        int cx = g.getClipX();</span>
<span class="nc" id="L205">        int cy = g.getClipY();</span>
<span class="nc" id="L206">        int cw = g.getClipWidth();</span>
<span class="nc" id="L207">        int ch = g.getClipHeight();</span>
<span class="nc" id="L208">        int x = getSource().getAbsoluteX();</span>
<span class="nc" id="L209">        int y = getSource().getAbsoluteY();</span>
<span class="nc" id="L210">        int w = getSource().getWidth();</span>
<span class="nc" id="L211">        int h = getSource().getHeight();</span>
<span class="nc" id="L212">        g.setClip(x, y, w, h);</span>


<span class="nc bnc" id="L215" title="All 2 branches missed.">        if (getBgColor() &gt;= 0) {</span>
<span class="nc" id="L216">            int c = g.getColor();</span>
<span class="nc" id="L217">            g.setColor(getBgColor());</span>
<span class="nc" id="L218">            g.fillRect(x, y, w, h);</span>
<span class="nc" id="L219">            g.setColor(c);</span>
<span class="nc" id="L220">        } else {</span>
<span class="nc" id="L221">            getSource().paintBackgrounds(g);</span>
        }

<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (g.isPerspectiveTransformSupported()) {</span>
<span class="nc" id="L225">            float displayH = Display.getInstance().getDisplayHeight();</span>
<span class="nc" id="L226">            float displayW = Display.getInstance().getDisplayWidth();</span>
<span class="nc" id="L227">            double midX = (float) x + (float) w / 2.0;</span>
            //double midY = (float)y+(float)h/2.0;

<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (perspectiveT == null) {</span>
<span class="nc" id="L231">                perspectiveT = Transform.makeIdentity();</span>
            }
<span class="nc" id="L233">            makePerspectiveTransform(perspectiveT);</span>
<span class="nc" id="L234">            float[] bottomRight = perspectiveT.transformPoint(new float[]{displayW, displayH, zNear});</span>

<span class="nc bnc" id="L236" title="All 2 branches missed.">            if (currTransform == null) {</span>
<span class="nc" id="L237">                currTransform = Transform.makeTranslation(0, 0, 0);</span>
            } else {
<span class="nc" id="L239">                currTransform.setIdentity();</span>
            }


<span class="nc" id="L243">            float xfactor = -displayW / bottomRight[0];</span>
<span class="nc" id="L244">            float yfactor = -displayH / bottomRight[1];</span>


<span class="nc" id="L247">            currTransform.scale(xfactor, yfactor, 0f);</span>
<span class="nc" id="L248">            currTransform.translate((x + w / 2) / xfactor, (y + h / 2) / yfactor, 0);</span>

<span class="nc" id="L250">            currTransform.concatenate(perspectiveT);</span>

<span class="nc" id="L252">            float cameraZ = -zNear - w / 2 * zState;</span>
<span class="nc" id="L253">            float cameraX = -x - w / 2;</span>
<span class="nc" id="L254">            float cameraY = -y - h / 2;</span>
<span class="nc" id="L255">            currTransform.translate(cameraX, cameraY, cameraZ);</span>

<span class="nc bnc" id="L257" title="All 2 branches missed.">            if (transitionState == STATE_FLIP) {</span>
<span class="nc" id="L258">                currTransform.translate((float) midX, y, 0);</span>
            }

<span class="nc" id="L261">            Image img = null;</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">            if (flipState &lt; 0.5) {</span>
<span class="nc" id="L263">                img = sourceBuffer;</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">                if (transitionState == STATE_FLIP) {</span>
                    // We are showing the front image
                    // We will rotate it up to 90 degrees
                    // 0 -&gt; 0 degrees
                    // 0.5 -&gt; 90 degress
<span class="nc" id="L269">                    double sin = flipState * 2.0;</span>
<span class="nc" id="L270">                    double angle = MathUtil.asin(sin);</span>

<span class="nc" id="L272">                    currTransform.rotate((float) angle, 0, 1, 0);// rotate about y axis</span>
<span class="nc" id="L273">                }</span>
            } else {
<span class="nc" id="L275">                img = destBuffer;</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">                if (transitionState == STATE_FLIP) {</span>
                    // We are showing the back image
                    // We are showing the back of the image
                    //  We will rotate it from 90 degrees back to 0
                    // 0.5 -&gt; 90 degrees
                    // 1.0 -&gt; 0 degrees
<span class="nc" id="L282">                    double sin = (1.0 - flipState) * 2.0;</span>
<span class="nc" id="L283">                    double angle = Math.PI - MathUtil.asin(sin);</span>
<span class="nc" id="L284">                    currTransform.rotate((float) angle, 0, 1, 0);// rotate about y axis</span>
                }
            }
<span class="nc bnc" id="L287" title="All 2 branches missed.">            if (transitionState == STATE_FLIP) {</span>
<span class="nc" id="L288">                currTransform.translate(-(float) midX, -y, 0);</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">                if (flipState &gt;= 0.5f) {</span>
                    // The rotation will leave the destination image flipped
                    // backwards, so we need to transform it to be the 
                    // mirror image
<span class="nc" id="L293">                    currTransform.scale(-1, 1, 1);</span>
<span class="nc" id="L294">                    currTransform.translate(-2 * x - w, 0, 0);</span>
                }
            }
<span class="nc bnc" id="L297" title="All 2 branches missed.">            if (tmpTransform == null) {</span>
<span class="nc" id="L298">                tmpTransform = Transform.makeIdentity();</span>
            }
<span class="nc" id="L300">            g.getTransform(tmpTransform);</span>
<span class="nc" id="L301">            g.setTransform(currTransform);</span>
<span class="nc" id="L302">            g.drawImage(img, x, y, w, h);</span>
<span class="nc" id="L303">            g.setTransform(tmpTransform);</span>
<span class="nc" id="L304">        } else {</span>
<span class="nc" id="L305">            perspectiveSupported = false;</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (flipState &lt; 0.5) {</span>
<span class="nc" id="L307">                int frontX = x + (int) (flipState * (float) w);</span>
<span class="nc" id="L308">                int frontWidth = (int) ((float) w * (1.0 - flipState * 2.0));</span>
<span class="nc" id="L309">                g.drawImage(sourceBuffer, frontX, y, frontWidth, h);</span>
<span class="nc" id="L310">            } else {</span>
<span class="nc" id="L311">                double backState = 1.0 - flipState;</span>
<span class="nc" id="L312">                int backX = x + (int) (backState * (float) w);</span>
<span class="nc" id="L313">                int backWidth = (int) ((float) w * (1.0 - backState * 2.0));</span>
<span class="nc" id="L314">                g.drawImage(destBuffer, backX, y, backWidth, h);</span>
            }
        }
<span class="nc" id="L317">        g.setClip(cx, cy, cw, ch);</span>
<span class="nc" id="L318">    }</span>

    private Image createMutableImage(int w, int h) {
<span class="fc" id="L321">        Display d = Display.getInstance();</span>
<span class="fc" id="L322">        return Image.createImage(Math.min(d.getDisplayWidth(), w), Math.min(d.getDisplayHeight(), h));</span>
    }

    private void paint(Graphics g, Component cmp, int x, int y) {
<span class="fc" id="L326">        paint(g, cmp, x, y, false);</span>
<span class="fc" id="L327">    }</span>

    private void paint(Graphics g, Component cmp, int x, int y, boolean background) {
<span class="fc" id="L330">        int cx = g.getClipX();</span>
<span class="fc" id="L331">        int cy = g.getClipY();</span>
<span class="fc" id="L332">        int cw = g.getClipWidth();</span>
<span class="fc" id="L333">        int ch = g.getClipHeight();</span>
<span class="fc" id="L334">        g.translate(x, y);</span>
<span class="fc" id="L335">        cmp.paintComponent(g, background);</span>
<span class="fc" id="L336">        g.translate(-x, -y);</span>

<span class="fc" id="L338">        g.setClip(cx, cy, cw, ch);</span>
<span class="fc" id="L339">    }</span>

    public void cleanup() {
<span class="fc" id="L342">        sourceBuffer = null;</span>
<span class="fc" id="L343">        destBuffer = null;</span>

<span class="fc" id="L345">    }</span>

    /**
     * The duration for the flip transition
     *
     * @return the duration
     */
    public int getDuration() {
<span class="fc" id="L353">        return duration;</span>
    }

    /**
     * The duration for the flip transition
     *
     * @param duration the duration to set
     */
    public void setDuration(int duration) {
<span class="fc" id="L362">        this.duration = duration;</span>
<span class="fc" id="L363">    }</span>

    /**
     * The background color that is painted behind the flipping effect or -1 to use the paintBackgrounds method instead
     *
     * @return the bgColor
     */
    public int getBgColor() {
<span class="fc" id="L371">        return bgColor;</span>
    }

    /**
     * The background color that is painted behind the flipping effect or -1 to use the paintBackgrounds method instead
     *
     * @param bgColor the bgColor to set
     */
    public void setBgColor(int bgColor) {
<span class="fc" id="L380">        this.bgColor = bgColor;</span>
<span class="fc" id="L381">    }</span>

    /**
     * {@inheritDoc}
     *
     * @param reverse {@inheritDoc}
     * @return {@inheritDoc}
     */
    @Override
    public Transition copy(boolean reverse) {
<span class="fc" id="L391">        return new FlipTransition(bgColor, duration);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>